[
    {
        "namespace": "10.utils.add_logging_level",
        "prompt": [
            "I will provide you with a code snippet to reuse and a json file containing required adaptations.You should adapt the snippet into a target code base according to the description of adaptations one by one.Some related code from the target code base is provided for reference.\n\n### Reused Snippet:\n```python\ndef addLoggingLevel(levelName, levelNum, methodName=None):\n    \"\"\"\n    Comprehensively adds a new logging level to the `logging` module and the\n    currently configured logging class.\n\n    `levelName` becomes an attribute of the `logging` module with the value\n    `levelNum`. `methodName` becomes a convenience method for both `logging`\n    itself and the class returned by `logging.getLoggerClass()` (usually just\n    `logging.Logger`). If `methodName` is not specified, `levelName.lower()` is\n    used.\n\n    To avoid accidental clobberings of existing attributes, this method will\n    raise an `AttributeError` if the level name is already an attribute of the\n    `logging` module or if the method name is already present \n\n    Example\n    -------\n    >>> addLoggingLevel('TRACE', logging.DEBUG - 5)\n    >>> logging.getLogger(__name__).setLevel(\"TRACE\")\n    >>> logging.getLogger(__name__).trace('that worked')\n    >>> logging.trace('so did this')\n    >>> logging.TRACE\n    5\n\n    \"\"\"\n    if not methodName:\n        methodName = levelName.lower()\n\n    if hasattr(logging, levelName):\n       raise AttributeError('{} already defined in logging module'.format(levelName))\n    if hasattr(logging, methodName):\n       raise AttributeError('{} already defined in logging module'.format(methodName))\n    if hasattr(logging.getLoggerClass(), methodName):\n       raise AttributeError('{} already defined in logger class'.format(methodName))\n\n    # This method was inspired by the answers to Stack Overflow post\n    # http://stackoverflow.com/q/2183233/2988730, especially\n    # http://stackoverflow.com/a/13638084/2988730\n    def logForLevel(self, message, *args, **kwargs):\n        if self.isEnabledFor(levelNum):\n            self._log(levelNum, message, args, **kwargs)\n    def logToRoot(message, *args, **kwargs):\n        logging.log(levelNum, message, *args, **kwargs)\n\n    logging.addLevelName(levelNum, levelName)\n    setattr(logging, levelName, levelNum)\n    setattr(logging.getLoggerClass(), methodName, logForLevel)\n    setattr(logging, methodName, logToRoot)\n\n```\n\n\n### Adaptations Required to Perform:\n```json\n[{'id': 0, 'type': 'Refactoring', 'description': 'Add type annotations to the parameters and return type of the add_logging_level function for better type checking and readability.'}, {'id': 1, 'type': 'Method_Signature', 'description': \"Change function name from 'addLoggingLevel' to 'add_logging_level' to follow snake_case naming convention.\"}, {'id': 2, 'type': 'Logic', 'description': \"Add a new method 'adapterLog' to handle logging for LoggerAdapter instances.\"}, {'id': 3, 'type': 'Logic', 'description': 'Include a new attribute to add the custom logging method to LoggerAdapter instances.'}]\n```\n\n\n### Related Code For Reference:\n[Start of Imports]\n```python\nfrom typing import List, Optional\nimport logging\n```\n[End of Imports]\n\nPlease write out function after adaptation in the following section:\n### Adapted Function:"
        ]
    }
]
