{
    "items": [
        {
            "tags": [
                "python"
            ],
            "comments": [
                {
                    "owner": {
                        "account_id": 29910,
                        "reputation": 114373,
                        "user_id": 81179,
                        "user_type": "registered",
                        "accept_rate": 100,
                        "display_name": "ChristopheD"
                    },
                    "edited": false,
                    "score": 2,
                    "creation_date": 1278975788,
                    "post_id": 3232943,
                    "comment_id": 3337596,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth#comment3337596_3232943",
                    "body": "Is the nesting always three levels deep or can you have nesting of an arbitrary depth?"
                },
                {
                    "owner": {
                        "account_id": 136601,
                        "reputation": 3753,
                        "user_id": 340212,
                        "user_type": "registered",
                        "accept_rate": 48,
                        "display_name": "jay_t"
                    },
                    "edited": false,
                    "score": 3,
                    "creation_date": 1279007754,
                    "post_id": 3232943,
                    "comment_id": 3340113,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth#comment3340113_3232943",
                    "body": "It can have any depth/length."
                },
                {
                    "owner": {
                        "account_id": 5303006,
                        "reputation": 890,
                        "user_id": 4231932,
                        "user_type": "registered",
                        "accept_rate": 83,
                        "display_name": "Alexander McNulty"
                    },
                    "edited": false,
                    "score": 2,
                    "creation_date": 1553193243,
                    "post_id": 3232943,
                    "comment_id": 97303919,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth#comment97303919_3232943",
                    "body": "Correct me if I\u2019m wrong but it seems like the ideal solution here requires implementation of the composite design pattern."
                },
                {
                    "owner": {
                        "account_id": 642441,
                        "reputation": 668,
                        "user_id": 423560,
                        "user_type": "registered",
                        "display_name": "Samantha Atkins"
                    },
                    "edited": false,
                    "score": 0,
                    "creation_date": 1656550312,
                    "post_id": 3232943,
                    "comment_id": 128602986,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth#comment128602986_3232943",
                    "body": "In the general case this may not be well defined unless you have the update take additional arguments[s] specifying key paths to preserve.    A possible interesting sort of deep update is a merge_update preserving what was unique in the dictts at all depths and replacing or updating what is not recursively."
                }
            ],
            "answers": [
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 22584,
                                "reputation": 42221,
                                "user_id": 55857,
                                "user_type": "registered",
                                "accept_rate": 86,
                                "display_name": "FMc"
                            },
                            "edited": false,
                            "score": 11,
                            "creation_date": 1278989880,
                            "post_id": 3233356,
                            "comment_id": 3338688,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3233356#comment3338688_3233356",
                            "body": "+1 Good catch on the bug -- doh! I figured someone would would have a better way to handle the <code>isinstance</code> test, but thought I&#39;d take a stab at it."
                        },
                        {
                            "owner": {
                                "account_id": 34048,
                                "reputation": 869830,
                                "user_id": 95810,
                                "user_type": "registered",
                                "accept_rate": 80,
                                "display_name": "Alex Martelli"
                            },
                            "reply_to_user": {
                                "account_id": 136601,
                                "reputation": 3753,
                                "user_id": 340212,
                                "user_type": "registered",
                                "accept_rate": 48,
                                "display_name": "jay_t"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1279064501,
                            "post_id": 3233356,
                            "comment_id": 3349081,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3233356#comment3349081_3233356",
                            "body": "@jay_t. you&#39;re welcome -- yep, I agree that the collections&#39; module abstract base classes (Mapping etc), which were new in Python 2.6, are really nice (you can also make your own ABCs with module abc!-)."
                        },
                        {
                            "owner": {
                                "account_id": 48444,
                                "reputation": 8192,
                                "user_id": 143931,
                                "user_type": "registered",
                                "accept_rate": 57,
                                "display_name": "fuenfundachtzig"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1294395146,
                            "post_id": 3233356,
                            "comment_id": 5086021,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3233356#comment5086021_3233356",
                            "body": "For me this only works when using <code>dict</code> instead of <code>collections.Mapping</code>?! Otherwise <code>isinstance</code> always returns false. (Python 2.5.4)"
                        },
                        {
                            "owner": {
                                "account_id": 310642,
                                "reputation": 18929,
                                "user_id": 623735,
                                "user_type": "registered",
                                "accept_rate": 85,
                                "display_name": "hobs"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1356559737,
                            "post_id": 3233356,
                            "comment_id": 19408629,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3233356#comment19408629_3233356",
                            "body": "adding a depth arg may be useful (though less elegant): <code>def update(d, u, depth=-1):</code> ... <code>if not depth==0 and isinstance(v, collections.Mapping):</code> ... <code>r = update(d.get(k, {}), v, depth=max(depth-1,-1))</code> ..."
                        },
                        {
                            "owner": {
                                "account_id": 310642,
                                "reputation": 18929,
                                "user_id": 623735,
                                "user_type": "registered",
                                "accept_rate": 85,
                                "display_name": "hobs"
                            },
                            "edited": false,
                            "score": 9,
                            "creation_date": 1356570641,
                            "post_id": 3233356,
                            "comment_id": 19411111,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3233356#comment19411111_3233356",
                            "body": "Another minor &quot;feature&quot; causes this to raise <code>TypeError: &#39;int&#39; object does not support item assignment.</code> when you, e.g. <code>update({&#39;k1&#39;: 1}, {&#39;k1&#39;: {&#39;k2&#39;: 2}})</code>.  To change this behavior, and instead expand the depth of dictionaries to make room for deeper dictionaries you can add an <code>elif isinstance(d, Mapping):</code> around the <code>d[k] = u[k]</code> and after the <code>isinstance</code> condition. You&#39;ll also need to add an <code>else: d = {k: u[k]}</code> to deal with the case that the updating dict is deeper than the original dict. Happy to edit the answer, but don&#39;t want to dirty concise code that solves the OP&#39;s problem."
                        },
                        {
                            "owner": {
                                "account_id": 93160,
                                "reputation": 1049,
                                "user_id": 255008,
                                "user_type": "registered",
                                "accept_rate": 93,
                                "display_name": "Matt"
                            },
                            "edited": false,
                            "score": 3,
                            "creation_date": 1360343229,
                            "post_id": 3233356,
                            "comment_id": 20689028,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3233356#comment20689028_3233356",
                            "body": "Why use <code>isinstance(v, collections.Mapping)</code> rather than <code>isinstance(v, dict)</code>?  In the event that OP decides to start using collections?"
                        },
                        {
                            "owner": {
                                "account_id": 310642,
                                "reputation": 18929,
                                "user_id": 623735,
                                "user_type": "registered",
                                "accept_rate": 85,
                                "display_name": "hobs"
                            },
                            "reply_to_user": {
                                "account_id": 93160,
                                "reputation": 1049,
                                "user_id": 255008,
                                "user_type": "registered",
                                "accept_rate": 93,
                                "display_name": "Matt"
                            },
                            "edited": false,
                            "score": 3,
                            "creation_date": 1360363190,
                            "post_id": 3233356,
                            "comment_id": 20697632,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3233356#comment20697632_3233356",
                            "body": "@Matt  Yea, or any other mapping-derived object (lists of pairs of things). Makes the function more general and less likely to quietly ignore mapping-derived objects and leave them un-updated (insidious error that the OP might not ever see/catch). You almost always want to use Mapping to find dict types and basestring to find str types."
                        },
                        {
                            "owner": {
                                "account_id": 1186108,
                                "reputation": 509,
                                "user_id": 1160023,
                                "user_type": "registered",
                                "accept_rate": 62,
                                "display_name": "Monica For CEO"
                            },
                            "edited": false,
                            "score": 5,
                            "creation_date": 1419890757,
                            "post_id": 3233356,
                            "comment_id": 43806664,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3233356#comment43806664_3233356",
                            "body": "Recursion is only needed if the old and new value are both collections: <code>if isinstance(d.get(k, None), collections.Mapping) and isinstance(v, collections.Mapping): d[k] = update(d[k], v)</code> followed by <code>else: d[k] = v</code>"
                        },
                        {
                            "owner": {
                                "account_id": 41952,
                                "reputation": 10960,
                                "user_id": 122075,
                                "user_type": "registered",
                                "accept_rate": 91,
                                "display_name": "Greg K"
                            },
                            "edited": false,
                            "score": 3,
                            "creation_date": 1419956911,
                            "post_id": 3233356,
                            "comment_id": 43829675,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3233356#comment43829675_3233356",
                            "body": "If you&#39;re running this under Python 3+ change <code>u.iteritems()</code> to <code>u.items()</code>, otherwise you will encounter: <code>AttributeError: &#39;dict&#39; object has no attribute &#39;iteritems&#39;</code>"
                        },
                        {
                            "owner": {
                                "account_id": 480090,
                                "reputation": 17100,
                                "user_id": 893113,
                                "user_type": "registered",
                                "accept_rate": 81,
                                "display_name": "paulmelnikow"
                            },
                            "edited": false,
                            "score": 2,
                            "creation_date": 1421887634,
                            "post_id": 3233356,
                            "comment_id": 44537818,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3233356#comment44537818_3233356",
                            "body": "Note that <code>update({&#39;k1&#39;: None}, {&#39;k1&#39;: {&#39;foo&#39;: &#39;bar&#39;})</code> causes a crash, whereas what I&#39;d expect is <code>{&#39;k1&#39;: {&#39;foo&#39;: &#39;bar&#39;}</code>."
                        },
                        {
                            "owner": {
                                "account_id": 4811612,
                                "reputation": 2896,
                                "user_id": 3884938,
                                "user_type": "registered",
                                "display_name": "bscan"
                            },
                            "reply_to_user": {
                                "account_id": 480090,
                                "reputation": 17100,
                                "user_id": 893113,
                                "user_type": "registered",
                                "accept_rate": 81,
                                "display_name": "paulmelnikow"
                            },
                            "edited": false,
                            "score": 2,
                            "creation_date": 1441207456,
                            "post_id": 3233356,
                            "comment_id": 52587234,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3233356#comment52587234_3233356",
                            "body": "@paulmelnikow, the problem of replacing integers with dictionaries should be addressed by my answer below"
                        },
                        {
                            "owner": {
                                "account_id": 1099965,
                                "reputation": 636,
                                "user_id": 1092608,
                                "user_type": "registered",
                                "accept_rate": 67,
                                "display_name": "cecemel"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1466081180,
                            "post_id": 3233356,
                            "comment_id": 63176460,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3233356#comment63176460_3233356",
                            "body": "Thx. I somewhat like immutability of the original dict, so I added the line: final_dict = copy.deepcopy(d)"
                        },
                        {
                            "owner": {
                                "account_id": 1500642,
                                "reputation": 9574,
                                "user_id": 1405425,
                                "user_type": "registered",
                                "display_name": "Charlesthk"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1485372868,
                            "post_id": 3233356,
                            "comment_id": 70904012,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3233356#comment70904012_3233356",
                            "body": "Maybe you could add a third option with six.iteritems(u) so that your code is 2/3 compatible"
                        },
                        {
                            "owner": {
                                "account_id": 3059159,
                                "reputation": 424,
                                "user_id": 2592207,
                                "user_type": "registered",
                                "accept_rate": 100,
                                "display_name": "Ramon"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1511333749,
                            "post_id": 3233356,
                            "comment_id": 81811369,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3233356#comment81811369_3233356",
                            "body": ".get is cleaner, more pythonic and the better choice in general but it is  NOT faster.  It is slow as hell in comparison if the default case happens a reasonable amount."
                        },
                        {
                            "owner": {
                                "account_id": 4446,
                                "reputation": 26135,
                                "user_id": 6691,
                                "user_type": "registered",
                                "accept_rate": 71,
                                "display_name": "EoghanM"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1539775567,
                            "post_id": 3233356,
                            "comment_id": 92622633,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3233356#comment92622633_3233356",
                            "body": "Cross referencing a similar function from the MochiKit JavaScript libary (MochiKit is heavily inspired by Python): <a href=\"https://mochi.github.io/mochikit/doc/html/MochiKit/Base.html#fn-updatetree\" rel=\"nofollow noreferrer\">mochi.github.io/mochikit/doc/html/MochiKit/&hellip;</a> I think <code>updatetree</code> is a great name for this function."
                        },
                        {
                            "owner": {
                                "account_id": 5914193,
                                "reputation": 14079,
                                "user_id": 4653485,
                                "user_type": "registered",
                                "accept_rate": 95,
                                "display_name": "J&#233;r&#244;me"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1582208113,
                            "post_id": 3233356,
                            "comment_id": 106704368,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3233356#comment106704368_3233356",
                            "body": "<a href=\"https://stackoverflow.com/a/60321833/4653485\">My answer</a>, inspired from this one, adds a test to handle the <code>update({&#39;k1&#39;: None}, {&#39;k1&#39;: {&#39;foo&#39;: &#39;bar&#39;})</code> case."
                        },
                        {
                            "owner": {
                                "account_id": 2272817,
                                "reputation": 854,
                                "user_id": 1999801,
                                "user_type": "registered",
                                "display_name": "Sultan"
                            },
                            "reply_to_user": {
                                "account_id": 310642,
                                "reputation": 18929,
                                "user_id": 623735,
                                "user_type": "registered",
                                "accept_rate": 85,
                                "display_name": "hobs"
                            },
                            "edited": false,
                            "score": 2,
                            "creation_date": 1598113198,
                            "post_id": 3233356,
                            "comment_id": 112354626,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3233356#comment112354626_3233356",
                            "body": "@hobs I think it will be most easy if we just replace line: <code>d[k] = update(d.get(k, {}), v)</code> with: <code>d[k] = update({}, v)</code>. That is, pass an <b>empty dictionary</b> that will be populated at next round with new data. This must fix a problems in the comments above."
                        },
                        {
                            "owner": {
                                "account_id": 310642,
                                "reputation": 18929,
                                "user_id": 623735,
                                "user_type": "registered",
                                "accept_rate": 85,
                                "display_name": "hobs"
                            },
                            "reply_to_user": {
                                "account_id": 2272817,
                                "reputation": 854,
                                "user_id": 1999801,
                                "user_type": "registered",
                                "display_name": "Sultan"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1598129228,
                            "post_id": 3233356,
                            "comment_id": 112359163,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3233356#comment112359163_3233356",
                            "body": "@Sultan Wow! That looks like magic. I haven&#39;t tested that update() approach. But if you have tested it thoroughly, feel free to edit the answer directly. Or you can show me your tests and I can make the edit if you don&#39;t want to."
                        },
                        {
                            "owner": {
                                "account_id": 2272817,
                                "reputation": 854,
                                "user_id": 1999801,
                                "user_type": "registered",
                                "display_name": "Sultan"
                            },
                            "reply_to_user": {
                                "account_id": 310642,
                                "reputation": 18929,
                                "user_id": 623735,
                                "user_type": "registered",
                                "accept_rate": 85,
                                "display_name": "hobs"
                            },
                            "edited": false,
                            "score": 2,
                            "creation_date": 1598183119,
                            "post_id": 3233356,
                            "comment_id": 112368705,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3233356#comment112368705_3233356",
                            "body": "@hobs I posted the solution as a new answer, as editing this answer is not allowed. I&#39;ve already tested the code. It works great. Enjoy) <a href=\"https://stackoverflow.com/a/63543967/1999801\">stackoverflow.com/a/63543967/1999801</a>"
                        },
                        {
                            "owner": {
                                "account_id": 218311,
                                "reputation": 19721,
                                "user_id": 474563,
                                "user_type": "registered",
                                "accept_rate": 48,
                                "display_name": "Pithikos"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1610557862,
                            "post_id": 3233356,
                            "comment_id": 116174049,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3233356#comment116174049_3233356",
                            "body": "What about some example?"
                        },
                        {
                            "owner": {
                                "account_id": 5035109,
                                "reputation": 387,
                                "user_id": 4044167,
                                "user_type": "registered",
                                "display_name": "Nico Knoll"
                            },
                            "reply_to_user": {
                                "account_id": 480090,
                                "reputation": 17100,
                                "user_id": 893113,
                                "user_type": "registered",
                                "accept_rate": 81,
                                "display_name": "paulmelnikow"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1611858554,
                            "post_id": 3233356,
                            "comment_id": 116592708,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3233356#comment116592708_3233356",
                            "body": "if you replace that line with <code>d[k] = update(d.get(k) or {}, v)</code> that prevents the crash mentioned by @paulmelnikow . It works becasue <code>get()</code>will by default return <code>None</code>. So if you move the <code>{}</code>out of the get and instead use it with <code>or</code> in the situtation of the crash it will execute as <code>None or {}</code> and that works fine."
                        },
                        {
                            "owner": {
                                "account_id": 9472342,
                                "reputation": 490,
                                "user_id": 8135687,
                                "user_type": "registered",
                                "display_name": "rickstaa"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1623315244,
                            "post_id": 3233356,
                            "comment_id": 120045955,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3233356#comment120045955_3233356",
                            "body": "Thanks a lot for this amazing solution! A modified version of this code with some extra features (i.e. keyword updating, fixed dictionary) can be found in <a href=\"https://gist.github.com/rickstaa/1e0f4ebcc7c35bdee2cae9ccf6fec6ec\" rel=\"nofollow noreferrer\">this gist</a>."
                        },
                        {
                            "owner": {
                                "account_id": 4719941,
                                "reputation": 30749,
                                "user_id": 4518341,
                                "user_type": "registered",
                                "display_name": "wjandrea"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1680306431,
                            "post_id": 3233356,
                            "comment_id": 133881865,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3233356#comment133881865_3233356",
                            "body": "You should use <code>MutableMapping</code>, since there are immutable <code>Mapping</code>s, e.g. <code>types.MappingProxyType</code>, which would fail on the next step."
                        }
                    ],
                    "owner": {
                        "account_id": 34048,
                        "reputation": 869830,
                        "user_id": 95810,
                        "user_type": "registered",
                        "accept_rate": 80,
                        "display_name": "Alex Martelli"
                    },
                    "comment_count": 23,
                    "is_accepted": true,
                    "score": 394,
                    "last_activity_date": 1573852805,
                    "last_edit_date": 1573852805,
                    "creation_date": 1278981113,
                    "answer_id": 3233356,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3233356#3233356",
                    "body": "<p>@FM's answer has the right general idea, i.e. a recursive solution, but somewhat peculiar coding and at least one bug.  I'd recommend, instead:</p>\n\n<p>Python 2:</p>\n\n<pre><code>import collections\n\ndef update(d, u):\n    for k, v in u.iteritems():\n        if isinstance(v, collections.Mapping):\n            d[k] = update(d.get(k, {}), v)\n        else:\n            d[k] = v\n    return d\n</code></pre>\n\n<p>Python 3:</p>\n\n<pre><code>import collections.abc\n\ndef update(d, u):\n    for k, v in u.items():\n        if isinstance(v, collections.abc.Mapping):\n            d[k] = update(d.get(k, {}), v)\n        else:\n            d[k] = v\n    return d\n</code></pre>\n\n<p>The bug shows up when the \"update\" has a <code>k</code>, <code>v</code> item where <code>v</code> is a <code>dict</code> and <code>k</code> is not originally a key in the dictionary being updated -- @FM's code \"skips\" this part of the update (because it performs it on an empty new <code>dict</code> which isn't saved or returned anywhere, just lost when the recursive call returns).</p>\n\n<p>My other changes are minor: there is no reason for the <code>if</code>/<code>else</code> construct when <code>.get</code> does the same job faster and cleaner, and <code>isinstance</code> is best applied to abstract base classes (not concrete ones) for generality.</p>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 136601,
                                "reputation": 3753,
                                "user_id": 340212,
                                "user_type": "registered",
                                "accept_rate": 48,
                                "display_name": "jay_t"
                            },
                            "edited": false,
                            "score": 7,
                            "creation_date": 1279007864,
                            "post_id": 3234274,
                            "comment_id": 3340126,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3234274#comment3340126_3234274",
                            "body": "The nested structure comes from incoming json datasets, so I would like to keep them intact,..."
                        }
                    ],
                    "owner": {
                        "account_id": 79825,
                        "reputation": 28712,
                        "user_id": 226086,
                        "user_type": "registered",
                        "accept_rate": 80,
                        "display_name": "Nas Banov"
                    },
                    "comment_count": 1,
                    "is_accepted": false,
                    "score": -5,
                    "last_activity_date": 1278996644,
                    "creation_date": 1278996644,
                    "answer_id": 3234274,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/3234274#3234274",
                    "body": "<p>That's a bit to the side but do you really need nested dictionaries? Depending on the problem, sometimes flat dictionary may suffice... and look good at it:</p>\n\n<pre><code>&gt;&gt;&gt; dict1 = {('level1','level2','levelA'): 0}\n&gt;&gt;&gt; dict1['level1','level2','levelB'] = 1\n&gt;&gt;&gt; update = {('level1','level2','levelB'): 10}\n&gt;&gt;&gt; dict1.update(update)\n&gt;&gt;&gt; print dict1\n{('level1', 'level2', 'levelB'): 10, ('level1', 'level2', 'levelA'): 0}\n</code></pre>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 93160,
                                "reputation": 1049,
                                "user_id": 255008,
                                "user_type": "registered",
                                "accept_rate": 93,
                                "display_name": "Matt"
                            },
                            "edited": false,
                            "score": 2,
                            "creation_date": 1360346079,
                            "post_id": 14048316,
                            "comment_id": 20690385,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/14048316#comment20690385_14048316",
                            "body": "Thanks for this!  What use-case might the depth parameter apply to?"
                        },
                        {
                            "owner": {
                                "account_id": 310642,
                                "reputation": 18929,
                                "user_id": 623735,
                                "user_type": "registered",
                                "accept_rate": 85,
                                "display_name": "hobs"
                            },
                            "reply_to_user": {
                                "account_id": 93160,
                                "reputation": 1049,
                                "user_id": 255008,
                                "user_type": "registered",
                                "accept_rate": 93,
                                "display_name": "Matt"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1360362648,
                            "post_id": 14048316,
                            "comment_id": 20697429,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/14048316#comment20697429_14048316",
                            "body": "@Matt when you have some objects/dicts at a known depth that you don&#39;t want merged/updated, just overwritten with new objects (like replacing a dict with a string or float or whatever, deep in your dict)"
                        },
                        {
                            "owner": {
                                "account_id": 4811612,
                                "reputation": 2896,
                                "user_id": 3884938,
                                "user_type": "registered",
                                "display_name": "bscan"
                            },
                            "edited": false,
                            "score": 2,
                            "creation_date": 1441207970,
                            "post_id": 14048316,
                            "comment_id": 52587595,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/14048316#comment52587595_14048316",
                            "body": "This only works if the update is at most 1 level deeper than the original. For example, this fails: <code>update({&#39;k1&#39;: 1}, {&#39;k1&#39;: {&#39;k2&#39;: {&#39;k3&#39;: 3}}})</code> I added an answer that addresses this"
                        },
                        {
                            "owner": {
                                "account_id": 310642,
                                "reputation": 18929,
                                "user_id": 623735,
                                "user_type": "registered",
                                "accept_rate": 85,
                                "display_name": "hobs"
                            },
                            "reply_to_user": {
                                "account_id": 4811612,
                                "reputation": 2896,
                                "user_id": 3884938,
                                "user_type": "registered",
                                "display_name": "bscan"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1441304943,
                            "post_id": 14048316,
                            "comment_id": 52636363,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/14048316#comment52636363_14048316",
                            "body": "@bscan good catch! never thought of that use case. I guess I should recurse deeper in the elif branches. Any ideas?"
                        },
                        {
                            "owner": {
                                "account_id": 5914193,
                                "reputation": 14079,
                                "user_id": 4653485,
                                "user_type": "registered",
                                "accept_rate": 95,
                                "display_name": "J&#233;r&#244;me"
                            },
                            "edited": false,
                            "score": 2,
                            "creation_date": 1582207992,
                            "post_id": 14048316,
                            "comment_id": 106704310,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/14048316#comment106704310_14048316",
                            "body": "Why test <code>if isinstance(d, Mapping)</code> on evey iteration? See <a href=\"https://stackoverflow.com/a/60321833/4653485\">my answer</a>. (Also, I&#39;m not sure about your <code>d = {k: u[k]}</code>)"
                        },
                        {
                            "owner": {
                                "account_id": 13196367,
                                "reputation": 190,
                                "user_id": 9531047,
                                "user_type": "registered",
                                "display_name": "Erwan Leroy"
                            },
                            "edited": false,
                            "score": 2,
                            "creation_date": 1637631832,
                            "post_id": 14048316,
                            "comment_id": 123872961,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/14048316#comment123872961_14048316",
                            "body": "I was using hobs&#39; answer but ran into the case where the update dict was a lot deeper than the original, Jerome&#39;s answer did the trick for me!"
                        }
                    ],
                    "owner": {
                        "account_id": 310642,
                        "reputation": 18929,
                        "user_id": 623735,
                        "user_type": "registered",
                        "accept_rate": 85,
                        "display_name": "hobs"
                    },
                    "comment_count": 6,
                    "is_accepted": false,
                    "score": 6,
                    "last_activity_date": 1369428730,
                    "last_edit_date": 1495535495,
                    "creation_date": 1356571452,
                    "answer_id": 14048316,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/14048316#14048316",
                    "body": "<p>Minor improvements to <a href=\"https://stackoverflow.com/a/3233356/623735\">@Alex's answer</a> that enables updating of dictionaries of differing depths as well as limiting the depth that the update dives into the original nested dictionary (but the updating dictionary depth is not limited). Only a few cases have been tested:</p>\n\n<pre><code>def update(d, u, depth=-1):\n    \"\"\"\n    Recursively merge or update dict-like objects. \n    &gt;&gt;&gt; update({'k1': {'k2': 2}}, {'k1': {'k2': {'k3': 3}}, 'k4': 4})\n    {'k1': {'k2': {'k3': 3}}, 'k4': 4}\n    \"\"\"\n\n    for k, v in u.iteritems():\n        if isinstance(v, Mapping) and not depth == 0:\n            r = update(d.get(k, {}), v, depth=max(depth - 1, -1))\n            d[k] = r\n        elif isinstance(d, Mapping):\n            d[k] = u[k]\n        else:\n            d = {k: u[k]}\n    return d\n</code></pre>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 515061,
                                "reputation": 369119,
                                "user_id": 1240268,
                                "user_type": "registered",
                                "accept_rate": 90,
                                "display_name": "Andy Hayden"
                            },
                            "edited": false,
                            "score": 4,
                            "creation_date": 1413354680,
                            "post_id": 18394648,
                            "comment_id": 41407580,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/18394648#comment41407580_18394648",
                            "body": "I think this should probably be (to be a bit safer): <code>orig_dict.get(key, []) + val</code>."
                        },
                        {
                            "owner": {
                                "account_id": 1191620,
                                "reputation": 2588,
                                "user_id": 1164249,
                                "user_type": "registered",
                                "accept_rate": 57,
                                "display_name": "gabrielhpugliese"
                            },
                            "edited": false,
                            "score": 3,
                            "creation_date": 1425065587,
                            "post_id": 18394648,
                            "comment_id": 45824151,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/18394648#comment45824151_18394648",
                            "body": "Since dicts are mutable, you are changing the instance you are passing as argument. Then, you don&#39;t need to return orig_dict."
                        },
                        {
                            "owner": {
                                "account_id": 893910,
                                "reputation": 3946,
                                "user_id": 931625,
                                "user_type": "registered",
                                "accept_rate": 67,
                                "display_name": "Kel Solaar"
                            },
                            "edited": false,
                            "score": 4,
                            "creation_date": 1434142593,
                            "post_id": 18394648,
                            "comment_id": 49672160,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/18394648#comment49672160_18394648",
                            "body": "I think most people would expect the definition to return the updated dict even though it is updated in place."
                        },
                        {
                            "owner": {
                                "account_id": 4181140,
                                "reputation": 576,
                                "user_id": 3426137,
                                "user_type": "registered",
                                "display_name": "intijk"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1478023247,
                            "post_id": 18394648,
                            "comment_id": 67985020,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/18394648#comment67985020_18394648",
                            "body": "The default logic in the onosendi&#39;s code is to append updated list to the original list. If you need to update overwrite the original list, you need to set orig_dict[key]=val"
                        },
                        {
                            "owner": {
                                "account_id": 4446,
                                "reputation": 26135,
                                "user_id": 6691,
                                "user_type": "registered",
                                "accept_rate": 71,
                                "display_name": "EoghanM"
                            },
                            "reply_to_user": {
                                "account_id": 1191620,
                                "reputation": 2588,
                                "user_id": 1164249,
                                "user_type": "registered",
                                "accept_rate": 57,
                                "display_name": "gabrielhpugliese"
                            },
                            "edited": false,
                            "score": 2,
                            "creation_date": 1539775445,
                            "post_id": 18394648,
                            "comment_id": 92622577,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/18394648#comment92622577_18394648",
                            "body": "@gabrielhpugliese returning the original is needed if called with a dictionary literal, e.g.  <code>merged_tree = update({&#39;default&#39;: {&#39;initialvalue&#39;: 1}}, other_tree)</code>"
                        }
                    ],
                    "owner": {
                        "user_type": "does_not_exist",
                        "display_name": "user2709610"
                    },
                    "comment_count": 5,
                    "is_accepted": false,
                    "score": 37,
                    "last_activity_date": 1488967229,
                    "last_edit_date": 1488967229,
                    "creation_date": 1377231665,
                    "answer_id": 18394648,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/18394648#18394648",
                    "body": "<p>Took me a little bit on this one, but thanks to @Alex's post, he filled in the gap I was missing. However, I came across an issue if a value within the recursive <code>dict</code> happens to be a <code>list</code>, so I thought I'd share, and extend his answer.</p>\n\n<pre><code>import collections\n\ndef update(orig_dict, new_dict):\n    for key, val in new_dict.iteritems():\n        if isinstance(val, collections.Mapping):\n            tmp = update(orig_dict.get(key, { }), val)\n            orig_dict[key] = tmp\n        elif isinstance(val, list):\n            orig_dict[key] = (orig_dict.get(key, []) + val)\n        else:\n            orig_dict[key] = new_dict[key]\n    return orig_dict\n</code></pre>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 970323,
                                "reputation": 715,
                                "user_id": 992999,
                                "user_type": "registered",
                                "accept_rate": 56,
                                "display_name": "drstevok"
                            },
                            "edited": false,
                            "score": 6,
                            "creation_date": 1641054908,
                            "post_id": 30655448,
                            "comment_id": 124713046,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/30655448#comment124713046_30655448",
                            "body": "Lovely. But had to update <code>overrides.iteritems()</code> to <code>overrides.items()</code> and <code>collections.Mapping</code> to <code>collections.abc.Mapping</code> on Python 3.9+"
                        }
                    ],
                    "owner": {
                        "account_id": 68427,
                        "reputation": 25631,
                        "user_id": 199649,
                        "user_type": "registered",
                        "accept_rate": 88,
                        "display_name": "charlax"
                    },
                    "comment_count": 1,
                    "is_accepted": false,
                    "score": 35,
                    "last_activity_date": 1553737671,
                    "last_edit_date": 1553737671,
                    "creation_date": 1433457741,
                    "answer_id": 30655448,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/30655448#30655448",
                    "body": "<p>Same solution as the accepted one, but clearer variable naming, docstring, and fixed a bug where <code>{}</code> as a value would not override.</p>\n\n<pre><code>import collections\n\n\ndef deep_update(source, overrides):\n    \"\"\"\n    Update a nested dictionary or similar mapping.\n    Modify ``source`` in place.\n    \"\"\"\n    for key, value in overrides.iteritems():\n        if isinstance(value, collections.Mapping) and value:\n            returned = deep_update(source.get(key, {}), value)\n            source[key] = returned\n        else:\n            source[key] = overrides[key]\n    return source\n</code></pre>\n\n<p>Here are a few test cases:</p>\n\n<pre><code>def test_deep_update():\n    source = {'hello1': 1}\n    overrides = {'hello2': 2}\n    deep_update(source, overrides)\n    assert source == {'hello1': 1, 'hello2': 2}\n\n    source = {'hello': 'to_override'}\n    overrides = {'hello': 'over'}\n    deep_update(source, overrides)\n    assert source == {'hello': 'over'}\n\n    source = {'hello': {'value': 'to_override', 'no_change': 1}}\n    overrides = {'hello': {'value': 'over'}}\n    deep_update(source, overrides)\n    assert source == {'hello': {'value': 'over', 'no_change': 1}}\n\n    source = {'hello': {'value': 'to_override', 'no_change': 1}}\n    overrides = {'hello': {'value': {}}}\n    deep_update(source, overrides)\n    assert source == {'hello': {'value': {}, 'no_change': 1}}\n\n    source = {'hello': {'value': {}, 'no_change': 1}}\n    overrides = {'hello': {'value': 2}}\n    deep_update(source, overrides)\n    assert source == {'hello': {'value': 2, 'no_change': 1}}\n</code></pre>\n\n<p>This functions is available in the <a href=\"https://charlatan.readthedocs.org\" rel=\"noreferrer\">charlatan</a> package, in <code>charlatan.utils</code>.</p>\n"
                },
                {
                    "owner": {
                        "account_id": 4755426,
                        "reputation": 45,
                        "user_id": 3844316,
                        "user_type": "registered",
                        "display_name": "noragen"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 3,
                    "last_activity_date": 1588084908,
                    "last_edit_date": 1588084908,
                    "creation_date": 1438878295,
                    "answer_id": 31861045,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/31861045#31861045",
                    "body": "<p>It could be that you stumble over a non-standard-dictionary, like me today, which has no iteritems-Attribute. \nIn this case it's easy to interpret this type of dictionary as a standard-dictionary. E.g.:\n<strong>Python 2.7:</strong></p>\n\n<pre class=\"lang-py prettyprint-override\"><code>    import collections\n    def update(orig_dict, new_dict):\n        for key, val in dict(new_dict).iteritems():\n            if isinstance(val, collections.Mapping):\n                tmp = update(orig_dict.get(key, { }), val)\n                orig_dict[key] = tmp\n            elif isinstance(val, list):\n                orig_dict[key] = (orig_dict[key] + val)\n            else:\n                orig_dict[key] = new_dict[key]\n        return orig_dict\n\n    import multiprocessing\n    d=multiprocessing.Manager().dict({'sample':'data'})\n    u={'other': 1234}\n\n    x=update(d, u)\n    x.items()\n</code></pre>\n\n<p><strong>Python 3.8:</strong></p>\n\n<pre><code>    def update(orig_dict, new_dict):\n        orig_dict=dict(orig_dict)\n        for key, val in dict(new_dict).items():\n            if isinstance(val, collections.abc.Mapping):\n                tmp = update(orig_dict.get(key, { }), val)\n                orig_dict[key] = tmp\n            elif isinstance(val, list):\n                orig_dict[key] = (orig_dict[key] + val)\n            else:\n                orig_dict[key] = new_dict[key]\n        return orig_dict\n\n    import collections\n    import multiprocessing\n    d=multiprocessing.Manager().dict({'sample':'data'})\n    u={'other': 1234, \"deeper\": {'very': 'deep'}}\n\n    x=update(d, u)\n    x.items()\n</code></pre>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 310642,
                                "reputation": 18929,
                                "user_id": 623735,
                                "user_type": "registered",
                                "accept_rate": 85,
                                "display_name": "hobs"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1441566880,
                            "post_id": 32357112,
                            "comment_id": 52719850,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/32357112#comment52719850_32357112",
                            "body": "I see. You made my <code>elif</code> check of the original object type an &quot;enclosing&quot; conditional containing the checks of both the value and the key of that dict/mapping. Clever."
                        },
                        {
                            "owner": {
                                "account_id": 4119865,
                                "reputation": 261,
                                "user_id": 3380530,
                                "user_type": "registered",
                                "display_name": "Wlerin"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1488066696,
                            "post_id": 32357112,
                            "comment_id": 72068155,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/32357112#comment72068155_32357112",
                            "body": "This won&#39;t work if the inner dict has more than one key."
                        },
                        {
                            "owner": {
                                "account_id": 4811612,
                                "reputation": 2896,
                                "user_id": 3884938,
                                "user_type": "registered",
                                "display_name": "bscan"
                            },
                            "reply_to_user": {
                                "account_id": 4119865,
                                "reputation": 261,
                                "user_id": 3380530,
                                "user_type": "registered",
                                "display_name": "Wlerin"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1488211153,
                            "post_id": 32357112,
                            "comment_id": 72119858,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/32357112#comment72119858_32357112",
                            "body": "@Wlerin , it still works; d will have become a Mapping by that point. Here&#39;s a test case with multiple keys: <code>update({&#39;A1&#39;: 1, &#39;A2&#39;:2}, {&#39;A1&#39;: {&#39;B1&#39;: {&#39;C1&#39;: 3, &#39;C2&#39;:4}, &#39;B2&#39;:2}, &#39;A3&#39;:5})</code>. Do you have an example that doesn&#39;t do what you want?"
                        },
                        {
                            "owner": {
                                "account_id": 5914193,
                                "reputation": 14079,
                                "user_id": 4653485,
                                "user_type": "registered",
                                "accept_rate": 95,
                                "display_name": "J&#233;r&#244;me"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1582207884,
                            "post_id": 32357112,
                            "comment_id": 106704239,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/32357112#comment106704239_32357112",
                            "body": "Why test <code>if isinstance(d, collections.Mapping)</code> on evey iteration? See <a href=\"https://stackoverflow.com/a/60321833/4653485\">my answer</a>."
                        }
                    ],
                    "owner": {
                        "account_id": 4811612,
                        "reputation": 2896,
                        "user_id": 3884938,
                        "user_type": "registered",
                        "display_name": "bscan"
                    },
                    "comment_count": 4,
                    "is_accepted": false,
                    "score": 22,
                    "last_activity_date": 1441207374,
                    "creation_date": 1441207374,
                    "answer_id": 32357112,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/32357112#32357112",
                    "body": "<p>@Alex's answer is good, but doesn't work when replacing an element such as an integer with a dictionary, such as <code>update({'foo':0},{'foo':{'bar':1}})</code>. This update addresses it:</p>\n\n<pre><code>import collections\ndef update(d, u):\n    for k, v in u.iteritems():\n        if isinstance(d, collections.Mapping):\n            if isinstance(v, collections.Mapping):\n                r = update(d.get(k, {}), v)\n                d[k] = r\n            else:\n                d[k] = u[k]\n        else:\n            d = {k: u[k]}\n    return d\n\nupdate({'k1': 1}, {'k1': {'k2': {'k3': 3}}})\n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 1364661,
                        "reputation": 4159,
                        "user_id": 1301359,
                        "user_type": "registered",
                        "accept_rate": 60,
                        "display_name": "panda-34"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 3,
                    "last_activity_date": 1456724520,
                    "last_edit_date": 1456724520,
                    "creation_date": 1456723282,
                    "answer_id": 35692470,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/35692470#35692470",
                    "body": "<p>In neither of these answers the authors seem to understand the concept of updating an object stored in a dictionary nor even of iterating over dictionary items (as opposed to keys). So I had to write one which doesn't make pointless tautological dictionary stores and retrievals.\nThe dicts are assumed to store other dicts or simple types.</p>\n\n<pre><code>def update_nested_dict(d, other):\n    for k, v in other.items():\n        if isinstance(v, collections.Mapping):\n            d_v = d.get(k)\n            if isinstance(d_v, collections.Mapping):\n                update_nested_dict(d_v, v)\n            else:\n                d[k] = v.copy()\n        else:\n            d[k] = v\n</code></pre>\n\n<p>Or even simpler one working with any type:</p>\n\n<pre><code>def update_nested_dict(d, other):\n    for k, v in other.items():\n        d_v = d.get(k)\n        if isinstance(v, collections.Mapping) and isinstance(d_v, collections.Mapping):\n            update_nested_dict(d_v, v)\n        else:\n            d[k] = deepcopy(v) # or d[k] = v if you know what you're doing\n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 4247798,
                        "reputation": 1833,
                        "user_id": 3475912,
                        "user_type": "registered",
                        "accept_rate": 100,
                        "display_name": "Daniel"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 3,
                    "last_activity_date": 1467261266,
                    "last_edit_date": 1467261266,
                    "creation_date": 1467170877,
                    "answer_id": 38089879,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/38089879#38089879",
                    "body": "<p>Update to @Alex Martelli's answer to fix a bug in his code to make the solution more robust:</p>\n\n<pre><code>def update_dict(d, u):\n    for k, v in u.items():\n        if isinstance(v, collections.Mapping):\n            default = v.copy()\n            default.clear()\n            r = update_dict(d.get(k, default), v)\n            d[k] = r\n        else:\n            d[k] = v\n    return d\n</code></pre>\n\n<p>The key is that we often want to create the <strong>same type</strong> at recursion, so here we use <code>v.copy().clear()</code> but not <code>{}</code>. And this is especially useful if the <code>dict</code> here is of type <code>collections.defaultdict</code> which can have different kinds of <code>default_factory</code>s.</p>\n\n<p>Also notice that the <code>u.iteritems()</code> has been changed to <code>u.items()</code> in <code>Python3</code>.</p>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 15165476,
                                "reputation": 306,
                                "user_id": 10943095,
                                "user_type": "registered",
                                "display_name": "Laurent T"
                            },
                            "edited": false,
                            "score": 2,
                            "creation_date": 1639469018,
                            "post_id": 42997969,
                            "comment_id": 124349824,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/42997969#comment124349824_42997969",
                            "body": "That is the only soltuion that actually worked for me. Thanks"
                        }
                    ],
                    "owner": {
                        "account_id": 3484078,
                        "reputation": 2553,
                        "user_id": 2915423,
                        "user_type": "registered",
                        "display_name": "helvete"
                    },
                    "comment_count": 1,
                    "is_accepted": false,
                    "score": 4,
                    "last_activity_date": 1490353761,
                    "creation_date": 1490353761,
                    "answer_id": 42997969,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/42997969#42997969",
                    "body": "<p>I used the solution @Alex Martelli suggests, but it fails</p>\n\n<p><code>TypeError 'bool' object does not support item assignment</code></p>\n\n<p>when the two dictionaries differ in data type at some level. </p>\n\n<p>In case at the same level the element of dictionary <code>d</code> is just a scalar (ie. <code>Bool</code>) while the element of dictionary <code>u</code> is still dictionary the reassignment fails as no dictionary assignment is possible into scalar (like <code>True[k]</code>).</p>\n\n<p>One added condition fixes that:</p>\n\n<pre><code>from collections import Mapping\n\ndef update_deep(d, u):\n    for k, v in u.items():\n        # this condition handles the problem\n        if not isinstance(d, Mapping):\n            d = u\n        elif isinstance(v, Mapping):\n            r = update_deep(d.get(k, {}), v)\n            d[k] = r\n        else:\n            d[k] = u[k]\n\n    return d\n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 1498758,
                        "reputation": 3350,
                        "user_id": 1404076,
                        "user_type": "registered",
                        "accept_rate": 94,
                        "display_name": "kabirbaidhya"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 17,
                    "last_activity_date": 1695103818,
                    "last_edit_date": 1695103818,
                    "creation_date": 1491387703,
                    "answer_id": 43228384,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/43228384#43228384",
                    "body": "<p>Here's an immutable version of recursive dictionary merge in case someone needs it.</p>\n<p>Based upon @Alex Martelli's <a href=\"https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth#answer-3233356\">answer</a>.</p>\n<p><strong>Python 3.x:</strong></p>\n<pre><code>from collections.abc import Mapping\nfrom copy import deepcopy\n\n\ndef merge(dict1, dict2):\n    ''' Return a new dictionary by merging two dictionaries recursively. '''\n\n    result = deepcopy(dict1)\n\n    for key, value in dict2.items():\n        if isinstance(value, Mapping):\n            result[key] = merge(result.get(key, {}), value)\n        else:\n            result[key] = deepcopy(dict2[key])\n\n    return result\n</code></pre>\n<p><strong>Python 2.x:</strong></p>\n<pre><code>import collections\nfrom copy import deepcopy\n\n\ndef merge(dict1, dict2):\n    ''' Return a new dictionary by merging two dictionaries recursively. '''\n\n    result = deepcopy(dict1)\n\n    for key, value in dict2.iteritems():\n        if isinstance(value, collections.Mapping):\n            result[key] = merge(result.get(key, {}), value)\n        else:\n            result[key] = deepcopy(dict2[key])\n\n    return result\n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 2047683,
                        "reputation": 773,
                        "user_id": 1827414,
                        "user_type": "registered",
                        "display_name": "djpinne"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 9,
                    "last_activity_date": 1608241342,
                    "last_edit_date": 1608241342,
                    "creation_date": 1535638529,
                    "answer_id": 52099238,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/52099238#52099238",
                    "body": "<p>This question is old, but I landed here when searching for a &quot;deep merge&quot; solution. The answers above inspired what follows. I ended up writing my own because there were bugs in all the versions I tested. The critical point missed was, at some arbitrary depth of the two input dicts, for some key, k, the decision tree when d[k] or u[k] is <em>not</em> a dict was faulty.</p>\n<p>Also, this solution does not require recursion, which is more symmetric with how <code>dict.update()</code> works, and returns <code>None</code>.</p>\n<pre class=\"lang-py prettyprint-override\"><code>import collections\ndef deep_merge(d, u):\n   &quot;&quot;&quot;Do a deep merge of one dict into another.\n\n   This will update d with values in u, but will not delete keys in d\n   not found in u at some arbitrary depth of d. That is, u is deeply\n   merged into d.\n\n   Args -\n     d, u: dicts\n\n   Note: this is destructive to d, but not u.\n\n   Returns: None\n   &quot;&quot;&quot;\n   stack = [(d,u)]\n   while stack:\n      d,u = stack.pop(0)\n      for k,v in u.items():\n         if not isinstance(v, collections.Mapping):\n            # u[k] is not a dict, nothing to merge, so just set it,\n            # regardless if d[k] *was* a dict\n            d[k] = v\n\n        else:\n            # note: u[k] is a dict\n            if k not in d:\n                # add new key into d\n                d[k] = v\n            elif not isinstance(d[k], collections.Mapping):\n                # d[k] is not a dict, so just set it to u[k],\n                # overriding whatever it was\n                d[k] = v\n            else:\n                # both d[k] and u[k] are dicts, push them on the stack\n                # to merge\n                stack.append((d[k], v))\n</code></pre>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 331779,
                                "reputation": 1694,
                                "user_id": 1300775,
                                "user_type": "registered",
                                "display_name": "Damien"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1675697695,
                            "post_id": 53098940,
                            "comment_id": 132979637,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/53098940#comment132979637_53098940",
                            "body": "This one works best for me: concise and effective"
                        }
                    ],
                    "owner": {
                        "account_id": 7281438,
                        "reputation": 969,
                        "user_id": 5551065,
                        "user_type": "registered",
                        "accept_rate": 75,
                        "display_name": "honmaple"
                    },
                    "comment_count": 1,
                    "is_accepted": false,
                    "score": 3,
                    "last_activity_date": 1541066399,
                    "creation_date": 1541066399,
                    "answer_id": 53098940,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/53098940#53098940",
                    "body": "<pre><code>def update(value, nvalue):\n    if not isinstance(value, dict) or not isinstance(nvalue, dict):\n        return nvalue\n    for k, v in nvalue.items():\n        value.setdefault(k, dict())\n        if isinstance(v, dict):\n            v = update(value[k], v)\n        value[k] = v\n    return value\n</code></pre>\n\n<p>use <code>dict</code> or <code>collections.Mapping</code></p>\n"
                },
                {
                    "owner": {
                        "account_id": 3276541,
                        "reputation": 31,
                        "user_id": 2758377,
                        "user_type": "registered",
                        "display_name": "ipsuri"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 2,
                    "last_activity_date": 1567176927,
                    "last_edit_date": 1567176927,
                    "creation_date": 1553187740,
                    "answer_id": 55285651,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/55285651#55285651",
                    "body": "<p>I know this question is pretty old, but still posting what I do when I have to update a nested dictionary. We can use the fact that dicts are passed by reference in python\nAssuming that the path of the key is known and is dot separated. Forex if we have a dict named data:</p>\n\n<pre><code>{\n\"log_config_worker\": {\n    \"version\": 1, \n    \"root\": {\n        \"handlers\": [\n            \"queue\"\n        ], \n        \"level\": \"DEBUG\"\n    }, \n    \"disable_existing_loggers\": true, \n    \"handlers\": {\n        \"queue\": {\n            \"queue\": null, \n            \"class\": \"myclass1.QueueHandler\"\n        }\n    }\n}, \n\"number_of_archived_logs\": 15, \n\"log_max_size\": \"300M\", \n\"cron_job_dir\": \"/etc/cron.hourly/\", \n\"logs_dir\": \"/var/log/patternex/\", \n\"log_rotate_dir\": \"/etc/logrotate.d/\"\n}\n</code></pre>\n\n<p>And we want to update the queue class, the path of the key would be - <code>log_config_worker.handlers.queue.class</code></p>\n\n<p>We can use the following function to update the value:</p>\n\n<pre><code>def get_updated_dict(obj, path, value):\n    key_list = path.split(\".\")\n\n    for k in key_list[:-1]:\n        obj = obj[k]\n\n    obj[key_list[-1]] = value\n\nget_updated_dict(data, \"log_config_worker.handlers.queue.class\", \"myclass2.QueueHandler\")\n</code></pre>\n\n<p>This would update the dictionary correctly.</p>\n"
                },
                {
                    "owner": {
                        "account_id": 15378985,
                        "reputation": 865,
                        "user_id": 11094914,
                        "user_type": "registered",
                        "display_name": "ZettaCircl"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 0,
                    "last_activity_date": 1570867843,
                    "last_edit_date": 1570867843,
                    "creation_date": 1560770679,
                    "answer_id": 56630315,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/56630315#56630315",
                    "body": "<p>If you want to replace a \"full nested dictionary with arrays\" you can use this snippet : </p>\n\n<p>It will replace any \"old_value\" by \"new_value\". It's roughly doing a depth-first rebuilding of the dictionary. It can even work with List or Str/int given as input parameter of first level.</p>\n\n<pre><code>def update_values_dict(original_dict, future_dict, old_value, new_value):\n    # Recursively updates values of a nested dict by performing recursive calls\n\n    if isinstance(original_dict, Dict):\n        # It's a dict\n        tmp_dict = {}\n        for key, value in original_dict.items():\n            tmp_dict[key] = update_values_dict(value, future_dict, old_value, new_value)\n        return tmp_dict\n    elif isinstance(original_dict, List):\n        # It's a List\n        tmp_list = []\n        for i in original_dict:\n            tmp_list.append(update_values_dict(i, future_dict, old_value, new_value))\n        return tmp_list\n    else:\n        # It's not a dict, maybe a int, a string, etc.\n        return original_dict if original_dict != old_value else new_value\n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 8434820,
                        "reputation": 1267,
                        "user_id": 6329284,
                        "user_type": "registered",
                        "accept_rate": 44,
                        "display_name": "zwep"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 0,
                    "last_activity_date": 1568707639,
                    "creation_date": 1568707639,
                    "answer_id": 57969936,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/57969936#57969936",
                    "body": "<p>Yes! And another solution. My solution differs in the keys that are being checked.\nIn all other solutions we only look at the keys in <code>dict_b</code>. But here we look in the union of both dictionaries.</p>\n\n<p>Do with it as you please</p>\n\n<pre><code>def update_nested(dict_a, dict_b):\n    set_keys = set(dict_a.keys()).union(set(dict_b.keys()))\n    for k in set_keys:\n        v = dict_a.get(k)\n        if isinstance(v, dict):\n            new_dict = dict_b.get(k, None)\n            if new_dict:\n                update_nested(v, new_dict)\n        else:\n            new_value = dict_b.get(k, None)\n            if new_value:\n                dict_a[k] = new_value\n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 2397743,
                        "reputation": 1911,
                        "user_id": 2096218,
                        "user_type": "registered",
                        "display_name": "Fabio Caccamo"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 9,
                    "last_activity_date": 1603992052,
                    "last_edit_date": 1603992052,
                    "creation_date": 1569513874,
                    "answer_id": 58120743,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/58120743#58120743",
                    "body": "<p>Just use <code>python-benedict</code> <em>(I did it)</em>, it has a <code>merge</code> (deepupdate) utility method and many others. It works with python 2 / python 3 and it is well tested.</p>\n<pre class=\"lang-py prettyprint-override\"><code>from benedict import benedict\n\ndictionary1=benedict({'level1':{'level2':{'levelA':0,'levelB':1}}})\nupdate={'level1':{'level2':{'levelB':10}}}\ndictionary1.merge(update)\nprint(dictionary1)\n# &gt;&gt; {'level1':{'level2':{'levelA':0,'levelB':10}}}\n</code></pre>\n<p>Installation: <code>pip install python-benedict</code></p>\n<p>Documentation: <a href=\"https://github.com/fabiocaccamo/python-benedict\" rel=\"noreferrer\">https://github.com/fabiocaccamo/python-benedict</a></p>\n<p>Note: I am the author of this project</p>\n"
                },
                {
                    "owner": {
                        "account_id": 8003299,
                        "reputation": 6036,
                        "user_id": 6037369,
                        "user_type": "registered",
                        "display_name": "Yifu Yan"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 0,
                    "last_activity_date": 1571955248,
                    "last_edit_date": 1571955248,
                    "creation_date": 1571952979,
                    "answer_id": 58549435,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/58549435#58549435",
                    "body": "<p>Another way of using recursion:</p>\n\n<pre><code>def updateDict(dict1,dict2):\n    keys1 = list(dict1.keys())\n    keys2= list(dict2.keys())\n    keys2 = [x for x in keys2 if x in keys1]\n    for x in keys2:\n        if (x in keys1) &amp; (type(dict1[x]) is dict) &amp; (type(dict2[x]) is dict):\n            updateDict(dict1[x],dict2[x])\n        else:\n            dict1.update({x:dict2[x]})\n    return(dict1)\n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 9910403,
                        "reputation": 19,
                        "user_id": 7337353,
                        "user_type": "registered",
                        "display_name": "user7337353"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": -1,
                    "last_activity_date": 1574486756,
                    "creation_date": 1574486756,
                    "answer_id": 59004796,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/59004796#59004796",
                    "body": "<p>a new Q\nhow to By a keys chain</p>\n\n<pre><code>dictionary1={'level1':{'level2':{'levelA':0,'levelB':1}},'anotherLevel1':{'anotherLevel2':{'anotherLevelA':0,'anotherLevelB':1}}}\nupdate={'anotherLevel1':{'anotherLevel2':1014}}\ndictionary1.update(update)\nprint dictionary1\n{'level1':{'level2':{'levelA':0,'levelB':1}},'anotherLevel1':{'anotherLevel2':1014}}\n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 10212883,
                        "reputation": 1,
                        "user_id": 7539459,
                        "user_type": "registered",
                        "display_name": "Craig N."
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": -1,
                    "last_activity_date": 1578470663,
                    "creation_date": 1578470663,
                    "answer_id": 59641675,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/59641675#59641675",
                    "body": "<p>you could try this, it works with lists and is pure:</p>\n\n<pre><code>def update_keys(newd, dic, mapping):\n  def upsingle(d,k,v):\n    if k in mapping:\n      d[mapping[k]] = v\n    else:\n      d[k] = v\n  for ekey, evalue in dic.items():\n    upsingle(newd, ekey, evalue)\n    if type(evalue) is dict:\n      update_keys(newd, evalue, mapping)\n    if type(evalue) is list:\n      upsingle(newd, ekey, [update_keys({}, i, mapping) for i in evalue])\n  return newd\n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 2982654,
                        "reputation": 31,
                        "user_id": 12189131,
                        "user_type": "registered",
                        "display_name": "Nico"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 3,
                    "last_activity_date": 1578675229,
                    "creation_date": 1578675229,
                    "answer_id": 59685868,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/59685868#59685868",
                    "body": "<p>I recommend to replace <code>{}</code> by <code>type(v)()</code> in order to propagate object type of any dict subclass stored in <code>u</code> but absent from <code>d</code>.  For example, this would preserve types such as collections.OrderedDict:</p>\n\n<p>Python 2:</p>\n\n<pre><code>import collections\n\ndef update(d, u):\n    for k, v in u.iteritems():\n        if isinstance(v, collections.Mapping):\n            d[k] = update(d.get(k, type(v)()), v)\n        else:\n            d[k] = v\n    return d\n</code></pre>\n\n<p>Python 3:</p>\n\n<pre><code>import collections.abc\n\ndef update(d, u):\n    for k, v in u.items():\n        if isinstance(v, collections.abc.Mapping):\n            d[k] = update(d.get(k, type(v)()), v)\n        else:\n            d[k] = v\n    return d\n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 5914193,
                        "reputation": 14079,
                        "user_id": 4653485,
                        "user_type": "registered",
                        "accept_rate": 95,
                        "display_name": "J&#233;r&#244;me"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 5,
                    "last_activity_date": 1582207768,
                    "creation_date": 1582207768,
                    "answer_id": 60321833,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/60321833#60321833",
                    "body": "<p>The code below should solve the <code>update({'k1': 1}, {'k1': {'k2': 2}})</code> issue in @Alex Martelli's answer the right way.</p>\n\n<pre class=\"lang-py prettyprint-override\"><code>def deepupdate(original, update):\n    \"\"\"Recursively update a dict.\n\n    Subdict's won't be overwritten but also updated.\n    \"\"\"\n    if not isinstance(original, abc.Mapping):\n        return update\n    for key, value in update.items():\n        if isinstance(value, abc.Mapping):\n            original[key] = deepupdate(original.get(key, {}), value)\n        else:\n            original[key] = value\n    return original\n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 2272817,
                        "reputation": 854,
                        "user_id": 1999801,
                        "user_type": "registered",
                        "display_name": "Sultan"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 3,
                    "last_activity_date": 1598182093,
                    "last_edit_date": 1598182093,
                    "creation_date": 1598163132,
                    "answer_id": 63543967,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/63543967#63543967",
                    "body": "<p>Thanks to <a href=\"https://stackoverflow.com/users/623735/hobs\">hobs</a> for his comment on <a href=\"https://stackoverflow.com/users/95810/alex-martelli\">Alex's</a> <a href=\"https://stackoverflow.com/a/3233356/1999801\">answer</a>. Indeed <code>update({'k1': 1}, {'k1': {'k2': 2}})</code> will cause <code>TypeError: 'int' object does not support item assignment.</code></p>\n<p>We should check the types of the input values at the beginning of the function. So, I suggest the following function, which should solve this (and other) problem.</p>\n<p>Python 3:</p>\n<pre class=\"lang-py prettyprint-override\"><code>from collections.abc import Mapping\n\n\ndef deep_update(d1, d2):\n    if all((isinstance(d, Mapping) for d in (d1, d2))):\n        for k, v in d2.items():\n            d1[k] = deep_update(d1.get(k), v)\n        return d1\n    return d2\n</code></pre>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 8545263,
                                "reputation": 1009,
                                "user_id": 6404012,
                                "user_type": "registered",
                                "accept_rate": 50,
                                "display_name": "Eitel Dagnin"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1646391239,
                            "post_id": 65137380,
                            "comment_id": 126116785,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/65137380#comment126116785_65137380",
                            "body": "So far, your solution has been the only one that&#39;s worked for me :) There&#39;s 2 issues I have to solve now though. 1 - If there is a key with the same name in a different nested dict, it only updates the first occurrence of the key and 2 - Updating list values"
                        },
                        {
                            "owner": {
                                "account_id": 8545263,
                                "reputation": 1009,
                                "user_id": 6404012,
                                "user_type": "registered",
                                "accept_rate": 50,
                                "display_name": "Eitel Dagnin"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1646391327,
                            "post_id": 65137380,
                            "comment_id": 126116823,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/65137380#comment126116823_65137380",
                            "body": "Example of list mentioned above:  <code>{&quot;thirdClass&quot;: [{&quot;my_string&quot;: &quot;my_list&quot;,&quot;my_int&quot;: 3,&quot;my_bool&quot;: True}]}</code>"
                        },
                        {
                            "owner": {
                                "account_id": 8545263,
                                "reputation": 1009,
                                "user_id": 6404012,
                                "user_type": "registered",
                                "accept_rate": 50,
                                "display_name": "Eitel Dagnin"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1646638243,
                            "post_id": 65137380,
                            "comment_id": 126164092,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/65137380#comment126164092_65137380",
                            "body": "UPDATE: I used this solution and added some additional code for getting dicts from lists (as mentioned above) as well as specifying the name of a nested dict IF there&#39;s keys with the same names. Answer posted below!"
                        }
                    ],
                    "owner": {
                        "account_id": 17798746,
                        "reputation": 21,
                        "user_id": 12926062,
                        "user_type": "registered",
                        "display_name": "Gustavo Alves Casqueiro"
                    },
                    "comment_count": 3,
                    "is_accepted": false,
                    "score": 2,
                    "last_activity_date": 1607051419,
                    "creation_date": 1607051419,
                    "answer_id": 65137380,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/65137380#65137380",
                    "body": "<p>I made a simple function, in which you give the key, the new value and the dictionary as input, and it recursively updates it with the value:</p>\n<pre><code>def update(key,value,dictionary):\n    if key in dictionary.keys():\n        dictionary[key] = value\n        return\n    dic_aux = []\n    for val_aux in dictionary.values():\n        if isinstance(val_aux,dict):\n            dic_aux.append(val_aux)\n    for i in dic_aux:\n        update(key,value,i)\n    for [key2,val_aux2] in dictionary.items():\n        if isinstance(val_aux2,dict):\n            dictionary[key2] = val_aux2\n\ndictionary1={'level1':{'level2':{'levelA':0,'levelB':1}}}\nupdate('levelB',10,dictionary1)\nprint(dictionary1)\n\n#output: {'level1': {'level2': {'levelA': 0, 'levelB': 10}}}\n</code></pre>\n<p>Hope it answers.</p>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 82743,
                                "reputation": 3847,
                                "user_id": 232416,
                                "user_type": "registered",
                                "accept_rate": 100,
                                "display_name": "Shaun"
                            },
                            "edited": false,
                            "score": 12,
                            "creation_date": 1638883911,
                            "post_id": 68557484,
                            "comment_id": 124201746,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/68557484#comment124201746_68557484",
                            "body": "This should be upvoted.   Most people should be using this now.  No need to bake your own implementation of this"
                        },
                        {
                            "owner": {
                                "account_id": 7355390,
                                "reputation": 174,
                                "user_id": 5600314,
                                "user_type": "registered",
                                "display_name": "Jorgu"
                            },
                            "edited": false,
                            "score": 4,
                            "creation_date": 1643213366,
                            "post_id": 68557484,
                            "comment_id": 125280927,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/68557484#comment125280927_68557484",
                            "body": "<a href=\"https://github.com/samuelcolvin/pydantic/blob/9d631a3429a66f30742c1a52c94ac18ec6ba848d/pydantic/utils.py#L198\" rel=\"nofollow noreferrer\">pydantic.utils.deep_update on Github</a>  TLDR: it&#39;s recursive, typed, and accept several updates at the same time"
                        },
                        {
                            "owner": {
                                "account_id": 12868472,
                                "reputation": 788,
                                "user_id": 9307834,
                                "user_type": "registered",
                                "display_name": "Piakkaa"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1651558424,
                            "post_id": 68557484,
                            "comment_id": 127386031,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/68557484#comment127386031_68557484",
                            "body": "but pydantic is a huge library and in many cases its not feasible to waste that much space :("
                        },
                        {
                            "owner": {
                                "account_id": 127944,
                                "reputation": 12963,
                                "user_id": 325452,
                                "user_type": "registered",
                                "accept_rate": 71,
                                "display_name": "ingyhere"
                            },
                            "reply_to_user": {
                                "account_id": 12868472,
                                "reputation": 788,
                                "user_id": 9307834,
                                "user_type": "registered",
                                "display_name": "Piakkaa"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1690246567,
                            "post_id": 68557484,
                            "comment_id": 135323490,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/68557484#comment135323490_68557484",
                            "body": "@Piakkaa No need to import the entirety of <code>pydantic</code>, by using <code>from pydantic.utils import deep_update</code> the code is surgically getting a small portion of the module."
                        },
                        {
                            "owner": {
                                "account_id": 3318084,
                                "reputation": 111,
                                "user_id": 3777345,
                                "user_type": "registered",
                                "display_name": "Var14ble"
                            },
                            "edited": false,
                            "score": 2,
                            "creation_date": 1697545531,
                            "post_id": 68557484,
                            "comment_id": 136290991,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/68557484#comment136290991_68557484",
                            "body": "FWIW, pydantic seems to have &quot;deprecated&quot; this in V2 (moved to the v1 sub-package and put it in the deprecated table in the documentation, although it doesn&#39;t raise any warnings and there doesn&#39;t seem to be any conclusive information on when/if it will actually be removed.)"
                        },
                        {
                            "owner": {
                                "account_id": 7739012,
                                "reputation": 287,
                                "user_id": 5893603,
                                "user_type": "registered",
                                "accept_rate": 100,
                                "display_name": "vacky"
                            },
                            "reply_to_user": {
                                "account_id": 3318084,
                                "reputation": 111,
                                "user_id": 3777345,
                                "user_type": "registered",
                                "display_name": "Var14ble"
                            },
                            "edited": false,
                            "score": 1,
                            "creation_date": 1699422483,
                            "post_id": 68557484,
                            "comment_id": 136527977,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/68557484#comment136527977_68557484",
                            "body": "@Var14ble is there a better way to do this in pydantic v2?"
                        },
                        {
                            "owner": {
                                "account_id": 7074737,
                                "reputation": 2302,
                                "user_id": 6084517,
                                "user_type": "registered",
                                "display_name": "Nathan Chappell"
                            },
                            "reply_to_user": {
                                "account_id": 7739012,
                                "reputation": 287,
                                "user_id": 5893603,
                                "user_type": "registered",
                                "accept_rate": 100,
                                "display_name": "vacky"
                            },
                            "edited": false,
                            "score": 2,
                            "creation_date": 1700560267,
                            "post_id": 68557484,
                            "comment_id": 136666773,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/68557484#comment136666773_68557484",
                            "body": "@vacky FWIW According to <a href=\"https://github.com/pydantic/pydantic/discussions/7505\" rel=\"nofollow noreferrer\">this discussion</a>, pydantic will keep <code>V1</code> around until <code>V3</code>.  I&#39;m still using <code>V1</code> for <code>BaseSettings</code> (I don&#39;t want to depend on <code>pydantic-settings</code> when <code>v1.BaseSettings</code> works just fine), now I&#39;ll probably use this <code>deep_update</code> too."
                        },
                        {
                            "owner": {
                                "account_id": 878759,
                                "reputation": 4054,
                                "user_id": 134044,
                                "user_type": "registered",
                                "display_name": "NeilG"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1701505428,
                            "post_id": 68557484,
                            "comment_id": 136786252,
                            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/68557484#comment136786252_68557484",
                            "body": "Pydantic migration guide about depreciated functions like <code>deep_update</code>: <a href=\"https://docs.pydantic.dev/latest/migration/#continue-using-pydantic-v1-features\" rel=\"nofollow noreferrer\">docs.pydantic.dev/latest/migration/&hellip;</a>"
                        }
                    ],
                    "owner": {
                        "account_id": 16554,
                        "reputation": 1882,
                        "user_id": 36195,
                        "user_type": "registered",
                        "display_name": "kepler"
                    },
                    "comment_count": 8,
                    "is_accepted": false,
                    "score": 66,
                    "last_activity_date": 1657369978,
                    "last_edit_date": 1657369978,
                    "creation_date": 1627463328,
                    "answer_id": 68557484,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/68557484#68557484",
                    "body": "<p>If you happen to be using <a href=\"https://github.com/samuelcolvin/pydantic/\" rel=\"noreferrer\">pydantic</a> (great lib, BTW), you can use one of its utility methods:</p>\n<pre><code>from pydantic.utils import deep_update\n\ndictionary1 = deep_update(dictionary1, update)\n</code></pre>\n<p>UPDATE: <a href=\"https://github.com/samuelcolvin/pydantic/blob/fd2991fe6a73819b48c906e3c3274e8e47d0f761/pydantic/utils.py#L200\" rel=\"noreferrer\">reference to code</a>, as pointed by <a href=\"https://stackoverflow.com/users/5600314/jorgu\">@Jorgu</a>. If installing pydantic is not desired, the code is short enough to be copied, provided adequate licenses compatibilities.</p>\n"
                },
                {
                    "owner": {
                        "account_id": 8545263,
                        "reputation": 1009,
                        "user_id": 6404012,
                        "user_type": "registered",
                        "accept_rate": 50,
                        "display_name": "Eitel Dagnin"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 0,
                    "last_activity_date": 1646640116,
                    "creation_date": 1646640116,
                    "answer_id": 71377971,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/71377971#71377971",
                    "body": "<p>Credit to: @Gustavo Alves Casqueiro for original answer</p>\n<p>I honestly would have preferred using a lib that could do the heavy lifting for me, but I just couldn't find something that did what I needed.</p>\n<p>I have only added a couple of additional checks to this function.</p>\n<p>I have included a check for <code>lists</code> within a <code>dict</code> and added a parameter for the name of a nested <code>dict</code> to correctly update the nested <code>dict</code> KEY when there <em><strong>may</strong></em> be another KEY within the OUTER <code>dict</code> with the same name.</p>\n<p>Updated function:</p>\n<pre><code>def update(dictionary: dict[str, any], key: str, value: any, nested_dict_name: str = None) -&gt; dict[str, any]:\n    if not nested_dict_name:  # if current (outermost) dict should be updated\n        if key in dictionary.keys():  # check if key exists in current dict\n            dictionary[key] = value\n            return dictionary\n    else:  # if nested dict should be updated\n        if nested_dict_name in dictionary.keys():  # check if dict is in next layer\n            if isinstance(dictionary[nested_dict_name], dict):\n                if key in dictionary[nested_dict_name].keys():  # check if key exists in current dict\n                    dictionary[nested_dict_name][key] = value\n                    return dictionary\n            if isinstance(dictionary[nested_dict_name], list):\n                list_index = random.choice(range(len(dictionary[nested_dict_name])))  # pick a random dict from the list\n\n                if key in dictionary[nested_dict_name][list_index].keys():  # check if key exists in current dict\n                    dictionary[nested_dict_name][list_index][key] = value\n                    return dictionary\n\n    dic_aux = []\n\n    # this would only run IF the above if-statement was not able to identity and update a dict\n    for val_aux in dictionary.values():\n        if isinstance(val_aux, dict):\n            dic_aux.append(val_aux)\n\n    # call the update function again for recursion\n    for i in dic_aux:\n        return update(dictionary=i, key=key, value=value, nested_dict_name=nested_dict_name)\n</code></pre>\n<p>Original dict:</p>\n<pre><code>{\n    &quot;level1&quot;: {\n        &quot;level2&quot;: {\n            &quot;myBool&quot;: &quot;Original&quot;,\n            &quot;myInt&quot;: &quot;Original&quot;\n        },\n        &quot;myInt&quot;: &quot;Original&quot;,\n        &quot;myBool&quot;: &quot;Original&quot;\n    },\n    &quot;myStr&quot;: &quot;Original&quot;,\n    &quot;level3&quot;: [\n        {\n            &quot;myList&quot;: &quot;Original&quot;,\n            &quot;myInt&quot;: &quot;Original&quot;,\n            &quot;myBool&quot;: &quot;Original&quot;\n        }\n    ],\n    &quot;level4&quot;: [\n        {\n            &quot;myList&quot;: &quot;Original&quot;,\n            &quot;myInt&quot;: &quot;UPDATED&quot;,\n            &quot;myBool&quot;: &quot;Original&quot;\n        }\n    ],\n    &quot;level5&quot;: {\n        &quot;level6&quot;: {\n            &quot;myBool&quot;: &quot;Original&quot;,\n            &quot;myInt&quot;: &quot;Original&quot;\n        },\n        &quot;myInt&quot;: &quot;Original&quot;,\n        &quot;myBool&quot;: &quot;Original&quot;\n    }\n}\n</code></pre>\n<p>Data for updating (using <code>pytest</code>):</p>\n<pre><code>@pytest.fixture(params=[(None, 'myStr', 'UPDATED'),\n                        ('level1', 'myInt', 'UPDATED'),\n                        ('level2', 'myBool', 'UPDATED'),\n                        ('level3', 'myList', 'UPDATED'),\n                        ('level4', 'myInt', 'UPDATED'),\n                        ('level5', 'myBool', 'UPDATED')])\ndef sample_data(request):\n    return request.param\n</code></pre>\n<p>The <code>'UPDATED'</code> parameter doesn't make sense in this smaller use case (since I could just hard-code it), but for simplicity when reading the logs, I didn't want to see multiple data-types and just made it show me an <code>'UPDATED'</code> string.</p>\n<p>Test:</p>\n<pre><code>@pytest.mark.usefixtures('sample_data')\ndef test_this(sample_data):\n    nested_dict, param, update_value = sample_data\n\n    if nested_dict is None:\n        print(f'\\nDict Value: Level0\\nParam: {param}\\nUpdate Value: {update_value}')\n    else:\n        print(f'\\nDict Value: {nested_dict}\\nParam: {param}\\nUpdate Value: {update_value}')\n\n    # initialise data dict\n    data_object = # insert data here (see example dict above)\n\n    # first print as is\n    print(f'\\nOriginal Dict:\\n{data_object}')\n\n    update(dictionary=data_object,\n           key=param,\n           value=update_value,\n           nested_dict_name=nested_dict)\n\n    # print updated\n    print(f'\\nUpdated Dict:\\n{data_object}')\n</code></pre>\n<p>There is one caveat, when you have a dict like this:</p>\n<pre><code>{\n    &quot;level1&quot;: {\n        &quot;level2&quot;: {\n            &quot;myBool&quot;: &quot;Original&quot;\n        },\n        &quot;myBool&quot;: &quot;Original&quot;\n    },\n    &quot;level3&quot;: {\n        &quot;level2&quot;: {\n            &quot;myBool&quot;: &quot;Original&quot;\n        },\n        &quot;myInt&quot;: &quot;Original&quot;\n    }\n}\n</code></pre>\n<p>Where <code>level2</code> is under <code>level1</code> AND <code>level3</code>. This would require making using of a <code>list</code> or something with the <code>nested_dict_name</code> and passing in the name of the outer <code>dict</code> AND inner <code>dict</code> (<code>['level5', 'level2']</code>) and then somehow looping through the values to find that <code>dict</code>.</p>\n<p>However, since I haven't <em><strong>yet</strong></em> ran into this issue for the data objects I use, I haven't spent the time trying to solve this &quot;issue&quot;.</p>\n"
                },
                {
                    "owner": {
                        "account_id": 16660741,
                        "reputation": 1301,
                        "user_id": 12040751,
                        "user_type": "registered",
                        "display_name": "edd313"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 0,
                    "last_activity_date": 1646785367,
                    "creation_date": 1646785367,
                    "answer_id": 71402969,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/71402969#71402969",
                    "body": "<p>Convert your dictionaries into <code>NestedDict</code></p>\n<pre><code>from ndicts.ndicts import NestedDict\n\ndictionary1 = {'level1': {'level2': {'levelA': 0, 'levelB': 1}}}\nupdate = {'level1': {'level2': {'levelB': 10}}}\n\nnd, nd_update = NestedDict(dictionary1), NestedDict(update)\n</code></pre>\n<p>Then just use update</p>\n<pre><code>&gt;&gt;&gt; nd.update(nd_update)\n&gt;&gt;&gt; nd\nNestedDict({'level1': {'level2': {'levelA': 0, 'levelB': 10}}})\n</code></pre>\n<p>If you need the result as a dictionary <code>nd.to_dict()</code></p>\n<p>To install <a href=\"https://github.com/edd313/ndicts\" rel=\"nofollow noreferrer\">ndicts</a> <code>pip install ndicts</code></p>\n"
                },
                {
                    "owner": {
                        "account_id": 18704351,
                        "reputation": 89,
                        "user_id": 13635865,
                        "user_type": "registered",
                        "display_name": "Den Avrondo"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 0,
                    "last_activity_date": 1664381172,
                    "creation_date": 1664381172,
                    "answer_id": 73884610,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/73884610#73884610",
                    "body": "<p><code>d</code> is dict to update, <code>u</code> is dict-updater.</p>\n<pre><code>def recursively_update_dict(d: dict, u: dict):\n    for k, v in u.items():\n        if isinstance(v, dict):\n            d.setdefault(k, {})\n            recursively_update_dict(d[k], v)\n        else:\n            d[k] = v\n</code></pre>\n<p>Or for defaultdict</p>\n<pre><code>from collections import defaultdict\n\ndef recursively_update_defaultdict(d: defaultdict[dict], u: dict):\n    for k, v in u.items():\n        if isinstance(v, dict):\n            recursively_update_dict(d[k], v)\n        else:\n            d[k] = v\n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 35843,
                        "reputation": 2511,
                        "user_id": 101831,
                        "user_type": "registered",
                        "accept_rate": 25,
                        "display_name": "Pascal Polleunus"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 0,
                    "last_activity_date": 1688805918,
                    "creation_date": 1688805918,
                    "answer_id": 76642106,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/76642106#76642106",
                    "body": "<p>Basic solution (in case someone arrives here looking for that)</p>\n<pre><code>dictionary1 = {\n    &quot;level1&quot;: {\n        &quot;level2&quot;: {&quot;levelA&quot;: 0, &quot;levelB&quot;: 1}\n    }\n}\n\ndictionary1.update({\n    &quot;level1&quot;: {\n        &quot;level2&quot;: {\n            **dictionary1[&quot;level1&quot;][&quot;level2&quot;],\n            &quot;levelB&quot;: 10\n        }\n    }\n})\n</code></pre>\n<p><strong>Result:</strong></p>\n<pre><code>{'level1': {'level2': {'levelA': 0, 'levelB': 10}}}\n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 10888778,
                        "reputation": 1347,
                        "user_id": 8005373,
                        "user_type": "registered",
                        "display_name": "Hans Bouwmeester"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 0,
                    "last_activity_date": 1690297980,
                    "creation_date": 1690297980,
                    "answer_id": 76764109,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/76764109#76764109",
                    "body": "<p>Here's what I use:</p>\n<pre><code>from collections.abc import MutableMapping as Map\n\ndef merge(d, v):\n    &quot;&quot;&quot;\n    Merge two dictionaries.\n\n    Merge dict-like `v` into dict-like `d`. In case keys between them\n    are the same, merge their sub-dictionaries. Otherwise, values in  \n    `v` overwrite `d`.\n    &quot;&quot;&quot;\n    for key in v:\n        if key in d and isinstance(d[key], Map) and isinstance(v[key], Map):\n            d[key] = merge(d[key], v[key])\n        else:\n            d[key] = v[key]\n    return d\n</code></pre>\n<pre><code>merge(dictionary1, update)\nprint(dictionary1)\n\n&gt;&gt;&gt; {'level1': {'level2': {'levelA': 0, 'levelB': 10}}}\n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 16654328,
                        "reputation": 11,
                        "user_id": 12036189,
                        "user_type": "registered",
                        "display_name": "Just"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 0,
                    "last_activity_date": 1693452745,
                    "creation_date": 1693452745,
                    "answer_id": 77012702,
                    "question_id": 3232943,
                    "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth/77012702#77012702",
                    "body": "<p>The answer from @kepler helps me, but when I run</p>\n<pre><code>from pydantic.utils import deep_update\ndict1 = deep_update(dict1, dict2)\n</code></pre>\n<p>a warning comes out:</p>\n<pre><code>UserWarning: `pydantic.utils:deep_update` has been removed. We are importing from `pydantic.v1.utils:deep_update` instead.See the migration guide for more details: https://docs.pydantic.dev/latest/migration/\n  f'`{import_path}` has been removed. We are importing from `{new_location}` instead.'\n</code></pre>\n<p>So I change the import command to</p>\n<pre><code>from pydantic.v1.utils import deep_update\n</code></pre>\n"
                }
            ],
            "owner": {
                "account_id": 136601,
                "reputation": 3753,
                "user_id": 340212,
                "user_type": "registered",
                "accept_rate": 48,
                "display_name": "jay_t"
            },
            "comment_count": 4,
            "is_answered": true,
            "accepted_answer_id": 3233356,
            "answer_count": 31,
            "score": 298,
            "last_activity_date": 1695103818,
            "creation_date": 1278975672,
            "last_edit_date": 1677093806,
            "question_id": 3232943,
            "link": "https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth",
            "title": "Update value of a nested dictionary of varying depth",
            "body": "<p>I'm looking for a way to update dict <code>dictionary1</code> with the contents of dict <code>update</code> wihout overwriting <code>levelA</code></p>\n<pre class=\"lang-py prettyprint-override\"><code>dictionary1 = {\n    &quot;level1&quot;: {\n        &quot;level2&quot;: {&quot;levelA&quot;: 0, &quot;levelB&quot;: 1}\n    }\n}\nupdate = {\n    &quot;level1&quot;: {\n        &quot;level2&quot;: {&quot;levelB&quot;: 10}\n    }\n}\ndictionary1.update(update)\nprint(dictionary1)\n</code></pre>\n<pre class=\"lang-py prettyprint-override\"><code>{\n    &quot;level1&quot;: {\n        &quot;level2&quot;: {&quot;levelB&quot;: 10}\n    }\n}\n</code></pre>\n<p>I know that update deletes the values in level2 because it's updating the lowest key level1.</p>\n<p>How could I tackle this, given that dictionary1 and update can have any length?</p>\n"
        }
    ],
    "has_more": false,
    "quota_max": 10000,
    "quota_remaining": 9653
}