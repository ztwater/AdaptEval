{
    "items": [
        {
            "tags": [
                "python",
                "decorator"
            ],
            "answers": [
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 35314,
                                "reputation": 32670,
                                "user_id": 99989,
                                "user_type": "registered",
                                "accept_rate": 94,
                                "display_name": "Neil G"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1308421180,
                            "post_id": 6394966,
                            "comment_id": 7499361,
                            "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/6394966#comment7499361_6394966",
                            "body": "Thanks mouad.  Do you know what the purpose of the <code>__get__</code> method is?"
                        },
                        {
                            "owner": {
                                "account_id": 35314,
                                "reputation": 32670,
                                "user_id": 99989,
                                "user_type": "registered",
                                "accept_rate": 94,
                                "display_name": "Neil G"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1308421449,
                            "post_id": 6394966,
                            "comment_id": 7499407,
                            "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/6394966#comment7499407_6394966",
                            "body": "Oh, I see: it makes the decorator work with methods?  It probably should be in class_wraps then?"
                        },
                        {
                            "owner": {
                                "account_id": 95256,
                                "reputation": 69061,
                                "user_id": 479633,
                                "user_type": "registered",
                                "display_name": "mouad"
                            },
                            "reply_to_user": {
                                "account_id": 35314,
                                "reputation": 32670,
                                "user_id": 99989,
                                "user_type": "registered",
                                "accept_rate": 94,
                                "display_name": "Neil G"
                            },
                            "edited": false,
                            "score": 1,
                            "creation_date": 1308423245,
                            "post_id": 6394966,
                            "comment_id": 7499626,
                            "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/6394966#comment7499626_6394966",
                            "body": "@Neil: Yes For more detail: <a href=\"http://stackoverflow.com/questions/5469956/python-decorator-self-is-mixed-up/5470017#5470017\" title=\"python decorator self is mixed up\">stackoverflow.com/questions/5469956/&hellip;</a> , IMO i don&#39;t think so because it will violate one of the principles that i believe in for function or class which is <b>unique responsibility</b> , which in the case of <code>class_wraps</code> will be to <b>Update a wrapper class to look like the wrapped.</b> no less not more :)"
                        },
                        {
                            "owner": {
                                "account_id": 35314,
                                "reputation": 32670,
                                "user_id": 99989,
                                "user_type": "registered",
                                "accept_rate": 94,
                                "display_name": "Neil G"
                            },
                            "reply_to_user": {
                                "account_id": 95256,
                                "reputation": 69061,
                                "user_id": 479633,
                                "user_type": "registered",
                                "display_name": "mouad"
                            },
                            "edited": false,
                            "score": 1,
                            "creation_date": 1308435493,
                            "post_id": 6394966,
                            "comment_id": 7501301,
                            "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/6394966#comment7501301_6394966",
                            "body": "@mouad: Thanks a lot.  I have a couple more questions (for you or anyone else) if you don&#39;t mind:  1. Isn&#39;t it true that we will want to override <code>__get__</code> for all &quot;callable class&quot; decorators?  2.  Why do we use <code>functools.partial</code> instead of returning a bound method with <code>types.MethodType(self.__call__, obj)</code>?"
                        },
                        {
                            "owner": {
                                "account_id": 95256,
                                "reputation": 69061,
                                "user_id": 479633,
                                "user_type": "registered",
                                "display_name": "mouad"
                            },
                            "reply_to_user": {
                                "account_id": 35314,
                                "reputation": 32670,
                                "user_id": 99989,
                                "user_type": "registered",
                                "accept_rate": 94,
                                "display_name": "Neil G"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1308505443,
                            "post_id": 6394966,
                            "comment_id": 7508670,
                            "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/6394966#comment7508670_6394966",
                            "body": "@Neil: 1. Yes if you want to be able to decorate also methods (not just functions) as you already said , and i strongly believe that it&#39;s a good practice to implement also the <code>_get__</code> method for class decorator so to not have any weird problems after :) 2. I think it just a a question of preference <code>the beauty is in the eye of the beholder</code> right , i prefer to use <code>functools.partial</code> in cases like this one and mostly i use <code>types.*</code> to test the types of an object, Hope i answer your questions :)"
                        },
                        {
                            "owner": {
                                "account_id": 365893,
                                "reputation": 90060,
                                "user_id": 711085,
                                "user_type": "registered",
                                "display_name": "ninjagecko"
                            },
                            "reply_to_user": {
                                "account_id": 95256,
                                "reputation": 69061,
                                "user_id": 479633,
                                "user_type": "registered",
                                "display_name": "mouad"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1308543011,
                            "post_id": 6394966,
                            "comment_id": 7512826,
                            "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/6394966#comment7512826_6394966",
                            "body": "@mouad: oops, I misunderstood your code. I apologize for the downvote. I will upvote you somewhere else you deserve..."
                        },
                        {
                            "owner": {
                                "account_id": 95256,
                                "reputation": 69061,
                                "user_id": 479633,
                                "user_type": "registered",
                                "display_name": "mouad"
                            },
                            "reply_to_user": {
                                "account_id": 365893,
                                "reputation": 90060,
                                "user_id": 711085,
                                "user_type": "registered",
                                "display_name": "ninjagecko"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1308568346,
                            "post_id": 6394966,
                            "comment_id": 7517288,
                            "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/6394966#comment7517288_6394966",
                            "body": "@ninjagecko: hehehe, no worries :)"
                        },
                        {
                            "owner": {
                                "account_id": 441885,
                                "reputation": 60711,
                                "user_id": 832230,
                                "user_type": "registered",
                                "display_name": "Asclepius"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1374089427,
                            "post_id": 6394966,
                            "comment_id": 25807478,
                            "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/6394966#comment25807478_6394966",
                            "body": "In Python 2.7, the line <code>super().__init__(wrapped)</code> raises the exception <code>TypeError: super() takes at least 1 argument (0 given)</code>."
                        }
                    ],
                    "owner": {
                        "account_id": 95256,
                        "reputation": 69061,
                        "user_id": 479633,
                        "user_type": "registered",
                        "display_name": "mouad"
                    },
                    "comment_count": 8,
                    "is_accepted": false,
                    "score": 29,
                    "last_activity_date": 1590445424,
                    "last_edit_date": 1590445424,
                    "creation_date": 1308387783,
                    "answer_id": 6394966,
                    "question_id": 6394511,
                    "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/6394966#6394966",
                    "body": "<p>I'm not aware of such things in stdlib, but we can create our own if we need to.</p>\n\n<p>Something like this can work :</p>\n\n<pre><code>from functools import WRAPPER_ASSIGNMENTS\n\n\ndef class_wraps(cls):\n    \"\"\"Update a wrapper class `cls` to look like the wrapped.\"\"\"\n\n    class Wrapper(cls):\n        \"\"\"New wrapper that will extend the wrapper `cls` to make it look like `wrapped`.\n\n        wrapped: Original function or class that is beign decorated.\n        assigned: A list of attribute to assign to the the wrapper, by default they are:\n             ['__doc__', '__name__', '__module__', '__annotations__'].\n\n        \"\"\"\n\n        def __init__(self, wrapped, assigned=WRAPPER_ASSIGNMENTS):\n            self.__wrapped = wrapped\n            for attr in assigned:\n                setattr(self, attr, getattr(wrapped, attr))\n\n            super().__init__(wrapped)\n\n        def __repr__(self):\n            return repr(self.__wrapped)\n\n    return Wrapper\n</code></pre>\n\n<p>Usage:</p>\n\n<pre><code>@class_wraps\nclass memoized:\n    \"\"\"Decorator that caches a function's return value each time it is called.\n    If called later with the same arguments, the cached value is returned, and\n    not re-evaluated.\n    \"\"\"\n\n    def __init__(self, func):\n        super().__init__()\n        self.func = func\n        self.cache = {}\n\n    def __call__(self, *args):\n        try:\n            return self.cache[args]\n        except KeyError:\n            value = self.func(*args)\n            self.cache[args] = value\n            return value\n        except TypeError:\n            # uncacheable -- for instance, passing a list as an argument.\n            # Better to not cache than to blow up entirely.\n            return self.func(*args)\n\n    def __get__(self, obj, objtype):\n        return functools.partial(self.__call__, obj)\n\n\n@memoized\ndef fibonacci(n):\n    \"\"\"fibonacci docstring\"\"\"\n    if n in (0, 1):\n       return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\n\nprint(fibonacci)\nprint(\"__doc__: \", fibonacci.__doc__)\nprint(\"__name__: \", fibonacci.__name__)\n</code></pre>\n\n<p>Output:</p>\n\n<pre><code>&lt;function fibonacci at 0x14627c0&gt;\n__doc__:  fibonacci docstring\n__name__:  fibonacci\n</code></pre>\n\n<p><strong>EDIT:</strong></p>\n\n<p>And if you are wondering why this wasn't included in the stdlib is because you can\nwrap your class decorator in a function decorator and use <code>functools.wraps</code> like this:</p>\n\n<pre><code>def wrapper(f):\n\n    memoize = memoized(f)\n\n    @functools.wraps(f)\n    def helper(*args, **kws):\n        return memoize(*args, **kws)\n\n    return helper\n\n\n@wrapper\ndef fibonacci(n):\n    \"\"\"fibonacci docstring\"\"\"\n    if n &lt;= 1:\n       return n\n    return fibonacci(n-1) + fibonacci(n-2)\n</code></pre>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 365893,
                                "reputation": 90060,
                                "user_id": 711085,
                                "user_type": "registered",
                                "display_name": "ninjagecko"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1308542612,
                            "post_id": 6406392,
                            "comment_id": 7512777,
                            "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/6406392#comment7512777_6406392",
                            "body": "The reason you shouldn&#39;t use this is because, as you show, you have to call the <code>__init__</code> method of the parent classes (not necessarily just <code>super()</code>; you should google for <code>method resolution order python</code>)."
                        },
                        {
                            "owner": {
                                "account_id": 35314,
                                "reputation": 32670,
                                "user_id": 99989,
                                "user_type": "registered",
                                "accept_rate": 94,
                                "display_name": "Neil G"
                            },
                            "reply_to_user": {
                                "account_id": 365893,
                                "reputation": 90060,
                                "user_id": 711085,
                                "user_type": "registered",
                                "display_name": "ninjagecko"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1308542915,
                            "post_id": 6406392,
                            "comment_id": 7512815,
                            "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/6406392#comment7512815_6406392",
                            "body": "@ninjagecko: Isn&#39;t it up to the super class to call the <code>__init__</code> method of the other parent classes?"
                        },
                        {
                            "owner": {
                                "account_id": 365893,
                                "reputation": 90060,
                                "user_id": 711085,
                                "user_type": "registered",
                                "display_name": "ninjagecko"
                            },
                            "reply_to_user": {
                                "account_id": 35314,
                                "reputation": 32670,
                                "user_id": 99989,
                                "user_type": "registered",
                                "accept_rate": 94,
                                "display_name": "Neil G"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1308545313,
                            "post_id": 6406392,
                            "comment_id": 7513045,
                            "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/6406392#comment7513045_6406392",
                            "body": "It somewhat of an open question, as far as I know, I may be wrong though. <a href=\"http://fuhm.net/super-harmful/\" rel=\"nofollow noreferrer\">fuhm.net/super-harmful</a> Also <a href=\"http://stackoverflow.com/questions/1385759/should-init-call-the-parent-classs-init\" title=\"should init call the parent classs init\">stackoverflow.com/questions/1385759/&hellip;</a> does not seem to indicate any consensus."
                        },
                        {
                            "owner": {
                                "account_id": 35314,
                                "reputation": 32670,
                                "user_id": 99989,
                                "user_type": "registered",
                                "accept_rate": 94,
                                "display_name": "Neil G"
                            },
                            "reply_to_user": {
                                "account_id": 365893,
                                "reputation": 90060,
                                "user_id": 711085,
                                "user_type": "registered",
                                "display_name": "ninjagecko"
                            },
                            "edited": false,
                            "score": 1,
                            "creation_date": 1308545693,
                            "post_id": 6406392,
                            "comment_id": 7513092,
                            "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/6406392#comment7513092_6406392",
                            "body": "@ninjagecko: Yes, I&#39;ve read the first article.  What I&#39;ve been doing is to always call super().__init__ from every class no matter what.  This way I can count on all <code>__init__</code> methods being called as long as everyone I inherit from does this.  Unfortunately, I&#39;ve discovered that PyQt classes don&#39;t do this.  I really thought that this was how co-operative inheritance had to work, but from what you&#39;re saying it sounds like I might be the only one!"
                        }
                    ],
                    "owner": {
                        "account_id": 35314,
                        "reputation": 32670,
                        "user_id": 99989,
                        "user_type": "registered",
                        "accept_rate": 94,
                        "display_name": "Neil G"
                    },
                    "comment_count": 4,
                    "is_accepted": false,
                    "score": 0,
                    "last_activity_date": 1308537903,
                    "creation_date": 1308537903,
                    "answer_id": 6406392,
                    "question_id": 6394511,
                    "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/6406392#6406392",
                    "body": "<p>Another solution using inheritance:</p>\n\n<pre><code>import functools\nimport types\n\nclass CallableClassDecorator:\n    \"\"\"Base class that extracts attributes and assigns them to self.\n\n    By default the extracted attributes are:\n         ['__doc__', '__name__', '__module__'].\n    \"\"\"\n\n    def __init__(self, wrapped, assigned=functools.WRAPPER_ASSIGNMENTS):\n        for attr in assigned:\n            setattr(self, attr, getattr(wrapped, attr))\n        super().__init__()\n\n    def __get__(self, obj, objtype):\n        return types.MethodType(self.__call__, obj)\n</code></pre>\n\n<p>And, usage:</p>\n\n<pre><code>class memoized(CallableClassDecorator):\n    \"\"\"Decorator that caches a function's return value each time it is called.\n    If called later with the same arguments, the cached value is returned, and\n    not re-evaluated.\n    \"\"\"\n    def __init__(self, function):\n        super().__init__(function)\n        self.function = function\n        self.cache = {}\n\n    def __call__(self, *args):\n        try:\n            return self.cache[args]\n        except KeyError:\n            value = self.function(*args)\n            self.cache[args] = value\n            return value\n        except TypeError:\n            # uncacheable -- for instance, passing a list as an argument.\n            # Better to not cache than to blow up entirely.\n            return self.function(*args)\n</code></pre>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 873453,
                                "reputation": 11133,
                                "user_id": 923794,
                                "user_type": "registered",
                                "accept_rate": 91,
                                "display_name": "cfi"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1332489407,
                            "post_id": 6406676,
                            "comment_id": 12533106,
                            "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/6406676#comment12533106_6406676",
                            "body": "The @hygienic does not work for code where the wrapped decorator class has a class attribute. Mouad&#39;s solution works though. The problem reported is: <code>AttributeError: &#39;function&#39; object has no attribute &#39;level&#39;</code> when trying to do <code>decoratorclassname.level += 1</code> inside the <code>__call__</code>"
                        }
                    ],
                    "owner": {
                        "account_id": 365893,
                        "reputation": 90060,
                        "user_id": 711085,
                        "user_type": "registered",
                        "display_name": "ninjagecko"
                    },
                    "comment_count": 1,
                    "is_accepted": false,
                    "score": 1,
                    "last_activity_date": 1308544984,
                    "last_edit_date": 1308544984,
                    "creation_date": 1308542078,
                    "answer_id": 6406676,
                    "question_id": 6394511,
                    "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/6406676#6406676",
                    "body": "<p>All we really need to do is modify the behavior of the decorator so that it is \"hygienic\", i.e. it is attribute-preserving.</p>\n\n<pre><code>#!/usr/bin/python3\n\ndef hygienic(decorator):\n    def new_decorator(original):\n        wrapped = decorator(original)\n        wrapped.__name__ = original.__name__\n        wrapped.__doc__ = original.__doc__\n        wrapped.__module__ = original.__module__\n        return wrapped\n    return new_decorator\n</code></pre>\n\n<p>This is ALL you need. In general. It doesn't preserve the signature, but if you really want that you can use a library to do that. I also went ahead and rewrote the memoization code so that it works on keyword arguments as well. Also there was a bug where failure to convert it to a hashable tuple would make it not work in 100% of cases.</p>\n\n<p>Demo of rewritten <code>memoized</code> decorator with <code>@hygienic</code> modifying its behavior. <code>memoized</code> is now a function that wraps the original class, though you can (like the other answer) write a wrapping class instead, or even better, something which detects if it's a class and if so wraps the <code>__init__</code> method.</p>\n\n<pre><code>@hygienic\nclass memoized:\n    def __init__(self, func):\n        self.func = func\n        self.cache = {}\n\n    def __call__(self, *args, **kw):\n        try:\n            key = (tuple(args), frozenset(kw.items()))\n            if not key in self.cache:\n                self.cache[key] = self.func(*args,**kw)\n            return self.cache[key]\n        except TypeError:\n            # uncacheable -- for instance, passing a list as an argument.\n            # Better to not cache than to blow up entirely.\n            return self.func(*args,**kw)\n</code></pre>\n\n<p>In action:</p>\n\n<pre><code>@memoized\ndef f(a, b=5, *args, keyword=10):\n    \"\"\"Intact docstring!\"\"\"\n    print('f was called!')\n    return {'a':a, 'b':b, 'args':args, 'keyword':10}\n\nx=f(0)  \n#OUTPUT: f was called!\nprint(x)\n#OUTPUT: {'a': 0, 'b': 5, 'keyword': 10, 'args': ()}                 \n\ny=f(0)\n#NO OUTPUT - MEANS MEMOIZATION IS WORKING\nprint(y)\n#OUTPUT: {'a': 0, 'b': 5, 'keyword': 10, 'args': ()}          \n\nprint(f.__name__)\n#OUTPUT: 'f'\nprint(f.__doc__)\n#OUTPUT: 'Intact docstring!'\n</code></pre>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 2257675,
                                "reputation": 3740,
                                "user_id": 1988505,
                                "user_type": "registered",
                                "accept_rate": 100,
                                "display_name": "Wesley Baugh"
                            },
                            "edited": false,
                            "score": 22,
                            "creation_date": 1416294334,
                            "post_id": 17705456,
                            "comment_id": 42509102,
                            "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/17705456#comment42509102_17705456",
                            "body": "The <code>__name__</code> and <code>__doc__</code> are set on the <i>instance</i>, but not the class, which is what is always used by <code>help(instance)</code>. To fix, a class-based decorator implementation cannot be used, and instead the decorator must be implemented as a function. For details see <a href=\"http://stackoverflow.com/a/25973438/1988505\">stackoverflow.com/a/25973438/1988505</a>."
                        },
                        {
                            "owner": {
                                "account_id": 297553,
                                "reputation": 2888,
                                "user_id": 603136,
                                "user_type": "registered",
                                "accept_rate": 84,
                                "display_name": "samwyse"
                            },
                            "edited": false,
                            "score": 3,
                            "creation_date": 1490801108,
                            "post_id": 17705456,
                            "comment_id": 73276940,
                            "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/17705456#comment73276940_17705456",
                            "body": "I&#39;m not sure why my answer was suddenly marked down yesterday.  No one asked about getting help() to work.  In 3.5, inspect.signature() and inspect.from_callable() got a new follow_wrapped option; perhaps help() should do the same?"
                        },
                        {
                            "owner": {
                                "account_id": 49162,
                                "reputation": 22288,
                                "user_id": 146289,
                                "user_type": "registered",
                                "accept_rate": 79,
                                "display_name": "vdboor"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1545237504,
                            "post_id": 17705456,
                            "comment_id": 94558932,
                            "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/17705456#comment94558932_17705456",
                            "body": "Fortunately ipython&#39;s <code>fibonacci?</code> does show both the <b>doc</b> from the wrapper, and the memoized class so you get both"
                        },
                        {
                            "owner": {
                                "account_id": 108161,
                                "reputation": 6729,
                                "user_id": 287238,
                                "user_type": "registered",
                                "accept_rate": 75,
                                "display_name": "safetyduck"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1588095034,
                            "post_id": 17705456,
                            "comment_id": 108766631,
                            "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/17705456#comment108766631_17705456",
                            "body": "This does not produce picklable class decorators"
                        },
                        {
                            "owner": {
                                "account_id": 297553,
                                "reputation": 2888,
                                "user_id": 603136,
                                "user_type": "registered",
                                "accept_rate": 84,
                                "display_name": "samwyse"
                            },
                            "edited": false,
                            "score": 1,
                            "creation_date": 1656104447,
                            "post_id": 17705456,
                            "comment_id": 128498645,
                            "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/17705456#comment128498645_17705456",
                            "body": "Update: Starting from Python 3.9, help() now shows the wrapped function&#39;s docstring, though it still lacks the argument list"
                        }
                    ],
                    "owner": {
                        "account_id": 297553,
                        "reputation": 2888,
                        "user_id": 603136,
                        "user_type": "registered",
                        "accept_rate": 84,
                        "display_name": "samwyse"
                    },
                    "comment_count": 5,
                    "is_accepted": true,
                    "score": 88,
                    "last_activity_date": 1650113138,
                    "last_edit_date": 1650113138,
                    "creation_date": 1374078975,
                    "answer_id": 17705456,
                    "question_id": 6394511,
                    "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/17705456#17705456",
                    "body": "<p>Everyone seems to have missed the obvious solution. Using <a href=\"https://docs.python.org/3/library/functools.html#functools.update_wrapper\" rel=\"noreferrer\"><code>functools.update_wrapper</code></a>:</p>\n<pre><code>&gt;&gt;&gt; import functools\n&gt;&gt;&gt; class memoized(object):\n    &quot;&quot;&quot;Decorator that caches a function's return value each time it is called.\n    If called later with the same arguments, the cached value is returned, and\n    not re-evaluated.\n    &quot;&quot;&quot;\n    def __init__(self, func):\n        self.func = func\n        self.cache = {}\n        functools.update_wrapper(self, func)  ## TA-DA! ##\n    def __call__(self, *args):\n        pass  # Not needed for this demo.\n\n&gt;&gt;&gt; @memoized\ndef fibonacci(n):\n    &quot;&quot;&quot;fibonacci docstring&quot;&quot;&quot;\n    pass  # Not needed for this demo.\n\n&gt;&gt;&gt; fibonacci\n&lt;__main__.memoized object at 0x0156DE30&gt;\n&gt;&gt;&gt; fibonacci.__name__\n'fibonacci'\n&gt;&gt;&gt; fibonacci.__doc__\n'fibonacci docstring'\n</code></pre>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 27866,
                                "reputation": 5486,
                                "user_id": 73957,
                                "user_type": "registered",
                                "accept_rate": 75,
                                "display_name": "temoto"
                            },
                            "edited": false,
                            "score": 1,
                            "creation_date": 1482375107,
                            "post_id": 41275076,
                            "comment_id": 69751603,
                            "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/41275076#comment69751603_41275076",
                            "body": "Side note, I invite everybody to use this <code>.is_timeout=True</code> idiom to mark your timeout caused errors and accept this API from other packages."
                        }
                    ],
                    "owner": {
                        "account_id": 27866,
                        "reputation": 5486,
                        "user_id": 73957,
                        "user_type": "registered",
                        "accept_rate": 75,
                        "display_name": "temoto"
                    },
                    "comment_count": 1,
                    "is_accepted": false,
                    "score": 5,
                    "last_activity_date": 1482375014,
                    "creation_date": 1482375014,
                    "answer_id": 41275076,
                    "question_id": 6394511,
                    "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/41275076#41275076",
                    "body": "<p>I needed something that would wrap both classes and functions and wrote this:</p>\n\n<pre><code>def wrap_is_timeout(base):\n    '''Adds `.is_timeout=True` attribute to objects returned by `base()`.\n\n    When `base` is class, it returns a subclass with same name and adds read-only property.\n    Otherwise, it returns a function that sets `.is_timeout` attribute on result of `base()` call.\n\n    Wrappers make best effort to be transparent.\n    '''\n    if inspect.isclass(base):\n        class wrapped(base):\n            is_timeout = property(lambda _: True)\n\n        for k in functools.WRAPPER_ASSIGNMENTS:\n            v = getattr(base, k, _MISSING)\n            if v is not _MISSING:\n                try:\n                    setattr(wrapped, k, v)\n                except AttributeError:\n                    pass\n        return wrapped\n\n    @functools.wraps(base)\n    def fun(*args, **kwargs):\n        ex = base(*args, **kwargs)\n        ex.is_timeout = True\n        return ex\n    return fun\n</code></pre>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 35314,
                                "reputation": 32670,
                                "user_id": 99989,
                                "user_type": "registered",
                                "accept_rate": 94,
                                "display_name": "Neil G"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1609103980,
                            "post_id": 65470430,
                            "comment_id": 115749273,
                            "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/65470430#comment115749273_65470430",
                            "body": "I don&#39;t understand what this has to do with my question.  How do I implement <code>memoized</code> as a class and provide the wrapping functionality?"
                        },
                        {
                            "owner": {
                                "account_id": 433926,
                                "reputation": 8390,
                                "user_id": 819544,
                                "user_type": "registered",
                                "accept_rate": 62,
                                "display_name": "David Marx"
                            },
                            "reply_to_user": {
                                "account_id": 35314,
                                "reputation": 32670,
                                "user_id": 99989,
                                "user_type": "registered",
                                "accept_rate": 94,
                                "display_name": "Neil G"
                            },
                            "edited": false,
                            "score": 7,
                            "creation_date": 1612986986,
                            "post_id": 65470430,
                            "comment_id": 116940492,
                            "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/65470430#comment116940492_65470430",
                            "body": "@NeilG if it makes you feel better, this at least answered <i>my</i> question, which mapped to the title of the OP question but not the specific memoize example."
                        },
                        {
                            "owner": {
                                "account_id": 6587241,
                                "reputation": 387,
                                "user_id": 5092038,
                                "user_type": "registered",
                                "display_name": "meyer1994"
                            },
                            "edited": false,
                            "score": 6,
                            "creation_date": 1637890918,
                            "post_id": 65470430,
                            "comment_id": 123950715,
                            "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/65470430#comment123950715_65470430",
                            "body": "This solved my problem of searching an equivalent of <code>functools.wraps</code> for clases"
                        }
                    ],
                    "owner": {
                        "account_id": 429341,
                        "reputation": 66510,
                        "user_id": 812183,
                        "user_type": "registered",
                        "accept_rate": 77,
                        "display_name": "anthony sottile"
                    },
                    "comment_count": 3,
                    "is_accepted": false,
                    "score": 21,
                    "last_activity_date": 1609102979,
                    "creation_date": 1609102979,
                    "answer_id": 65470430,
                    "question_id": 6394511,
                    "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes/65470430#65470430",
                    "body": "<p>Turns out there's a straightforward solution using <code>functools.wraps</code> itself:</p>\n<pre class=\"lang-py prettyprint-override\"><code>import functools\n\ndef dec(cls):\n    @functools.wraps(cls, updated=())\n    class D(cls):\n        decorated = 1\n    return D\n\n\n@dec\nclass C:\n    &quot;&quot;&quot;doc&quot;&quot;&quot;\n\nprint(f'{C.__name__=} {C.__doc__=} {C.__wrapped__=}')\n</code></pre>\n<pre><code>$ python3 t.py \nC.__name__='C' C.__doc__='doc' C.__wrapped__=&lt;class '__main__.C'&gt;\n</code></pre>\n<p>Note that <code>updated=()</code> is needed to prevent an attempt to update the class's <code>__dict__</code> (this output is without <code>updated=()</code>):</p>\n<pre><code>$ python t.py\nTraceback (most recent call last):\n  File &quot;t.py&quot;, line 26, in &lt;module&gt;\n    class C:\n  File &quot;t.py&quot;, line 20, in dec\n    class D(cls):\n  File &quot;/usr/lib/python3.8/functools.py&quot;, line 57, in update_wrapper\n    getattr(wrapper, attr).update(getattr(wrapped, attr, {}))\nAttributeError: 'mappingproxy' object has no attribute 'update'\n</code></pre>\n"
                }
            ],
            "owner": {
                "account_id": 35314,
                "reputation": 32670,
                "user_id": 99989,
                "user_type": "registered",
                "accept_rate": 94,
                "display_name": "Neil G"
            },
            "comment_count": 0,
            "is_answered": true,
            "accepted_answer_id": 17705456,
            "answer_count": 6,
            "score": 106,
            "last_activity_date": 1650113138,
            "creation_date": 1308381610,
            "last_edit_date": 1308381964,
            "question_id": 6394511,
            "link": "https://stackoverflow.com/questions/6394511/python-functools-wraps-equivalent-for-classes",
            "title": "Python functools.wraps equivalent for classes",
            "body": "<p>When defining a decorator using a class, how do I automatically transfer over<code>__name__</code>, <code>__module__</code> and <code>__doc__</code>?  Normally, I would use the @wraps decorator from functools.  Here's what I did instead for a class (this is not entirely my code):</p>\n\n<pre><code>class memoized:\n    \"\"\"Decorator that caches a function's return value each time it is called.\n    If called later with the same arguments, the cached value is returned, and\n    not re-evaluated.\n    \"\"\"\n    def __init__(self, func):\n        super().__init__()\n        self.func = func\n        self.cache = {}\n\n    def __call__(self, *args):\n        try:\n            return self.cache[args]\n        except KeyError:\n            value = self.func(*args)\n            self.cache[args] = value\n            return value\n        except TypeError:\n            # uncacheable -- for instance, passing a list as an argument.\n            # Better to not cache than to blow up entirely.\n            return self.func(*args)\n\n    def __repr__(self):\n        return self.func.__repr__()\n\n    def __get__(self, obj, objtype):\n        return functools.partial(self.__call__, obj)\n\n    __doc__ = property(lambda self:self.func.__doc__)\n    __module__ = property(lambda self:self.func.__module__)\n    __name__ = property(lambda self:self.func.__name__)\n</code></pre>\n\n<p>Is there a standard decorator to automate the creation of name module and doc?  Also, to automate the get method (I assume that's for creating bound methods?)  Are there any missing methods?</p>\n"
        }
    ],
    "has_more": false,
    "quota_max": 10000,
    "quota_remaining": 6319
}