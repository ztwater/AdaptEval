{
    "items": [
        {
            "tags": [
                "python",
                "image-processing",
                "numpy",
                "matplotlib",
                "imagefilter"
            ],
            "comments": [
                {
                    "owner": {
                        "account_id": 1917216,
                        "reputation": 1296,
                        "user_id": 1729576,
                        "user_type": "registered",
                        "accept_rate": 100,
                        "display_name": "Faultier"
                    },
                    "edited": false,
                    "score": 0,
                    "creation_date": 1378733463,
                    "post_id": 18697532,
                    "comment_id": 27548159,
                    "link": "https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python#comment27548159_18697532",
                    "body": "the scipy.stats package offers the functions nanmean and nanstd, that ignore nan, instead of returning nan. Exchange the numpy.mean / numpy.std in your code by them and everything should be fine (;"
                },
                {
                    "owner": {
                        "account_id": 948860,
                        "reputation": 19399,
                        "user_id": 975477,
                        "user_type": "registered",
                        "accept_rate": 82,
                        "display_name": "Daniel"
                    },
                    "edited": false,
                    "score": 1,
                    "creation_date": 1378734989,
                    "post_id": 18697532,
                    "comment_id": 27549046,
                    "link": "https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python#comment27549046_18697532",
                    "body": "Can you post a sample of your averaging code?"
                },
                {
                    "owner": {
                        "account_id": 160284,
                        "reputation": 86236,
                        "user_id": 380231,
                        "user_type": "registered",
                        "accept_rate": 100,
                        "display_name": "tacaswell"
                    },
                    "edited": false,
                    "score": 0,
                    "creation_date": 1378736842,
                    "post_id": 18697532,
                    "comment_id": 27550150,
                    "link": "https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python#comment27550150_18697532",
                    "body": "Suspect you will have to write the loops to do the convolution and checks your self."
                },
                {
                    "owner": {
                        "account_id": 3280515,
                        "reputation": 339,
                        "user_id": 2761243,
                        "user_type": "registered",
                        "display_name": "user2761243"
                    },
                    "edited": false,
                    "score": 0,
                    "creation_date": 1378745331,
                    "post_id": 18697532,
                    "comment_id": 27555186,
                    "link": "https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python#comment27555186_18697532",
                    "body": "Hi! My averaging code does not have any mystery. But if you like I will add a sample."
                },
                {
                    "owner": {
                        "account_id": 2123624,
                        "reputation": 7683,
                        "user_id": 1886357,
                        "user_type": "registered",
                        "accept_rate": 79,
                        "display_name": "eric"
                    },
                    "edited": false,
                    "score": 0,
                    "creation_date": 1429826991,
                    "post_id": 18697532,
                    "comment_id": 47797240,
                    "link": "https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python#comment47797240_18697532",
                    "body": "Check out Matlab version of this question: <a href=\"http://stackoverflow.com/questions/29833068/filter-image-that-contains-nans-in-matlab\" title=\"filter image that contains nans in matlab\">stackoverflow.com/questions/29833068/&hellip;</a>"
                },
                {
                    "owner": {
                        "account_id": 9093230,
                        "reputation": 143,
                        "user_id": 14776523,
                        "user_type": "registered",
                        "display_name": "pas-calc"
                    },
                    "edited": false,
                    "score": 0,
                    "creation_date": 1649953232,
                    "post_id": 18697532,
                    "comment_id": 127009931,
                    "link": "https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python#comment127009931_18697532",
                    "body": "A simple solution might be to reduce <code>truncate</code> so that a single / each NaN affects fewer points in your output."
                },
                {
                    "owner": {
                        "account_id": 9093230,
                        "reputation": 143,
                        "user_id": 14776523,
                        "user_type": "registered",
                        "display_name": "pas-calc"
                    },
                    "edited": false,
                    "score": 0,
                    "creation_date": 1649953709,
                    "post_id": 18697532,
                    "comment_id": 127010097,
                    "link": "https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python#comment127010097_18697532",
                    "body": "You might verify that this still ensures that the gaussian kernel is normalized by the <a href=\"https://github.com/scipy/scipy/blob/v1.8.0/scipy/ndimage/_filters.py#L189\" rel=\"nofollow noreferrer\">implementation</a>, see <a href=\"https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.gaussian_filter1d.html\" rel=\"nofollow noreferrer\">docs - source</a>."
                }
            ],
            "answers": [
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 670541,
                                "reputation": 1675,
                                "user_id": 512111,
                                "user_type": "registered",
                                "display_name": "j08lue"
                            },
                            "edited": false,
                            "score": 3,
                            "creation_date": 1506972807,
                            "post_id": 36307291,
                            "comment_id": 80019514,
                            "link": "https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python/36307291#comment80019514_36307291",
                            "body": "I don&#39;t know if I completely understand why, but this method works and gives almost the exact same result as <code>astropy.convolve</code> with <code>astropy.convolution.Gaussian2DKernel</code> - and 10x faster."
                        },
                        {
                            "owner": {
                                "account_id": 514227,
                                "reputation": 3545,
                                "user_id": 3478917,
                                "user_type": "registered",
                                "display_name": "Sealander"
                            },
                            "edited": false,
                            "score": 1,
                            "creation_date": 1533577398,
                            "post_id": 36307291,
                            "comment_id": 90387411,
                            "link": "https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python/36307291#comment90387411_36307291",
                            "body": "This is fantastically clever -- and I also don&#39;t fully understand why it works."
                        },
                        {
                            "owner": {
                                "account_id": 5220980,
                                "reputation": 732,
                                "user_id": 4174466,
                                "user_type": "registered",
                                "display_name": "Scott Staniewicz"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1548355933,
                            "post_id": 36307291,
                            "comment_id": 95522181,
                            "link": "https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python/36307291#comment95522181_36307291",
                            "body": "This is great! The WW is a clever way to track how much of the gaussian kernel is valid. Maybe you could make <code>V[U!=U]=0</code> into <code>V[np.isnan(U)]</code> for clarity?"
                        },
                        {
                            "owner": {
                                "account_id": 9897892,
                                "reputation": 58642,
                                "user_id": 7328782,
                                "user_type": "registered",
                                "accept_rate": 86,
                                "display_name": "Cris Luengo"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1548790953,
                            "post_id": 36307291,
                            "comment_id": 95667145,
                            "link": "https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python/36307291#comment95667145_36307291",
                            "body": "This is called normalized convolution."
                        },
                        {
                            "owner": {
                                "account_id": 6964155,
                                "reputation": 1949,
                                "user_id": 5350621,
                                "user_type": "registered",
                                "display_name": "David"
                            },
                            "reply_to_user": {
                                "account_id": 5220980,
                                "reputation": 732,
                                "user_id": 4174466,
                                "user_type": "registered",
                                "display_name": "Scott Staniewicz"
                            },
                            "edited": false,
                            "score": 1,
                            "creation_date": 1551802283,
                            "post_id": 36307291,
                            "comment_id": 96769211,
                            "link": "https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python/36307291#comment96769211_36307291",
                            "body": "Thanks @ScottStaniewicz, I implemented you suggestion!"
                        },
                        {
                            "owner": {
                                "account_id": 68857,
                                "reputation": 14493,
                                "user_id": 200688,
                                "user_type": "registered",
                                "accept_rate": 73,
                                "display_name": "AndyL"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1578068154,
                            "post_id": 36307291,
                            "comment_id": 105329795,
                            "link": "https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python/36307291#comment105329795_36307291",
                            "body": "Clever trick. What happens when you get a large swath of NaNs. Will this result in a divide by zero error? Also, is this equivalent to linearly interpolating first and then convolving?"
                        },
                        {
                            "owner": {
                                "account_id": 6964155,
                                "reputation": 1949,
                                "user_id": 5350621,
                                "user_type": "registered",
                                "display_name": "David"
                            },
                            "reply_to_user": {
                                "account_id": 68857,
                                "reputation": 14493,
                                "user_id": 200688,
                                "user_type": "registered",
                                "accept_rate": 73,
                                "display_name": "AndyL"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1578240060,
                            "post_id": 36307291,
                            "comment_id": 105367260,
                            "link": "https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python/36307291#comment105367260_36307291",
                            "body": "@AndyL Theoretically, the support of the Gaussian function is infinite, so as long as there is one non-NaN entry, the denominator (called WW above) will be strictly positive. Practically, large NaN areas or small Gaussian sigma parameters and limited numerical precision may indeed lead to a denominator WW~0. However, in that case also the nominator VV~0."
                        },
                        {
                            "owner": {
                                "account_id": 877606,
                                "reputation": 1668,
                                "user_id": 104707,
                                "user_type": "registered",
                                "display_name": "amain"
                            },
                            "edited": false,
                            "score": 1,
                            "creation_date": 1584929514,
                            "post_id": 36307291,
                            "comment_id": 107583575,
                            "link": "https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python/36307291#comment107583575_36307291",
                            "body": "@David Theoretically yes, but practically most implementations of gaussian filters are truncated by default. For example, scipy&#39;s <code>ndimage.gaussian_filter</code> has a default truncate value of 4.0 standard deviations. To avoid &#39;division-by-zero&#39;-like numpy warnings, zeros in WW could be converted to NaNs prior to division."
                        },
                        {
                            "owner": {
                                "account_id": 9093230,
                                "reputation": 143,
                                "user_id": 14776523,
                                "user_type": "registered",
                                "display_name": "pas-calc"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1649953153,
                            "post_id": 36307291,
                            "comment_id": 127009906,
                            "link": "https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python/36307291#comment127009906_36307291",
                            "body": "Due to this fact, it might be already a simple solution to adjust (decrease) the <code>truncate</code> argument in the initial gaussian kernel of your data, so that a single NaN might affect less values in your filtered output."
                        },
                        {
                            "owner": {
                                "account_id": 9093230,
                                "reputation": 143,
                                "user_id": 14776523,
                                "user_type": "registered",
                                "display_name": "pas-calc"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1649955121,
                            "post_id": 36307291,
                            "comment_id": 127010594,
                            "link": "https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python/36307291#comment127010594_36307291",
                            "body": "to prevent the warning <code>WW[WW==0]=np.nan</code> , anyway the result of that will be NaN"
                        },
                        {
                            "owner": {
                                "account_id": 430749,
                                "reputation": 18736,
                                "user_id": 814354,
                                "user_type": "registered",
                                "accept_rate": 78,
                                "display_name": "keflavich"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1661476706,
                            "post_id": 36307291,
                            "comment_id": 129787483,
                            "link": "https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python/36307291#comment129787483_36307291",
                            "body": "aside, for the top comment: astropy&#39;s convolution can perform as well as the others if you turn off padding.  See <a href=\"https://github.com/astropy/astropy/issues/11242#issuecomment-760169792\" rel=\"nofollow noreferrer\">github.com/astropy/astropy/issues/11242#issuecomment-7601697&zwnj;&#8203;92</a> and <a href=\"https://keflavich-astropy.readthedocs.io/en/convolve_fft_profiling/convolution/performance.html\" rel=\"nofollow noreferrer\">keflavich-astropy.readthedocs.io/en/convolve_fft_profiling/&hellip;</a>"
                        }
                    ],
                    "owner": {
                        "account_id": 6964155,
                        "reputation": 1949,
                        "user_id": 5350621,
                        "user_type": "registered",
                        "display_name": "David"
                    },
                    "comment_count": 11,
                    "is_accepted": false,
                    "score": 45,
                    "last_activity_date": 1584959356,
                    "last_edit_date": 1584959356,
                    "creation_date": 1459336866,
                    "answer_id": 36307291,
                    "question_id": 18697532,
                    "link": "https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python/36307291#36307291",
                    "body": "<p><strong>in words:</strong></p>\n\n<p>A Gaussian filter which ignores NaNs in a given array <em>U</em> can be easily obtained by applying a standard Gaussian filter to two auxiliary arrays <em>V</em> and <em>W</em> and by taking the ratio of the two to get the result <em>Z</em>.</p>\n\n<p>Here, <em>V</em> is copy of the original <em>U</em> with NaNs replaced by zeros and <em>W</em> is an array of ones with zeros indicating the positions of NaNs in the original <em>U</em>.</p>\n\n<p>The idea is that replacing the NaNs by zeros introduces an error in the filtered array which can, however, be compensated by applying the same Gaussian filter to another auxiliary array and combining the two. </p>\n\n<p><strong>in Python:</strong></p>\n\n<pre><code>import numpy as np\nimport scipy as sp\nimport scipy.ndimage\n\nsigma=2.0                  # standard deviation for Gaussian kernel\ntruncate=4.0               # truncate filter at this many sigmas\n\nU=sp.randn(10,10)          # random array...\nU[U&gt;2]=np.nan              # ...with NaNs for testing\n\nV=U.copy()\nV[np.isnan(U)]=0\nVV=sp.ndimage.gaussian_filter(V,sigma=sigma,truncate=truncate)\n\nW=0*U.copy()+1\nW[np.isnan(U)]=0\nWW=sp.ndimage.gaussian_filter(W,sigma=sigma,truncate=truncate)\n\nZ=VV/WW\n</code></pre>\n\n<p><strong>in numbers:</strong></p>\n\n<p>Here coefficients of the Gaussian filter are set to [0.25,0.50,0.25] for demonstration purposes and they sum up to one 0.25+0.50+0.25=1, without loss of generality.</p>\n\n<p>After replacing the NaNs by zeros and applying the Gaussian filter (cf. VV below) it is clear that the zeros introduce an error, i.e., due to the \"missing\" data the coefficients 0.25+0.50=0.75 do not sum up to one anymore and therefore underestimate the \"true\" value.</p>\n\n<p>However, this can be compensated by using the second auxiliary array (cf. WW below) which, after filtering with the same Gaussian, just contains the sum of coefficients.</p>\n\n<p>Therefore, dividing the two filtered auxiliary arrays rescales the coefficients such that they sum up to one while the NaN positions are ignored.</p>\n\n<pre><code>array U         1   2   NaN 1   2    \nauxiliary V     1   2   0   1   2    \nauxiliary W     1   1   0   1   1\nposition        a   b   c   d   e\n\nfiltered VV_b   = 0.25*V_a  + 0.50*V_b  + 0.25*V_c\n                = 0.25*1    + 0.50*2    + 0\n                = 1.25\n\nfiltered WW_b   = 0.25*W_a  + 0.50*W_b  + 0.25*W_c\n                = 0.25*1    + 0.50*1    + 0\n                = 0.75\n\nratio Z         = VV_b / WW_b  \n                = (0.25*1 + 0.50*2) / (0.25*1    + 0.50*1)\n                = 0.333*1 + 0.666*2\n                = 1.666\n</code></pre>\n\n<p><strong>update - division-by-zero</strong>:</p>\n\n<p>The following incorporates useful questions and answers by @AndyL and @amain from the comments below, thanks! </p>\n\n<p>Large areas of NaNs may lead to a zero denominator (WW=0) at some positions when there are only NaN entries within the support of the Gaussian kernel (in theory that support is infinite, but in practice the kernel is usually truncated, see 'truncate' parameter in code example above). In that situation, the nominator becomes zero as well (VV=0) so that numpy throws a 'RuntimeWarning: invalid value encountered in true_divide' and returns NaN at the corresponding positions.</p>\n\n<p>This is probably the most consistent/meaningful result and if you can live with a numpy warning, no further adjustments are required.</p>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 14933384,
                                "reputation": 11067,
                                "user_id": 10808674,
                                "user_type": "registered",
                                "display_name": "Alain Merigot"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1548793744,
                            "post_id": 54428420,
                            "comment_id": 95668279,
                            "link": "https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python/54428420#comment95668279_54428420",
                            "body": "I am not sure this answers the question. If Original Poster has NaNs, it will not help. An op with a nan returns a nan. Maybe you should elaborate on your answer."
                        },
                        {
                            "owner": {
                                "account_id": 15226101,
                                "reputation": 21,
                                "user_id": 10986701,
                                "user_type": "registered",
                                "display_name": "Christopher Grimm"
                            },
                            "reply_to_user": {
                                "account_id": 14933384,
                                "reputation": 11067,
                                "user_id": 10808674,
                                "user_type": "registered",
                                "display_name": "Alain Merigot"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1548883250,
                            "post_id": 54428420,
                            "comment_id": 95708181,
                            "link": "https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python/54428420#comment95708181_54428420",
                            "body": "Neither VV not WW contains nan. VV as well as WW will become zero, thus epsilon will make the division computable and will give a zero as a result."
                        }
                    ],
                    "owner": {
                        "account_id": 15226101,
                        "reputation": 21,
                        "user_id": 10986701,
                        "user_type": "registered",
                        "display_name": "Christopher Grimm"
                    },
                    "comment_count": 2,
                    "is_accepted": false,
                    "score": 1,
                    "last_activity_date": 1548791282,
                    "last_edit_date": 1548791282,
                    "creation_date": 1548790345,
                    "answer_id": 54428420,
                    "question_id": 18697532,
                    "link": "https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python/54428420#54428420",
                    "body": "<p>How about replacing Z=VV/WW with Z=VV/(WW+epsilon) with epsilon=0.000001 to automatically handle the cases without any observations in the previous proposal</p>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 12857607,
                                "reputation": 1471,
                                "user_id": 9530017,
                                "user_type": "registered",
                                "display_name": "Liris"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1676900204,
                            "post_id": 61481246,
                            "comment_id": 133224761,
                            "link": "https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python/61481246#comment133224761_61481246",
                            "body": "Is this directly applicable to higher orders of the gaussian filter ? I tried it, and several artifacts appear on the borders."
                        }
                    ],
                    "owner": {
                        "account_id": 4662401,
                        "reputation": 10072,
                        "user_id": 7128154,
                        "user_type": "registered",
                        "accept_rate": 60,
                        "display_name": "Markus Dutschke"
                    },
                    "comment_count": 1,
                    "is_accepted": false,
                    "score": 11,
                    "last_activity_date": 1588080234,
                    "creation_date": 1588080234,
                    "answer_id": 61481246,
                    "question_id": 18697532,
                    "link": "https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python/61481246#61481246",
                    "body": "<p><a href=\"https://i.stack.imgur.com/Kq4sT.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/Kq4sT.png\" alt=\"enter image description here\"></a></p>\n\n<p>I stepped over this question a while ago and used <a href=\"https://stackoverflow.com/a/36307291/7128154\">davids answer</a> (thanks!).\nAs it turned out in the meantime, the task of applying a gaussian filter to a array with nans is not as well defined as I thought.</p>\n\n<p>As descibed in <a href=\"https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.gaussian_filter.html\" rel=\"noreferrer\">ndimage.gaussian_filter</a>, there are different options to process values at the border of the image (reflection, constant extrapolation, ...).\nA similar decision has to be made for the nan values in the image.</p>\n\n<ul>\n<li>Some idea might be, so linarly interpolate nan values, but the question arrises, what to do with nans at the image borders.</li>\n<li><code>filter_nan_gaussian_david</code>: Davids approach is equivalent to assuming some mean-neighborhood-value at each nan-point. This leads to a change in the total intensity (see <code>sum</code> value in colum 3), but does a great job otherwise.</li>\n<li><code>filter_nan_gaussian_conserving</code>: This approach is to spead the intesity of each point by a gaussian filter. The intensity, which is mapped to nan-pixels is reshifted back to the origin. If this maskes sense, depends on the application. I have a closed area surronded by nans and want to preseve the total intensity + avoid distortions at the boundaries.</li>\n<li><code>filter_nan_gaussian_conserving2</code>: Speads intesity of each point by a gaussian filter. The intensity, which is mapped to nan-pixels is redirected to the other pixels with the same Gaussian weighting. This leads to a relative reduction of the intensity at the origin in the vicinity of many nans / border pixels. This is illustrated in the last row very right.</li>\n</ul>\n\n<p><strong>Code</strong></p>\n\n<pre><code>import numpy as np\nfrom scipy import ndimage\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\ndef filter_nan_gaussian_conserving(arr, sigma):\n    \"\"\"Apply a gaussian filter to an array with nans.\n\n    Intensity is only shifted between not-nan pixels and is hence conserved.\n    The intensity redistribution with respect to each single point\n    is done by the weights of available pixels according\n    to a gaussian distribution.\n    All nans in arr, stay nans in gauss.\n    \"\"\"\n    nan_msk = np.isnan(arr)\n\n    loss = np.zeros(arr.shape)\n    loss[nan_msk] = 1\n    loss = ndimage.gaussian_filter(\n            loss, sigma=sigma, mode='constant', cval=1)\n\n    gauss = arr.copy()\n    gauss[nan_msk] = 0\n    gauss = ndimage.gaussian_filter(\n            gauss, sigma=sigma, mode='constant', cval=0)\n    gauss[nan_msk] = np.nan\n\n    gauss += loss * arr\n\n    return gauss\n\ndef filter_nan_gaussian_conserving2(arr, sigma):\n    \"\"\"Apply a gaussian filter to an array with nans.\n\n    Intensity is only shifted between not-nan pixels and is hence conserved.\n    The intensity redistribution with respect to each single point\n    is done by the weights of available pixels according\n    to a gaussian distribution.\n    All nans in arr, stay nans in gauss.\n    \"\"\"\n    nan_msk = np.isnan(arr)\n\n    loss = np.zeros(arr.shape)\n    loss[nan_msk] = 1\n    loss = ndimage.gaussian_filter(\n            loss, sigma=sigma, mode='constant', cval=1)\n\n    gauss = arr / (1-loss)\n    gauss[nan_msk] = 0\n    gauss = ndimage.gaussian_filter(\n            gauss, sigma=sigma, mode='constant', cval=0)\n    gauss[nan_msk] = np.nan\n\n    return gauss\n\ndef filter_nan_gaussian_david(arr, sigma):\n    \"\"\"Allows intensity to leak into the nan area.\n    According to Davids answer:\n        https://stackoverflow.com/a/36307291/7128154\n    \"\"\"\n    gauss = arr.copy()\n    gauss[np.isnan(gauss)] = 0\n    gauss = ndimage.gaussian_filter(\n            gauss, sigma=sigma, mode='constant', cval=0)\n\n    norm = np.ones(shape=arr.shape)\n    norm[np.isnan(arr)] = 0\n    norm = ndimage.gaussian_filter(\n            norm, sigma=sigma, mode='constant', cval=0)\n\n    # avoid RuntimeWarning: invalid value encountered in true_divide\n    norm = np.where(norm==0, 1, norm)\n    gauss = gauss/norm\n    gauss[np.isnan(arr)] = np.nan\n    return gauss\n\n\n\nfig, axs = plt.subplots(3, 4)\nfig.suptitle('black: 0, white: 1, red: nan')\ncmap = mpl.cm.get_cmap('gist_yarg_r')\ncmap.set_bad('r')\ndef plot_info(ax, arr, col):\n    kws = dict(cmap=cmap, vmin=0, vmax=1)\n    if col == 0:\n        title = 'input'\n    elif col == 1:\n        title = 'filter_nan_gaussian_conserving'\n    elif col == 2:\n        title = 'filter_nan_gaussian_david'\n    elif col == 3:\n        title = 'filter_nan_gaussian_conserving2'\n    ax.set_title(title + '\\nsum: {:.4f}'.format(np.nansum(arr)))\n    ax.imshow(arr, **kws)\n\nsigma = (1,1)\n\narr0 = np.zeros(shape=(6, 10))\narr0[2:, :] = np.nan\narr0[2, 1:3] = 1\n\narr1 = np.zeros(shape=(6, 10))\narr1[2, 1:3] = 1\narr1[3, 2] = np.nan\n\narr2 = np.ones(shape=(6, 10)) *.5\narr2[3, 2] = np.nan\n\nplot_info(axs[0, 0], arr0, 0)\nplot_info(axs[0, 1], filter_nan_gaussian_conserving(arr0, sigma), 1)\nplot_info(axs[0, 2], filter_nan_gaussian_david(arr0, sigma), 2)\nplot_info(axs[0, 3], filter_nan_gaussian_conserving2(arr0, sigma), 3)\n\nplot_info(axs[1, 0], arr1, 0)\nplot_info(axs[1, 1], filter_nan_gaussian_conserving(arr1, sigma), 1)\nplot_info(axs[1, 2], filter_nan_gaussian_david(arr1, sigma), 2)\nplot_info(axs[1, 3], filter_nan_gaussian_conserving2(arr1, sigma), 3)\n\nplot_info(axs[2, 0], arr2, 0)\nplot_info(axs[2, 1], filter_nan_gaussian_conserving(arr2, sigma), 1)\nplot_info(axs[2, 2], filter_nan_gaussian_david(arr2, sigma), 2)\nplot_info(axs[2, 3], filter_nan_gaussian_conserving2(arr2, sigma), 3)\n\nplt.show()\n</code></pre>\n"
                }
            ],
            "owner": {
                "account_id": 3280515,
                "reputation": 339,
                "user_id": 2761243,
                "user_type": "registered",
                "display_name": "user2761243"
            },
            "comment_count": 7,
            "is_answered": true,
            "answer_count": 3,
            "score": 33,
            "last_activity_date": 1588080234,
            "creation_date": 1378727206,
            "last_edit_date": 1518054747,
            "question_id": 18697532,
            "link": "https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python",
            "title": "Gaussian filtering a image with Nan in Python",
            "body": "<p>From a list of 2D coordinates, and a third variable (velocity), I have created a 2D numpy array covering the whole sampled area. My intention is to create an image, in which each pixel contains the mean velocity of the points lying within it. After that filter that image with a gaussian filter.</p>\n\n<p>The problem is that the area is not uniformly sampled. Therefore I have several pixels without information (<code>Nan</code>) in the middle of the image. When I try to filter the array through a gaussian filter, the <code>Nan</code> propagate ruining the whole image.</p>\n\n<p>I need to filter this image, but rejecting all pixels without information. In other words, If a pixel does not contain information, then it should be not taken into account for the filtering.</p>\n\n<p>Here is an example of my code for averaging:</p>\n\n<pre><code>Mean_V = np.zeros([len(x_bins), len(y_bins)])\n\nfor i, x_bin in enumerate(x_bins[:-1]):\n    bin_x = (x &gt; x_bins[i]) &amp; (x &lt;= x_bins[i+1])\n    for j, y_bin in enumerate(y_bins[:-1]):\n        bin_xy = (y[bin_x] &gt; y_bins[j]) &amp; (y[bin_x] &lt;= y_bins[j+1])\n        if (sum(x &gt; 0 for x in bin_xy) &gt; 0) :\n            Mean_V[i,j]=np.mean(V[bin_x][bin_xy])\n        else:\n            Mean_V[i,j]=np.nan\n</code></pre>\n\n<p>EDIT:</p>\n\n<p>Surfing the web I have ended into this question I made in 2013. The solution to this problem can be found in the astropy library:</p>\n\n<p><a href=\"http://docs.astropy.org/en/stable/convolution/\" rel=\"noreferrer\">http://docs.astropy.org/en/stable/convolution/</a></p>\n\n<p>Astropy's convolution replaces the NaN pixels with a kernel-weighted interpolation from their neighbors.</p>\n\n<p>Thanks folks!!</p>\n"
        }
    ],
    "has_more": false,
    "quota_max": 10000,
    "quota_remaining": 7500
}