{
    "items": [
        {
            "tags": [
                "python",
                "class",
                "constructor",
                "initialization"
            ],
            "comments": [
                {
                    "owner": {
                        "account_id": 181901,
                        "reputation": 25760,
                        "user_id": 416224,
                        "user_type": "registered",
                        "accept_rate": 96,
                        "display_name": "Kijewski"
                    },
                    "edited": false,
                    "score": 1,
                    "creation_date": 1383261745,
                    "post_id": 2168964,
                    "comment_id": 29293862,
                    "link": "https://stackoverflow.com/questions/2168964/how-to-create-a-class-instance-without-calling-initializer#comment29293862_2168964",
                    "body": "possible duplicate of <a href=\"http://stackoverflow.com/questions/6383914/is-there-a-way-to-instantiate-a-class-without-calling-init\">Is there a way to instantiate a class without calling __init__?</a>"
                }
            ],
            "answers": [
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 75420,
                                "reputation": 21753,
                                "user_id": 216356,
                                "user_type": "registered",
                                "accept_rate": 93,
                                "display_name": "Noctis Skytower"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1264877985,
                            "post_id": 2169007,
                            "comment_id": 2114389,
                            "link": "https://stackoverflow.com/questions/2168964/how-to-create-a-class-instance-without-calling-initializer/2169007#comment2114389_2169007",
                            "body": "I liked your first answer better. Considering <code>str() == &#39;&#39;</code>, I think that I will change the code to <code>def __init__(self, string=&#39;&#39;):</code>. Thanks for your help and thoughts! I was hoping to avoid <code>__init__</code> altogether, but calling <code>String()</code> with the change mentioned should not be a very expensive operation at all. That seems to be the best solution at this time."
                        },
                        {
                            "owner": {
                                "account_id": 8198,
                                "reputation": 178922,
                                "user_id": 14637,
                                "user_type": "registered",
                                "accept_rate": 88,
                                "display_name": "Thomas"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1264878185,
                            "post_id": 2169007,
                            "comment_id": 2114404,
                            "link": "https://stackoverflow.com/questions/2168964/how-to-create-a-class-instance-without-calling-initializer/2169007#comment2114404_2169007",
                            "body": "Sorry, I thought that my first answer didn&#39;t really address the question :) There seems to be no way I can get it back...?"
                        }
                    ],
                    "owner": {
                        "account_id": 8198,
                        "reputation": 178922,
                        "user_id": 14637,
                        "user_type": "registered",
                        "accept_rate": 88,
                        "display_name": "Thomas"
                    },
                    "comment_count": 2,
                    "is_accepted": false,
                    "score": 0,
                    "last_activity_date": 1264877601,
                    "creation_date": 1264877601,
                    "answer_id": 2169007,
                    "question_id": 2168964,
                    "link": "https://stackoverflow.com/questions/2168964/how-to-create-a-class-instance-without-calling-initializer/2169007#2169007",
                    "body": "<p>Pass another argument to the constructor, like so:</p>\n\n<pre><code>def __init__(self, string, simple = None):\n    if simple is None:\n        self.__string = tuple(string.split())\n        self.__simple = tuple(self.__simple())\n    else:\n        self.__string = string\n        self.__simple = simple\n</code></pre>\n\n<p>You can then call it like this:</p>\n\n<pre><code>def __getitem__(self, key):\n    assert isinstance(key, slice)\n    return String(self.__string[key], self.__simple[key])\n</code></pre>\n\n<p>Also, I'm not sure it's allowed to name both the field and the method <code>__simple</code>. If only for readability, you should change that.</p>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 75420,
                                "reputation": 21753,
                                "user_id": 216356,
                                "user_type": "registered",
                                "accept_rate": 93,
                                "display_name": "Noctis Skytower"
                            },
                            "edited": false,
                            "score": 9,
                            "creation_date": 1264886330,
                            "post_id": 2169191,
                            "comment_id": 2114945,
                            "link": "https://stackoverflow.com/questions/2168964/how-to-create-a-class-instance-without-calling-initializer/2169191#comment2114945_2169191",
                            "body": "How would you rewrite this for Python 3.1?"
                        },
                        {
                            "owner": {
                                "account_id": 103460,
                                "reputation": 8247,
                                "user_id": 277113,
                                "user_type": "registered",
                                "accept_rate": 53,
                                "display_name": "gozzilli"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1498670907,
                            "post_id": 2169191,
                            "comment_id": 76598252,
                            "link": "https://stackoverflow.com/questions/2168964/how-to-create-a-class-instance-without-calling-initializer/2169191#comment76598252_2169191",
                            "body": "If String was a subclass, how would you call the superclass&#39; constructor?"
                        },
                        {
                            "owner": {
                                "account_id": 103460,
                                "reputation": 8247,
                                "user_id": 277113,
                                "user_type": "registered",
                                "accept_rate": 53,
                                "display_name": "gozzilli"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1498671152,
                            "post_id": 2169191,
                            "comment_id": 76598417,
                            "link": "https://stackoverflow.com/questions/2168964/how-to-create-a-class-instance-without-calling-initializer/2169191#comment76598417_2169191",
                            "body": "Oh I found it, you would do <code>SuperClass.__init__(self)</code> after creating <code>self</code>."
                        },
                        {
                            "owner": {
                                "account_id": 73951,
                                "reputation": 8283,
                                "user_id": 212731,
                                "user_type": "registered",
                                "accept_rate": 73,
                                "display_name": "Hugh Perkins"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1638881219,
                            "post_id": 2169191,
                            "comment_id": 124200636,
                            "link": "https://stackoverflow.com/questions/2168964/how-to-create-a-class-instance-without-calling-initializer/2169191#comment124200636_2169191",
                            "body": "wow, I&#39;ve been using python for years/decades, and only just found this. been looking for this for &quot;a while&quot; :)"
                        }
                    ],
                    "owner": {
                        "account_id": 34048,
                        "reputation": 869830,
                        "user_id": 95810,
                        "user_type": "registered",
                        "accept_rate": 80,
                        "display_name": "Alex Martelli"
                    },
                    "comment_count": 4,
                    "is_accepted": false,
                    "score": 63,
                    "last_activity_date": 1264880812,
                    "creation_date": 1264880812,
                    "answer_id": 2169191,
                    "question_id": 2168964,
                    "link": "https://stackoverflow.com/questions/2168964/how-to-create-a-class-instance-without-calling-initializer/2169191#2169191",
                    "body": "<p>When feasible, letting <code>__init__</code> get called (and make the call innocuous by suitable arguments) is preferable.  However, should that require too much of a contortion, you do have an alternative, as long as you avoid the disastrous choice of using old-style classes (there is <strong>no</strong> good reason to use old-style classes in new code, and several good reasons <strong>not</strong> to)...:</p>\n\n<pre><code>   class String(object):\n      ...\n\n   bare_s = String.__new__(String)\n</code></pre>\n\n<p>This idiom is generally used in <code>classmethod</code>s which are meant to work as \"alternative constructors\", so you'll usually see it used in ways such as...:</p>\n\n<pre><code>@classmethod \ndef makeit(cls):\n    self = cls.__new__(cls)\n    # etc etc, then\n    return self\n</code></pre>\n\n<p>(this way the classmethod will properly be inherited and generate subclass instances when called on a subclass rather than on the base class).</p>\n"
                },
                {
                    "owner": {
                        "account_id": 89800,
                        "reputation": 63305,
                        "user_id": 247542,
                        "user_type": "registered",
                        "accept_rate": 59,
                        "display_name": "Cerin"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 14,
                    "last_activity_date": 1360110137,
                    "creation_date": 1360110137,
                    "answer_id": 14719469,
                    "question_id": 2168964,
                    "link": "https://stackoverflow.com/questions/2168964/how-to-create-a-class-instance-without-calling-initializer/14719469#14719469",
                    "body": "<p>A trick the standard pickle and copy modules use is to create an empty class, instantiate the object using that, and then assign that instance's <code>__class__</code> to the \"real\" class. e.g.</p>\n\n<pre><code>&gt;&gt;&gt; class MyClass(object):\n...     init = False\n...     def __init__(self):\n...         print 'init called!'\n...         self.init = True\n...     def hello(self):\n...         print 'hello world!'\n... \n&gt;&gt;&gt; class Empty(object):\n...     pass\n... \n&gt;&gt;&gt; a = MyClass()\ninit called!\n&gt;&gt;&gt; a.hello()\nhello world!\n&gt;&gt;&gt; print a.init\nTrue\n&gt;&gt;&gt; b = Empty()\n&gt;&gt;&gt; b.__class__ = MyClass\n&gt;&gt;&gt; b.hello()\nhello world!\n&gt;&gt;&gt; print b.init\nFalse\n</code></pre>\n\n<p>But note, this approach is very rarely necessary. Bypassing the <code>__init__</code> can have some unexpected side effects, especially if you're not familiar with the original class, so make sure you know what you're doing.</p>\n"
                },
                {
                    "owner": {
                        "account_id": 75420,
                        "reputation": 21753,
                        "user_id": 216356,
                        "user_type": "registered",
                        "accept_rate": 93,
                        "display_name": "Noctis Skytower"
                    },
                    "comment_count": 0,
                    "is_accepted": true,
                    "score": 2,
                    "last_activity_date": 1559329265,
                    "last_edit_date": 1559329265,
                    "creation_date": 1360182617,
                    "answer_id": 14738204,
                    "question_id": 2168964,
                    "link": "https://stackoverflow.com/questions/2168964/how-to-create-a-class-instance-without-calling-initializer/14738204#14738204",
                    "body": "<p>Using a metaclass provides a nice solution in this example. The metaclass has limited use but works fine.</p>\n\n<pre><code>&gt;&gt;&gt; class MetaInit(type):\n\n    def __call__(cls, *args, **kwargs):\n        if args or kwargs:\n            return super().__call__(*args, **kwargs)\n        return cls.__new__(cls)\n\n&gt;&gt;&gt; class String(metaclass=MetaInit):\n\n    def __init__(self, string):\n        self.__string = tuple(string.split())\n        self.__simple = tuple(self.__simple())\n\n    def __simple(self):\n        letter = lambda s: ''.join(filter(lambda s: 'a' &lt;= s &lt;= 'z', s))\n        return filter(bool, map(letter, map(str.lower, self.__string)))\n\n    def __eq__(self, other):\n        assert isinstance(other, String)\n        return self.__simple == other.__simple\n\n    def __getitem__(self, key):\n        assert isinstance(key, slice)\n        string = String()\n        string.__string = self.__string[key]\n        string.__simple = self.__simple[key]\n        return string\n\n    def __iter__(self):\n        return iter(self.__string)\n\n&gt;&gt;&gt; String('Hello, world!')[1:]\n&lt;__main__.String object at 0x02E78830&gt;\n&gt;&gt;&gt; _._String__string, _._String__simple\n(('world!',), ('world',))\n&gt;&gt;&gt; \n</code></pre>\n\n<p><strong>Addendum:</strong></p>\n\n<p>After six years, my opinion favors <a href=\"https://stackoverflow.com/a/2169191/216356\">Alex Martelli's answer</a> more than my own approach. With meta-classes still on the mind, the following answer shows how the problem can be solved both with and without them:</p>\n\n<pre><code>#! /usr/bin/env python3\nMETHOD = 'metaclass'\n\n\nclass NoInitMeta(type):\n    def new(cls):\n        return cls.__new__(cls)\n\n\nclass String(metaclass=NoInitMeta if METHOD == 'metaclass' else type):\n    def __init__(self, value):\n        self.__value = tuple(value.split())\n        self.__alpha = tuple(filter(None, (\n            ''.join(c for c in word.casefold() if 'a' &lt;= c &lt;= 'z') for word in\n            self.__value)))\n\n    def __str__(self):\n        return ' '.join(self.__value)\n\n    def __eq__(self, other):\n        if not isinstance(other, type(self)):\n            return NotImplemented\n        return self.__alpha == other.__alpha\n\n    if METHOD == 'metaclass':\n        def __getitem__(self, key):\n            if not isinstance(key, slice):\n                raise NotImplementedError\n            instance = type(self).new()\n            instance.__value = self.__value[key]\n            instance.__alpha = self.__alpha[key]\n            return instance\n    elif METHOD == 'classmethod':\n        def __getitem__(self, key):\n            if not isinstance(key, slice):\n                raise NotImplementedError\n            instance = self.new()\n            instance.__value = self.__value[key]\n            instance.__alpha = self.__alpha[key]\n            return instance\n\n        @classmethod\n        def new(cls):\n            return cls.__new__(cls)\n    elif METHOD == 'inline':\n        def __getitem__(self, key):\n            if not isinstance(key, slice):\n                raise NotImplementedError\n            cls = type(self)\n            instance = cls.__new__(cls)\n            instance.__value = self.__value[key]\n            instance.__alpha = self.__alpha[key]\n            return instance\n    else:\n        raise ValueError('METHOD did not have an appropriate value')\n\n    def __iter__(self):\n        return iter(self.__value)\n\n\ndef main():\n    x = String('Hello, world!')\n    y = x[1:]\n    print(y)\n\n\nif __name__ == '__main__':\n    main()\n</code></pre>\n"
                }
            ],
            "owner": {
                "account_id": 75420,
                "reputation": 21753,
                "user_id": 216356,
                "user_type": "registered",
                "accept_rate": 93,
                "display_name": "Noctis Skytower"
            },
            "comment_count": 1,
            "is_answered": true,
            "accepted_answer_id": 14738204,
            "answer_count": 4,
            "score": 45,
            "last_activity_date": 1582588019,
            "creation_date": 1264876897,
            "last_edit_date": 1582588019,
            "question_id": 2168964,
            "link": "https://stackoverflow.com/questions/2168964/how-to-create-a-class-instance-without-calling-initializer",
            "title": "How to create a class instance without calling initializer?",
            "body": "<p>Is there any way to avoid calling <code>__init__</code> on a class while initializing it, such as from a class method?</p>\n\n<p>I am trying to create a case and punctuation insensitive string class in Python used for efficient comparison purposes but am having trouble creating a new instance without calling <code>__init__</code>.</p>\n\n<pre><code>&gt;&gt;&gt; class String:\n\n    def __init__(self, string):\n        self.__string = tuple(string.split())\n        self.__simple = tuple(self.__simple())\n\n    def __simple(self):\n        letter = lambda s: ''.join(filter(lambda s: 'a' &lt;= s &lt;= 'z', s))\n        return filter(bool, map(letter, map(str.lower, self.__string)))\n\n    def __eq__(self, other):\n        assert isinstance(other, String)\n        return self.__simple == other.__simple\n\n    def __getitem__(self, key):\n        assert isinstance(key, slice)\n        string = String()\n        string.__string = self.__string[key]\n        string.__simple = self.__simple[key]\n        return string\n\n    def __iter__(self):\n        return iter(self.__string)\n\n&gt;&gt;&gt; String('Hello, world!')[1:]\nTraceback (most recent call last):\n  File \"&lt;pyshell#2&gt;\", line 1, in &lt;module&gt;\n    String('Hello, world!')[1:]\n  File \"&lt;pyshell#1&gt;\", line 17, in __getitem__\n    string = String()\nTypeError: __init__() takes exactly 2 positional arguments (1 given)\n&gt;&gt;&gt; \n</code></pre>\n\n<p>What should I replace <code>string = String();  string.__string = self.__string[key]; string.__simple = self.__simple[key]</code> with to initialize the new object with the slices?</p>\n\n<p><strong>EDIT:</strong></p>\n\n<p>As inspired by the answer written below, the initializer has been edited to quickly check for no arguments.</p>\n\n<pre><code>def __init__(self, string=None):\n    if string is None:\n        self.__string = self.__simple = ()\n    else:\n        self.__string = tuple(string.split())\n        self.__simple = tuple(self.__simple())\n</code></pre>\n"
        }
    ],
    "has_more": false,
    "quota_max": 10000,
    "quota_remaining": 6015
}