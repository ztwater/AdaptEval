{
    "items": [
        {
            "tags": [
                "python",
                "matlab",
                "numpy",
                "scipy"
            ],
            "comments": [
                {
                    "owner": {
                        "account_id": 963908,
                        "reputation": 6526,
                        "user_id": 987706,
                        "user_type": "registered",
                        "accept_rate": 92,
                        "display_name": "The Oddler"
                    },
                    "edited": false,
                    "score": 1,
                    "creation_date": 1460656516,
                    "post_id": 18925181,
                    "comment_id": 60856469,
                    "link": "https://stackoverflow.com/questions/18925181/procrustes-analysis-with-numpy#comment60856469_18925181",
                    "body": "This is an old question, but for those looking for the same year later, there is now a method in SciPy: <a href=\"http://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.procrustes.html#scipy.spatial.procrustes\" rel=\"nofollow noreferrer\">docs.scipy.org/doc/scipy/reference/generated/&hellip;</a>"
                },
                {
                    "owner": {
                        "account_id": 1211489,
                        "reputation": 20913,
                        "user_id": 1179925,
                        "user_type": "registered",
                        "accept_rate": 47,
                        "display_name": "mrgloom"
                    },
                    "reply_to_user": {
                        "account_id": 963908,
                        "reputation": 6526,
                        "user_id": 987706,
                        "user_type": "registered",
                        "accept_rate": 92,
                        "display_name": "The Oddler"
                    },
                    "edited": false,
                    "score": 0,
                    "creation_date": 1537526794,
                    "post_id": 18925181,
                    "comment_id": 91826694,
                    "link": "https://stackoverflow.com/questions/18925181/procrustes-analysis-with-numpy#comment91826694_18925181",
                    "body": "@TheOddler It doesn&#39;t return transform matrix."
                }
            ],
            "answers": [
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 37807,
                                "reputation": 34585,
                                "user_id": 108184,
                                "user_type": "registered",
                                "display_name": "pv."
                            },
                            "edited": false,
                            "score": 2,
                            "creation_date": 1379766629,
                            "post_id": 18927641,
                            "comment_id": 27954878,
                            "link": "https://stackoverflow.com/questions/18925181/procrustes-analysis-with-numpy/18927641#comment27954878_18927641",
                            "body": "Remember that the code is owned by Mathworks, and just making a translation to a different language is likely not enough avoid their copyright, which your posting here may violate."
                        },
                        {
                            "owner": {
                                "account_id": 1574306,
                                "reputation": 73298,
                                "user_id": 1461210,
                                "user_type": "registered",
                                "accept_rate": 82,
                                "display_name": "ali_m"
                            },
                            "reply_to_user": {
                                "account_id": 37807,
                                "reputation": 34585,
                                "user_id": 108184,
                                "user_type": "registered",
                                "display_name": "pv."
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1379770299,
                            "post_id": 18927641,
                            "comment_id": 27955891,
                            "link": "https://stackoverflow.com/questions/18925181/procrustes-analysis-with-numpy/18927641#comment27955891_18927641",
                            "body": "@pv. Yep, fair point. I usually do this sort of thing for myself as a shortcut to understanding how the function works, rather than for general consumption. I&#39;ll remove my answer if there are any complaints."
                        },
                        {
                            "owner": {
                                "account_id": 1211489,
                                "reputation": 20913,
                                "user_id": 1179925,
                                "user_type": "registered",
                                "accept_rate": 47,
                                "display_name": "mrgloom"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1537208099,
                            "post_id": 18927641,
                            "comment_id": 91691847,
                            "link": "https://stackoverflow.com/questions/18925181/procrustes-analysis-with-numpy/18927641#comment91691847_18927641",
                            "body": "Can you elaborate what is <code>reflection component</code>?"
                        },
                        {
                            "owner": {
                                "account_id": 1550863,
                                "reputation": 422,
                                "user_id": 1443288,
                                "user_type": "registered",
                                "display_name": "Wacov"
                            },
                            "reply_to_user": {
                                "account_id": 1211489,
                                "reputation": 20913,
                                "user_id": 1179925,
                                "user_type": "registered",
                                "accept_rate": 47,
                                "display_name": "mrgloom"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1548817471,
                            "post_id": 18927641,
                            "comment_id": 95675146,
                            "link": "https://stackoverflow.com/questions/18925181/procrustes-analysis-with-numpy/18927641#comment95675146_18927641",
                            "body": "@mrgloom that&#39;s referring to whether or not the solution is permitted to contain a reflection. In layman&#39;s terms, whether or not the transformation is allowed to &quot;flip&quot; or &quot;mirror&quot; the data in addition to rotating it."
                        },
                        {
                            "owner": {
                                "account_id": 2851256,
                                "reputation": 996,
                                "user_id": 3007075,
                                "user_type": "registered",
                                "display_name": "Mefitico"
                            },
                            "reply_to_user": {
                                "account_id": 37807,
                                "reputation": 34585,
                                "user_id": 108184,
                                "user_type": "registered",
                                "display_name": "pv."
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1554906538,
                            "post_id": 18927641,
                            "comment_id": 97923722,
                            "link": "https://stackoverflow.com/questions/18925181/procrustes-analysis-with-numpy/18927641#comment97923722_18927641",
                            "body": "@pv: I dont mean  to start a chat, but... Wouldn&#39;t that depend on the country? Also,  Matlab functions often provide literature references which one could have read and implemented instead of adapting Mathwork&#39;s code. Where should we expect judges and court to draw the line between a code being in public domain (since its available in text and equations in a paper) and it being copyright-able (as some Matlab functions might be)."
                        },
                        {
                            "owner": {
                                "account_id": 6490911,
                                "reputation": 32569,
                                "user_id": 5025009,
                                "user_type": "registered",
                                "display_name": "seralouk"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1563184039,
                            "post_id": 18927641,
                            "comment_id": 100602367,
                            "link": "https://stackoverflow.com/questions/18925181/procrustes-analysis-with-numpy/18927641#comment100602367_18927641",
                            "body": "If I have 2 sets of eigenvectors (<code>a</code>,<code>b</code>) with dimensionality 2000 and I want to apply procrustes to see how similar they are using <code>procrustes(a, b)</code>, then how should I store <code>a,b</code>? If I have 10 eigenvectors for <code>a</code> and 10 eigenvectors for <code>b</code>, should <code>a</code> and <code>b</code> be [2000,10] or [10,2000] ? The code uses A&#39;B so I guess [2000,10] is the correct way ?"
                        },
                        {
                            "owner": {
                                "account_id": 1074365,
                                "reputation": 4385,
                                "user_id": 1072825,
                                "user_type": "registered",
                                "accept_rate": 100,
                                "display_name": "Pavan K"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1571738617,
                            "post_id": 18927641,
                            "comment_id": 103332269,
                            "link": "https://stackoverflow.com/questions/18925181/procrustes-analysis-with-numpy/18927641#comment103332269_18927641",
                            "body": "Just a quick comment -&gt; tform is a dict specifying the rotation, translation and scaling that maps Y --&gt; Z. Y is being fit to X here and not the other way around if I am not mistaken"
                        },
                        {
                            "owner": {
                                "account_id": 2005572,
                                "reputation": 1131,
                                "user_id": 1795570,
                                "user_type": "registered",
                                "accept_rate": 73,
                                "display_name": "Joe Jankowiak"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1690837098,
                            "post_id": 18927641,
                            "comment_id": 135406004,
                            "link": "https://stackoverflow.com/questions/18925181/procrustes-analysis-with-numpy/18927641#comment135406004_18927641",
                            "body": "I&#39;m trying to run this, but get an error with the line X0**2. since X0 is not a square matrix.  I could get it to run converting it to an array first, but is that mathematically correct? (np.array(X0)**2).sum()"
                        },
                        {
                            "owner": {
                                "account_id": 2005572,
                                "reputation": 1131,
                                "user_id": 1795570,
                                "user_type": "registered",
                                "accept_rate": 73,
                                "display_name": "Joe Jankowiak"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1690898602,
                            "post_id": 18927641,
                            "comment_id": 135415328,
                            "link": "https://stackoverflow.com/questions/18925181/procrustes-analysis-with-numpy/18927641#comment135415328_18927641",
                            "body": "I found that the ssX and ssY variables are trying to do elementwise powering, not matrix power. I changed it to (np.array(X0)**2).sum() which works when a numpy matrix is passed in"
                        },
                        {
                            "owner": {
                                "account_id": 991116,
                                "reputation": 2737,
                                "user_id": 1008405,
                                "user_type": "registered",
                                "accept_rate": 75,
                                "display_name": "euraad"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1701903753,
                            "post_id": 18927641,
                            "comment_id": 136834194,
                            "link": "https://stackoverflow.com/questions/18925181/procrustes-analysis-with-numpy/18927641#comment136834194_18927641",
                            "body": "The code does not work properly."
                        }
                    ],
                    "owner": {
                        "account_id": 1574306,
                        "reputation": 73298,
                        "user_id": 1461210,
                        "user_type": "registered",
                        "accept_rate": 82,
                        "display_name": "ali_m"
                    },
                    "comment_count": 10,
                    "is_accepted": true,
                    "score": 31,
                    "last_activity_date": 1611863937,
                    "last_edit_date": 1611863937,
                    "creation_date": 1379722914,
                    "answer_id": 18927641,
                    "question_id": 18925181,
                    "link": "https://stackoverflow.com/questions/18925181/procrustes-analysis-with-numpy/18927641#18927641",
                    "body": "<p>I'm not aware of any pre-existing implementation in Python, but it's easy to take a look at the MATLAB code using <code>edit procrustes.m</code> and port it to Numpy:</p>\n<pre><code>def procrustes(X, Y, scaling=True, reflection='best'):\n    &quot;&quot;&quot;\n    A port of MATLAB's `procrustes` function to Numpy.\n\n    Procrustes analysis determines a linear transformation (translation,\n    reflection, orthogonal rotation and scaling) of the points in Y to best\n    conform them to the points in matrix X, using the sum of squared errors\n    as the goodness of fit criterion.\n\n        d, Z, [tform] = procrustes(X, Y)\n\n    Inputs:\n    ------------\n    X, Y    \n        matrices of target and input coordinates. they must have equal\n        numbers of  points (rows), but Y may have fewer dimensions\n        (columns) than X.\n\n    scaling \n        if False, the scaling component of the transformation is forced\n        to 1\n\n    reflection\n        if 'best' (default), the transformation solution may or may not\n        include a reflection component, depending on which fits the data\n        best. setting reflection to True or False forces a solution with\n        reflection or no reflection respectively.\n\n    Outputs\n    ------------\n    d       \n        the residual sum of squared errors, normalized according to a\n        measure of the scale of X, ((X - X.mean(0))**2).sum()\n\n    Z\n        the matrix of transformed Y-values\n\n    tform   \n        a dict specifying the rotation, translation and scaling that\n        maps X --&gt; Y\n\n    &quot;&quot;&quot;\n\n    n,m = X.shape\n    ny,my = Y.shape\n\n    muX = X.mean(0)\n    muY = Y.mean(0)\n\n    X0 = X - muX\n    Y0 = Y - muY\n\n    ssX = (X0**2.).sum()\n    ssY = (Y0**2.).sum()\n\n    # centred Frobenius norm\n    normX = np.sqrt(ssX)\n    normY = np.sqrt(ssY)\n\n    # scale to equal (unit) norm\n    X0 /= normX\n    Y0 /= normY\n\n    if my &lt; m:\n        Y0 = np.concatenate((Y0, np.zeros(n, m-my)),0)\n\n    # optimum rotation matrix of Y\n    A = np.dot(X0.T, Y0)\n    U,s,Vt = np.linalg.svd(A,full_matrices=False)\n    V = Vt.T\n    T = np.dot(V, U.T)\n\n    if reflection != 'best':\n\n        # does the current solution use a reflection?\n        have_reflection = np.linalg.det(T) &lt; 0\n\n        # if that's not what was specified, force another reflection\n        if reflection != have_reflection:\n            V[:,-1] *= -1\n            s[-1] *= -1\n            T = np.dot(V, U.T)\n\n    traceTA = s.sum()\n\n    if scaling:\n\n        # optimum scaling of Y\n        b = traceTA * normX / normY\n\n        # standarised distance between X and b*Y*T + c\n        d = 1 - traceTA**2\n\n        # transformed coords\n        Z = normX*traceTA*np.dot(Y0, T) + muX\n\n    else:\n        b = 1\n        d = 1 + ssY/ssX - 2 * traceTA * normY / normX\n        Z = normY*np.dot(Y0, T) + muX\n\n    # transformation matrix\n    if my &lt; m:\n        T = T[:my,:]\n    c = muX - b*np.dot(muY, T)\n    \n    #transformation values \n    tform = {'rotation':T, 'scale':b, 'translation':c}\n   \n    return d, Z, tform\n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 5687012,
                        "reputation": 561,
                        "user_id": 4496223,
                        "user_type": "registered",
                        "accept_rate": 0,
                        "display_name": "Zewei Song"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 17,
                    "last_activity_date": 1490672313,
                    "last_edit_date": 1490672313,
                    "creation_date": 1490671698,
                    "answer_id": 43060155,
                    "question_id": 18925181,
                    "link": "https://stackoverflow.com/questions/18925181/procrustes-analysis-with-numpy/43060155#43060155",
                    "body": "<p>There is a Scipy function for it: <a href=\"https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.procrustes.html\" rel=\"noreferrer\"><code>scipy.spatial.procrustes</code></a></p>\n\n<p>I'm just posting its example here:</p>\n\n<pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from scipy.spatial import procrustes\n\n&gt;&gt;&gt; a = np.array([[1, 3], [1, 2], [1, 1], [2, 1]], 'd')\n&gt;&gt;&gt; b = np.array([[4, -2], [4, -4], [4, -6], [2, -6]], 'd')\n&gt;&gt;&gt; mtx1, mtx2, disparity = procrustes(a, b)\n&gt;&gt;&gt; round(disparity)\n0.0\n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 20477305,
                        "reputation": 123,
                        "user_id": 15026325,
                        "user_type": "registered",
                        "display_name": "Franc Jerez"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 0,
                    "last_activity_date": 1611609333,
                    "last_edit_date": 1611609333,
                    "creation_date": 1611589853,
                    "answer_id": 65888033,
                    "question_id": 18925181,
                    "link": "https://stackoverflow.com/questions/18925181/procrustes-analysis-with-numpy/65888033#65888033",
                    "body": "<p>You can have both <em>Ordinary Procrustes Analysis</em> and <em>Generalized Procrustes Analysis</em> in <code>python</code> with something like this:</p>\n<pre><code>import numpy as np\n        \ndef opa(a, b):\n    aT = a.mean(0)\n    bT = b.mean(0)\n    A = a - aT \n    B = b - bT\n    aS = np.sum(A * A)**.5\n    bS = np.sum(B * B)**.5\n    A /= aS\n    B /= bS\n    U, _, V = np.linalg.svd(np.dot(B.T, A))\n    aR = np.dot(U, V)\n    if np.linalg.det(aR) &lt; 0:\n        V[1] *= -1\n        aR = np.dot(U, V)\n    aS = aS / bS\n    aT-= (bT.dot(aR) * aS)\n    aD = (np.sum((A - B.dot(aR))**2) / len(a))**.5\n    return aR, aS, aT, aD \n        \ndef gpa(v, n=-1):\n    if n &lt; 0:\n        p = avg(v)\n    else:\n        p = v[n]\n    l = len(v)\n    r, s, t, d = np.ndarray((4, l), object)\n    for i in range(l):\n        r[i], s[i], t[i], d[i] = opa(p, v[i]) \n    return r, s, t, d\n\ndef avg(v):\n    v_= np.copy(v)\n    l = len(v_) \n    R, S, T = [list(np.zeros(l)) for _ in range(3)]\n    for i, j in np.ndindex(l, l):\n        r, s, t, _ = opa(v_[i], v_[j]) \n        R[j] += np.arccos(min(1, max(-1, np.trace(r[:1])))) * np.sign(r[1][0]) \n        S[j] += s \n        T[j] += t \n    for i in range(l):\n        a = R[i] / l\n        r = [np.cos(a), -np.sin(a)], [np.sin(a), np.cos(a)]\n        v_[i] = v_[i].dot(r) * (S[i] / l) + (T[i] / l) \n    return v_.mean(0)\n</code></pre>\n<p>For testing purposes, the output of each algorithm can be visualized as follows:</p>\n<pre><code>import matplotlib.pyplot as p; p.rcParams['toolbar'] = 'None';\n\ndef plt(o, e, b):\n    p.figure(figsize=(10, 10), dpi=72, facecolor='w').add_axes([0.05, 0.05, 0.9, 0.9], aspect='equal')\n    p.plot(0, 0, marker='x', mew=1, ms=10, c='g', zorder=2, clip_on=False)\n    p.gcf().canvas.set_window_title('%f' % e)\n    x = np.ravel(o[0].T[0])\n    y = np.ravel(o[0].T[1])\n    p.xlim(min(x), max(x)) \n    p.ylim(min(y), max(y))\n    a = []\n    for i, j in np.ndindex(len(o), 2):\n        a.append(o[i].T[j])    \n    O = p.plot(*a, marker='x', mew=1, ms=10, lw=.25, c='b', zorder=0, clip_on=False)\n    O[0].set(c='r', zorder=1)\n    if not b:\n        O[2].set_color('b')\n        O[2].set_alpha(0.4)\n    p.axis('off')     \n    p.show()\n\n# Fly wings example (Klingenberg, 2015 | https://en.wikipedia.org/wiki/Procrustes_analysis)\narr1 = np.array([[588.0, 443.0], [178.0, 443.0], [56.0, 436.0], [50.0, 376.0], [129.0, 360.0], [15.0, 342.0], [92.0, 293.0], [79.0, 269.0], [276.0, 295.0], [281.0, 331.0], [785.0, 260.0], [754.0, 174.0], [405.0, 233.0], [386.0, 167.0], [466.0, 59.0]])\narr2 = np.array([[477.0, 557.0], [130.129, 374.307], [52.0, 334.0], [67.662, 306.953], [111.916, 323.0], [55.119, 275.854], [107.935, 277.723], [101.899, 259.73], [175.0, 329.0], [171.0, 345.0], [589.0, 527.0], [591.0, 468.0], [299.0, 363.0], [306.0, 317.0], [406.0, 288.0]])\n\ndef opa_out(a):\n    r, s, t, d = opa(a[0], a[1])\n    a[1] = a[1].dot(r) * s + t\n    return a, d, False\nplt(*opa_out([arr1, arr2, np.matrix.copy(arr2)]))\n\ndef gpa_out(a):\n    g = gpa(a, -1) \n    D = [avg(a)]\n    for i in range(len(a)):\n        D.append(a[i].dot(g[0][i]) * g[1][i] + g[2][i])\n    return D, sum(g[3])/len(a), True \nplt(*gpa_out([arr1, arr2]))\n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 12981447,
                        "reputation": 138,
                        "user_id": 10227505,
                        "user_type": "registered",
                        "display_name": "Snoopy"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 0,
                    "last_activity_date": 1618265782,
                    "creation_date": 1618265782,
                    "answer_id": 67066363,
                    "question_id": 18925181,
                    "link": "https://stackoverflow.com/questions/18925181/procrustes-analysis-with-numpy/67066363#67066363",
                    "body": "<p>Probably you want to try this package with various flavors of different Procrustes methods, <a href=\"https://github.com/theochem/procrustes\" rel=\"nofollow noreferrer\">https://github.com/theochem/procrustes</a>.</p>\n"
                }
            ],
            "owner": {
                "account_id": 151783,
                "reputation": 28062,
                "user_id": 365872,
                "user_type": "registered",
                "accept_rate": 91,
                "display_name": "ffriend"
            },
            "comment_count": 2,
            "is_answered": true,
            "accepted_answer_id": 18927641,
            "answer_count": 4,
            "score": 17,
            "last_activity_date": 1618265782,
            "creation_date": 1379708380,
            "last_edit_date": 1379715401,
            "question_id": 18925181,
            "link": "https://stackoverflow.com/questions/18925181/procrustes-analysis-with-numpy",
            "title": "Procrustes Analysis with NumPy?",
            "body": "<p>Is there something like Matlab's <a href=\"http://www.mathworks.com/help/stats/procrustes.html\"><code>procrustes</code></a> function in NumPy/SciPy or related libraries? </p>\n\n<hr>\n\n<p>For reference. Procrustes analysis aims to align 2 sets of points (in other words, 2 shapes) to minimize square distance between them by removing scale, translation and rotation warp components. </p>\n\n<p>Example in Matlab:</p>\n\n<pre><code>X = [0 1; 2 3; 4 5; 6 7; 8 9];   % first shape\nR = [1 2; 2 1];                  % rotation matrix\nt = [3 5];                       % translation vector\nY = X * R + repmat(t, 5, 1);     % warped shape, no scale and no distortion\n[d Z] = procrustes(X, Y);        % Z is Y aligned back to X\nZ\n\nZ =\n\n  0.0000    1.0000\n  2.0000    3.0000\n  4.0000    5.0000\n  6.0000    7.0000\n  8.0000    9.0000\n</code></pre>\n\n<p>Same task in NumPy: </p>\n\n<pre><code>X = arange(10).reshape((5, 2))\nR = array([[1, 2], [2, 1]])\nt = array([3, 5])\nY = dot(X, R) + t\nZ = ???\n</code></pre>\n\n<p>Note: I'm only interested in aligned shape, since square error (variable <code>d</code> in Matlab code) is easily computed from 2 shapes. </p>\n"
        }
    ],
    "has_more": false,
    "quota_max": 10000,
    "quota_remaining": 5920
}