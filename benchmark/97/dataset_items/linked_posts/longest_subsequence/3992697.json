{
    "items": [
        {
            "tags": [
                "python",
                "algorithm",
                "language-agnostic"
            ],
            "comments": [
                {
                    "owner": {
                        "account_id": 342731,
                        "reputation": 351046,
                        "user_id": 674039,
                        "user_type": "registered",
                        "accept_rate": 94,
                        "display_name": "wim"
                    },
                    "edited": false,
                    "score": 0,
                    "creation_date": 1633578498,
                    "post_id": 3992697,
                    "comment_id": 122798386,
                    "link": "https://stackoverflow.com/questions/3992697/longest-increasing-subsequence#comment122798386_3992697",
                    "body": "There are some good algorithms here: <a href=\"https://algorithmist.com/wiki/Longest_increasing_subsequence\" rel=\"nofollow noreferrer\">algorithmist.com/wiki/Longest_increasing_subsequence</a>"
                }
            ],
            "answers": [
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 159211,
                                "reputation": 5012,
                                "user_id": 378360,
                                "user_type": "registered",
                                "display_name": "Falk H&#252;ffner"
                            },
                            "edited": false,
                            "score": 6,
                            "creation_date": 1287749496,
                            "post_id": 3992744,
                            "comment_id": 4279464,
                            "link": "https://stackoverflow.com/questions/3992697/longest-increasing-subsequence/3992744#comment4279464_3992744",
                            "body": "Actually, the most efficient known algorithm runs in O(N log log N) time (Hunt&amp;Szymanski, &quot;A fast algorithm for computing longest common subsequences&quot;, Communications of the ACM, 20(5):350\u2013353, 1977). However, it is unlikely that this is worth bothering in practice."
                        },
                        {
                            "owner": {
                                "account_id": 974838,
                                "reputation": 807,
                                "user_id": 996443,
                                "user_type": "registered",
                                "accept_rate": 100,
                                "display_name": "kevin"
                            },
                            "reply_to_user": {
                                "account_id": 159211,
                                "reputation": 5012,
                                "user_id": 378360,
                                "user_type": "registered",
                                "display_name": "Falk H&#252;ffner"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1379996781,
                            "post_id": 3992744,
                            "comment_id": 28023850,
                            "link": "https://stackoverflow.com/questions/3992697/longest-increasing-subsequence/3992744#comment28023850_3992744",
                            "body": "@FalkH&#252;ffner I think he is talking about longest increasing subsequences instead of longest common subsequence."
                        }
                    ],
                    "owner": {
                        "account_id": 80529,
                        "reputation": 450838,
                        "user_id": 227665,
                        "user_type": "registered",
                        "accept_rate": 33,
                        "display_name": "codaddict"
                    },
                    "comment_count": 2,
                    "is_accepted": false,
                    "score": 0,
                    "last_activity_date": 1287702900,
                    "creation_date": 1287702900,
                    "answer_id": 3992744,
                    "question_id": 3992697,
                    "link": "https://stackoverflow.com/questions/3992697/longest-increasing-subsequence/3992744#3992744",
                    "body": "<p>The most efficient algorithm for this is O(NlogN) outlined <a href=\"http://en.wikipedia.org/wiki/Longest_increasing_subsequence#Efficient_algorithms\" rel=\"nofollow\">here</a>.</p>\n\n<p>Another way to solve this is to take the <a href=\"http://en.wikipedia.org/wiki/Longest_common_subsequence_problem\" rel=\"nofollow\">longest common subsequence</a> (LCS) of the original array and it's sorted version, which takes O(N<sup>2</sup>) time.</p>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 422217,
                                "reputation": 186,
                                "user_id": 800864,
                                "user_type": "registered",
                                "accept_rate": 8,
                                "display_name": "Bimlesh Sharma"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1487609918,
                            "post_id": 3992910,
                            "comment_id": 71851425,
                            "link": "https://stackoverflow.com/questions/3992697/longest-increasing-subsequence/3992910#comment71851425_3992910",
                            "body": "I m not understanding how this is fulfilling the requirements. Could you please explain?"
                        }
                    ],
                    "owner": {
                        "account_id": 34563,
                        "reputation": 19924,
                        "user_id": 97754,
                        "user_type": "registered",
                        "accept_rate": 90,
                        "display_name": "Margus"
                    },
                    "comment_count": 1,
                    "is_accepted": false,
                    "score": 8,
                    "last_activity_date": 1287709942,
                    "last_edit_date": 1287709942,
                    "creation_date": 1287705202,
                    "answer_id": 3992910,
                    "question_id": 3992697,
                    "link": "https://stackoverflow.com/questions/3992697/longest-increasing-subsequence/3992910#3992910",
                    "body": "<p>Here is how to simply find longest increasing/decreasing subsequence in Mathematica:</p>\n\n<pre><code> LIS[list_] := LongestCommonSequence[Sort[list], list];\n input={0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15};\n LIS[input]\n -1*LIS[-1*input]\n</code></pre>\n\n<p>Output:</p>\n\n<pre><code>{0, 2, 6, 9, 11, 15}\n{12, 10, 9, 5, 3}\n</code></pre>\n\n<p>Mathematica has also <strong>LongestIncreasingSubsequence</strong> function in the <strong>Combinatorica`</strong> libary. If you do not have Mathematica you can query the <a href=\"http://www.wolframalpha.com/\" rel=\"noreferrer\">WolframAlpha</a>.</p>\n\n<blockquote>\n  <h2>C++ O(nlogn) solution</h2>\n  \n  <p>There's also an O(nlogn) solution based on some\n  observations. Let Ai,j be the smallest\n  possible tail out of all increasing\n  subsequences of length j using\n  elements a<sub>1</sub>, a<sub>2</sub>, ... , a<sub>i</sub>. Observe that, for any\n  particular i, A<sub>i,1</sub>, A<sub>i,2</sub>, ... , A<sub>i,j</sub>. This suggests that if\n  we want the longest subsequence that\n  ends with ai + 1, we only need to look\n  for a j such that Ai,j &lt; ai + 1 &lt; =\n  Ai,j + 1 and the length will be j + 1.\n  Notice that in this case, Ai + 1,j + 1\n  will be equal to ai + 1, and all Ai +\n  1,k will be equal to Ai,k for k!=j+1.\n  Furthermore, there is at most one\n  difference between the set Ai and the\n  set Ai + 1, which is caused by this\n  search. Since A is always ordered in\n  increasing order, and the operation\n  does not change this ordering, we can\n  do a binary search for every single a<sub>1</sub>, a<sub>2</sub>, ... , a<sub>n</sub>.</p>\n  \n  <h2>Implementation <a href=\"http://www.algorithmist.com/index.php/Longest_Increasing_Subsequence.cpp\" rel=\"noreferrer\">C++</a> (O(nlogn) algorithm)</h2>\n\n<pre><code>#include &lt;vector&gt;\nusing namespace std;\n\n/* Finds longest strictly increasing subsequence. O(n log k) algorithm. */\nvoid find_lis(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b)\n{\n  vector&lt;int&gt; p(a.size());\n  int u, v;\n\n  if (a.empty()) return;\n\n  b.push_back(0);\n\n  for (size_t i = 1; i &lt; a.size(); i++) {\n      if (a[b.back()] &lt; a[i]) {\n          p[i] = b.back();\n          b.push_back(i);\n          continue;\n      }\n\n      for (u = 0, v = b.size()-1; u &lt; v;) {\n          int c = (u + v) / 2;\n          if (a[b[c]] &lt; a[i]) u=c+1; else v=c;\n      }\n\n      if (a[i] &lt; a[b[u]]) {\n          if (u &gt; 0) p[i] = b[u-1];\n          b[u] = i;\n      }   \n  }\n\n  for (u = b.size(), v = b.back(); u--; v = p[v]) b[u] = v;\n}\n\n/* Example of usage: */\n#include &lt;cstdio&gt;\nint main()\n{\n  int a[] = { 1, 9, 3, 8, 11, 4, 5, 6, 4, 19, 7, 1, 7 };\n  vector&lt;int&gt; seq(a, a+sizeof(a)/sizeof(a[0]));\n  vector&lt;int&gt; lis;\n        find_lis(seq, lis);\n\n  for (size_t i = 0; i &lt; lis.size(); i++)\n      printf(\"%d \", seq[lis[i]]);\n        printf(\"\\n\");    \n\n  return 0;\n}\n</code></pre>\n</blockquote>\n\n<p>Source: <a href=\"http://www.algorithmist.com/index.php/Longest_Increasing_Subsequence\" rel=\"noreferrer\">link</a></p>\n\n<p>I have rewritten the C++ implementation to Java a while ago, and can confirm it works. Vector alternative in python is List. But if you want to test it yourself, here is link for online compiler with example implementation loaded: <a href=\"http://www.ideone.com/oseBi\" rel=\"noreferrer\">link</a></p>\n\n<p>Example data is: <code>{ 1, 9, 3, 8, 11, 4, 5, 6, 4, 19, 7, 1, 7 }</code>\nand answer: <code>1 3 4 5 6 7</code>.</p>\n"
                },
                {
                    "owner": {
                        "account_id": 97303,
                        "reputation": 2584,
                        "user_id": 264003,
                        "user_type": "registered",
                        "accept_rate": 40,
                        "display_name": "zzz"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 2,
                    "last_activity_date": 1319731608,
                    "creation_date": 1319731608,
                    "answer_id": 7918909,
                    "question_id": 3992697,
                    "link": "https://stackoverflow.com/questions/3992697/longest-increasing-subsequence/7918909#7918909",
                    "body": "<p>Here is some python code with tests which implements the algorithm running in O(n*log(n)). I found this on a the <a href=\"http://en.wikipedia.org/wiki/Talk%3aLongest_increasing_subsequence\" rel=\"nofollow\">wikipedia talk page</a> about the <a href=\"http://en.wikipedia.org/wiki/Longest_increasing_subsequence\" rel=\"nofollow\">longest increasing subsequence</a>. </p>\n\n<pre><code>import unittest\n\n\ndef LongestIncreasingSubsequence(X):\n    \"\"\"\n    Find and return longest increasing subsequence of S.\n    If multiple increasing subsequences exist, the one that ends\n    with the smallest value is preferred, and if multiple\n    occurrences of that value can end the sequence, then the\n    earliest occurrence is preferred.\n    \"\"\"\n    n = len(X)\n    X = [None] + X  # Pad sequence so that it starts at X[1]\n    M = [None]*(n+1)  # Allocate arrays for M and P\n    P = [None]*(n+1)\n    L = 0\n    for i in range(1,n+1):\n        if L == 0 or X[M[1]] &gt;= X[i]:\n            # there is no j s.t. X[M[j]] &lt; X[i]]\n            j = 0\n        else:\n            # binary search for the largest j s.t. X[M[j]] &lt; X[i]]\n            lo = 1      # largest value known to be &lt;= j\n            hi = L+1    # smallest value known to be &gt; j\n            while lo &lt; hi - 1:\n                mid = (lo + hi)//2\n                if X[M[mid]] &lt; X[i]:\n                    lo = mid\n                else:\n                    hi = mid\n            j = lo\n\n        P[i] = M[j]\n        if j == L or X[i] &lt; X[M[j+1]]:\n            M[j+1] = i\n            L = max(L,j+1)\n\n    # Backtrack to find the optimal sequence in reverse order\n    output = []\n    pos = M[L]\n    while L &gt; 0:\n        output.append(X[pos])\n        pos = P[pos]\n        L -= 1\n\n    output.reverse()\n    return output\n\n# Try small lists and check that the correct subsequences are generated.\n\nclass LISTest(unittest.TestCase):\n    def testLIS(self):\n        self.assertEqual(LongestIncreasingSubsequence([]),[])\n        self.assertEqual(LongestIncreasingSubsequence(range(10,0,-1)),[1])\n        self.assertEqual(LongestIncreasingSubsequence(range(10)),range(10))\n        self.assertEqual(LongestIncreasingSubsequence(\\\n            [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9]), [1,2,3,5,8,9])\n\nunittest.main()\n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 1048107,
                        "reputation": 21,
                        "user_id": 1052682,
                        "user_type": "unregistered",
                        "display_name": "benben"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 2,
                    "last_activity_date": 1321563486,
                    "creation_date": 1321563486,
                    "answer_id": 8174197,
                    "question_id": 3992697,
                    "link": "https://stackoverflow.com/questions/3992697/longest-increasing-subsequence/8174197#8174197",
                    "body": "<pre><code>    int[] a = {1,3,2,4,5,4,6,7};\n    StringBuilder s1 = new StringBuilder();\n    for(int i : a){\n     s1.append(i);\n    }       \n    StringBuilder s2 = new StringBuilder();\n    int count = findSubstring(s1.toString(), s2);       \n    System.out.println(s2.reverse());\n\npublic static int findSubstring(String str1, StringBuilder s2){     \n    StringBuilder s1 = new StringBuilder(str1);\n    if(s1.length() == 0){\n        return 0;\n    }\n    if(s2.length() == 0){\n        s2.append(s1.charAt(s1.length()-1));\n        findSubstring(s1.deleteCharAt(s1.length()-1).toString(), s2);           \n    } else if(s1.charAt(s1.length()-1) &lt; s2.charAt(s2.length()-1)){ \n        char c = s1.charAt(s1.length()-1);\n        return 1 + findSubstring(s1.deleteCharAt(s1.length()-1).toString(), s2.append(c));\n    }\n    else{\n        char c = s1.charAt(s1.length()-1);\n        StringBuilder s3 = new StringBuilder();\n        for(int i=0; i &lt; s2.length(); i++){\n            if(s2.charAt(i) &gt; c){\n                s3.append(s2.charAt(i));\n            }\n        }\n        s3.append(c);\n        return Math.max(findSubstring(s1.deleteCharAt(s1.length()-1).toString(), s2), \n                findSubstring(s1.deleteCharAt(s1.length()-1).toString(), s3));\n    }       \n    return 0;\n}\n</code></pre>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 171685,
                                "reputation": 7258,
                                "user_id": 399268,
                                "user_type": "registered",
                                "accept_rate": 90,
                                "display_name": "Jungle Hunter"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1332485056,
                            "post_id": 9832414,
                            "comment_id": 12532384,
                            "link": "https://stackoverflow.com/questions/3992697/longest-increasing-subsequence/9832414#comment12532384_9832414",
                            "body": "Ah! Python is so much better, and your comments help. I&#39;ll look at it in more detail in the morning."
                        },
                        {
                            "owner": {
                                "account_id": 158074,
                                "reputation": 4961,
                                "user_id": 376445,
                                "user_type": "registered",
                                "accept_rate": 89,
                                "display_name": "Sam Stoelinga"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1382678552,
                            "post_id": 9832414,
                            "comment_id": 29062000,
                            "link": "https://stackoverflow.com/questions/3992697/longest-increasing-subsequence/9832414#comment29062000_9832414",
                            "body": "Works well in python 2.7 also :)"
                        },
                        {
                            "owner": {
                                "account_id": 3470597,
                                "reputation": 4028,
                                "user_id": 3956460,
                                "user_type": "registered",
                                "accept_rate": 71,
                                "display_name": "PaulMag"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1447856329,
                            "post_id": 9832414,
                            "comment_id": 55331411,
                            "link": "https://stackoverflow.com/questions/3992697/longest-increasing-subsequence/9832414#comment55331411_9832414",
                            "body": "@RikPoggi Do you know how this could me modified to only accept unique solutions? If there are two or more possible longest subsequences I want to reject them both and look for the second longest subsequence instead, or third longest, etc. You can see my question here: <a href=\"http://stackoverflow.com/questions/33778471/extract-monotonic-part-from-partly-monotonic-increasing-list-in-python\" title=\"extract monotonic part from partly monotonic increasing list in python\">stackoverflow.com/questions/33778471/&hellip;</a>"
                        }
                    ],
                    "owner": {
                        "account_id": 1150742,
                        "reputation": 28992,
                        "user_id": 1132524,
                        "user_type": "registered",
                        "accept_rate": 100,
                        "display_name": "Rik Poggi"
                    },
                    "comment_count": 3,
                    "is_accepted": true,
                    "score": 37,
                    "last_activity_date": 1332494225,
                    "last_edit_date": 1495541437,
                    "creation_date": 1332461504,
                    "answer_id": 9832414,
                    "question_id": 3992697,
                    "link": "https://stackoverflow.com/questions/3992697/longest-increasing-subsequence/9832414#9832414",
                    "body": "<p>I just stumbled in this problem, and came up with this Python 3 implementation:</p>\n\n\n\n<pre class=\"lang-py prettyprint-override\"><code>def subsequence(seq):\n    if not seq:\n        return seq\n\n    M = [None] * len(seq)    # offset by 1 (j -&gt; j-1)\n    P = [None] * len(seq)\n\n    # Since we have at least one element in our list, we can start by \n    # knowing that the there's at least an increasing subsequence of length one:\n    # the first element.\n    L = 1\n    M[0] = 0\n\n    # Looping over the sequence starting from the second element\n    for i in range(1, len(seq)):\n        # Binary search: we want the largest j &lt;= L\n        #  such that seq[M[j]] &lt; seq[i] (default j = 0),\n        #  hence we want the lower bound at the end of the search process.\n        lower = 0\n        upper = L\n\n        # Since the binary search will not look at the upper bound value,\n        # we'll have to check that manually\n        if seq[M[upper-1]] &lt; seq[i]:\n            j = upper\n\n        else:\n            # actual binary search loop\n            while upper - lower &gt; 1:\n                mid = (upper + lower) // 2\n                if seq[M[mid-1]] &lt; seq[i]:\n                    lower = mid\n                else:\n                    upper = mid\n\n            j = lower    # this will also set the default value to 0\n\n        P[i] = M[j-1]\n\n        if j == L or seq[i] &lt; seq[M[j]]:\n            M[j] = i\n            L = max(L, j+1)\n\n    # Building the result: [seq[M[L-1]], seq[P[M[L-1]]], seq[P[P[M[L-1]]]], ...]\n    result = []\n    pos = M[L-1]\n    for _ in range(L):\n        result.append(seq[pos])\n        pos = P[pos]\n\n    return result[::-1]    # reversing\n</code></pre>\n\n<p>Since it took me some time to understand how the algorithm works I was a little verbose with comments, and I'll also add a quick explanation:</p>\n\n<ul>\n<li><code>seq</code> is the input sequence.</li>\n<li><code>L</code> is a number: it gets updated while looping over the sequence and it marks the length of longest incresing subsequence found up to that moment.</li>\n<li><code>M</code> is a list. <code>M[j-1]</code> will point to an index of <code>seq</code> that holds the smallest value that could be used (at the end) to build an increasing subsequence of length <code>j</code>.</li>\n<li><code>P</code> is a list. <code>P[i]</code> will point to <code>M[j]</code>, where <code>i</code> is the index of <code>seq</code>. In a few words, it tells which is the previous element of the subsequence. <code>P</code> is used to build the result at the end.</li>\n</ul>\n\n<p>How the algorithm works:</p>\n\n<ol>\n<li>Handle the special case of an empty sequence.</li>\n<li>Start with a subsequence of 1 element.</li>\n<li>Loop over the input sequence with index <code>i</code>.</li>\n<li>With a binary search find the <code>j</code> that let <code>seq[M[j]</code> be <code>&lt;</code> than <code>seq[i]</code>.</li>\n<li>Update <code>P</code>, <code>M</code> and <code>L</code>.</li>\n<li>Traceback the result and return it reversed.</li>\n</ol>\n\n<p><strong>Note:</strong> The only differences with the <a href=\"http://en.wikipedia.org/wiki/Longest_increasing_subsequence#Efficient_algorithms\" rel=\"noreferrer\">wikipedia algorithm</a> are the offset of 1 in the <code>M</code> list, and that <code>X</code> is here called <code>seq</code>. I also test it with a slightly improved unit test version of the one showed in <a href=\"https://stackoverflow.com/a/7918909/1132524\">Eric Gustavson answer</a> and it passed all tests.</p>\n\n<hr>\n\n<p>Example:</p>\n\n<pre class=\"lang-py prettyprint-override\"><code>seq = [30, 10, 20, 50, 40, 80, 60]\n\n       0    1   2   3   4   5   6   &lt;-- indexes\n</code></pre>\n\n<p>At the end we'll have:</p>\n\n<pre class=\"lang-py prettyprint-override\"><code>M = [1, 2, 4, 6, None, None, None]\nP = [None, None, 1, 2, 2, 4, 4]\nresult = [10, 20, 40, 60]\n</code></pre>\n\n<p>As you'll see <code>P</code> is pretty straightforward. We have to look at it from the end, so it tells that before <code>60</code> there's <code>40,</code>before <code>80</code> there's <code>40</code>, before <code>40</code> there's <code>20</code>, before <code>50</code> there's <code>20</code> and before <code>20</code> there's <code>10</code>, stop.</p>\n\n<p>The complicated part is on <code>M</code>. At the beginning <code>M</code> was <code>[0, None, None, ...]</code> since the last element of the subsequence of length 1 (hence position 0 in <code>M</code>) was at the index 0: <code>30</code>. </p>\n\n<p>At this point we'll start looping on <code>seq</code> and look at <code>10</code>, since <code>10</code> is <code>&lt;</code> than <code>30</code>, <code>M</code> will be updated:</p>\n\n<pre class=\"lang-py prettyprint-override\"><code>if j == L or seq[i] &lt; seq[M[j]]:\n    M[j] = i\n</code></pre>\n\n<p>So now <code>M</code> looks like: <code>[1, None, None, ...]</code>. This is a good thing, because <code>10</code> have more chanches to create a longer increasing subsequence. (The new 1 is the index of 10)</p>\n\n<p>Now it's the turn of <code>20</code>. With <code>10</code> and <code>20</code> we have subsequence of length 2 (index 1 in <code>M</code>), so <code>M</code> will be: <code>[1, 2, None, ...]</code>. (The new 2 is the index of 20)</p>\n\n<p>Now it's the turn of <code>50</code>. <code>50</code> will not be part of any subsequence so nothing changes.</p>\n\n<p>Now it's the turn of <code>40</code>. With <code>10</code>, <code>20</code> and <code>40</code> we have a sub of length 3 (index 2 in <code>M</code>, so <code>M</code> will be: <code>[1, 2, 4, None, ...]</code> . (The new 4 is the index of 40)</p>\n\n<p>And so on...</p>\n\n<p>For a complete walk through the code you can copy and paste it <a href=\"http://netserv.ict.ru.ac.za/python3_viz/\" rel=\"noreferrer\">here</a> :)</p>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 14197194,
                                "reputation": 146,
                                "user_id": 10256147,
                                "user_type": "registered",
                                "display_name": "Miroslav Je\u017e&#237;k"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1659177503,
                            "post_id": 15996654,
                            "comment_id": 129234618,
                            "link": "https://stackoverflow.com/questions/3992697/longest-increasing-subsequence/15996654#comment129234618_15996654",
                            "body": "I don&#39;t think this solution is right. It returns <code>[1, 2, 5]</code> for simple array <code>[3, 4, 5, 1, 2]</code>"
                        }
                    ],
                    "owner": {
                        "account_id": 2633780,
                        "reputation": 767,
                        "user_id": 2279035,
                        "user_type": "registered",
                        "display_name": "Deepak Singhvi"
                    },
                    "comment_count": 1,
                    "is_accepted": false,
                    "score": 1,
                    "last_activity_date": 1441716499,
                    "last_edit_date": 1441716499,
                    "creation_date": 1365923449,
                    "answer_id": 15996654,
                    "question_id": 3992697,
                    "link": "https://stackoverflow.com/questions/3992697/longest-increasing-subsequence/15996654#15996654",
                    "body": "<p>Here is the code and explanation with Java, may be I will add for python soon.</p>\n\n<pre><code>arr = {0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}\n</code></pre>\n\n<ol>\n<li>list  = {0} - Initialize list to the empty set</li>\n<li>list  = {0,8} - New largest LIS</li>\n<li>list  = {0, 4} - Changed 8 to 4</li>\n<li>list  = {0, 4, 12} - New largest LIS</li>\n<li>list  = {0, 2, 12} - Changed 4 to 2</li>\n<li>list  = {0, 2, 10} - Changed 12 to 10</li>\n<li>list  = {0, 2, 6} - Changed 10 to 6</li>\n<li>list  = {0, 2, 6, 14} - New largest LIS</li>\n<li>list  = {0, 1, 6, 14} - Changed 2 to 1</li>\n<li>list = {0, 1, 6, 9} - Changed 14 to 9</li>\n<li>list = {0, 1, 5, 9} - Changed 6 to 5</li>\n<li>list = {0, 1, 6, 9, 13} - Changed 3 to 2</li>\n<li>list = {0, 1, 3, 9, 11} - New largest LIS</li>\n<li>list = {0, 1, 3, 9, 11} - Changed 9 to 5</li>\n<li>list = {0, 1, 3, 7, 11} - New largest LIS</li>\n<li>list = {0, 1, 3, 7, 11, 15} - New largest LIS</li>\n</ol>\n\n<p>So the length of the LIS is 6 (the size of list).</p>\n\n<pre><code>import java.util.ArrayList;\nimport java.util.List;\n\n\npublic class LongestIncreasingSubsequence {\n    public static void main(String[] args) {\n        int[] arr = { 0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15 };\n        increasingSubsequenceValues(arr);\n    }\n\n    public static void increasingSubsequenceValues(int[] seq) {\n        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n        for (int i = 0; i &lt; seq.length; i++) {\n            int j = 0;\n            boolean elementUpdate = false;\n            for (; j &lt; list.size(); j++) {\n                if (list.get(j) &gt; seq[i]) {\n                    list.add(j, seq[i]);\n                    list.remove(j + 1);\n                    elementUpdate = true;\n                    break;\n                }\n            }\n            if (!elementUpdate) {\n                list.add(j, seq[i]);\n            }\n        }\n        System.out.println(\"Longest Increasing Subsequence\" + list);\n    }\n\n\n}\n</code></pre>\n\n<p>Output for the above code: Longest Increasing Subsequence[0, 1, 3, 7, 11, 15]</p>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 6448,
                                "reputation": 10151,
                                "user_id": 10840,
                                "user_type": "registered",
                                "accept_rate": 40,
                                "display_name": "millerdev"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1575989293,
                            "post_id": 34598220,
                            "comment_id": 104746819,
                            "link": "https://stackoverflow.com/questions/3992697/longest-increasing-subsequence/34598220#comment104746819_34598220",
                            "body": "Quite compact O(N**2) algorithm. Also has a bug causing <i>ValueError: max() arg is an empty sequence</i> for some inputs. Does not work in Python 3."
                        }
                    ],
                    "owner": {
                        "account_id": 2460045,
                        "reputation": 1524,
                        "user_id": 2144401,
                        "user_type": "registered",
                        "display_name": "cmantas"
                    },
                    "comment_count": 1,
                    "is_accepted": false,
                    "score": 0,
                    "last_activity_date": 1451934993,
                    "creation_date": 1451934993,
                    "answer_id": 34598220,
                    "question_id": 3992697,
                    "link": "https://stackoverflow.com/questions/3992697/longest-increasing-subsequence/34598220#34598220",
                    "body": "<p>here's a compact implementation using \"enumerate\"</p>\n\n<pre><code>def lis(l):\n\n# we will create a list of lists where each sub-list contains\n# the longest increasing subsequence ending at this index\nlis = [[e] for e in l]\n# start with just the elements of l as contents of the sub-lists\n\n# iterate over (index,value) of l\nfor i, e in enumerate(l):\n    # (index,value) tuples for elements b where b&lt;e and a&lt;i\n    lower_tuples = filter(lambda (a,b): b&lt;e, enumerate(l[:i]))\n    # if no such items, nothing to do\n    if not lower_tuples: continue\n    # keep the lis-es of such items\n    lowerlises = [lis[a] for a,b in  lower_tuples ]\n    # choose the longest one of those and add\n    # to the current element's lis\n    lis[i] = max(lowerlises, key=len) + [e]\n\n# retrun the longest of lis-es\nreturn max(lis, key=len)\n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 2202373,
                        "reputation": 3240,
                        "user_id": 1946465,
                        "user_type": "registered",
                        "accept_rate": 33,
                        "display_name": "isarandi"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 1,
                    "last_activity_date": 1465482374,
                    "creation_date": 1465482374,
                    "answer_id": 37728738,
                    "question_id": 3992697,
                    "link": "https://stackoverflow.com/questions/3992697/longest-increasing-subsequence/37728738#37728738",
                    "body": "<p>Here's a more compact but still efficient Python implementation:</p>\n\n<pre><code>def longest_increasing_subsequence_indices(seq):\n    from bisect import bisect_right\n\n    if len(seq) == 0:\n        return seq\n\n    # m[j] in iteration i is the last index of the increasing subsequence of seq[:i]\n    # that ends with the lowest possible value while having length j\n    m = [None] * len(seq)\n    predecessor = [None] * len(seq)\n    best_len = 0\n\n    for i, item in enumerate(seq):\n        j = bisect_right([seq[k] for k in m[:best_len]], item)\n        m[j] = i\n        predecessor[i] = m[j-1] if j &gt; 0 else None\n        best_len = max(best_len, j+1)\n\n    result = []\n    i = m[best_len-1]\n    while i is not None:\n        result.append(i)\n        i = predecessor[i]\n    result.reverse()\n    return result\n\ndef longest_increasing_subsequence(seq):\n    return [seq[i] for i in longest_increasing_subsequence_indices(seq)]\n</code></pre>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 395733,
                                "reputation": 15983,
                                "user_id": 758836,
                                "user_type": "registered",
                                "accept_rate": 51,
                                "display_name": "loretoparisi"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1558649056,
                            "post_id": 38337443,
                            "comment_id": 99180916,
                            "link": "https://stackoverflow.com/questions/3992697/longest-increasing-subsequence/38337443#comment99180916_38337443",
                            "body": "Tha\u2019s an amazing answer and the reason why I love SF!"
                        }
                    ],
                    "owner": {
                        "account_id": 2162613,
                        "reputation": 9453,
                        "user_id": 1916449,
                        "user_type": "registered",
                        "accept_rate": 100,
                        "display_name": "arekolek"
                    },
                    "comment_count": 1,
                    "is_accepted": false,
                    "score": 4,
                    "last_activity_date": 1468353145,
                    "last_edit_date": 1495535479,
                    "creation_date": 1468351876,
                    "answer_id": 38337443,
                    "question_id": 3992697,
                    "link": "https://stackoverflow.com/questions/3992697/longest-increasing-subsequence/38337443#38337443",
                    "body": "<p>Here is a pretty general solution that:</p>\n\n<ul>\n<li>runs in <code>O(n log n)</code> time,</li>\n<li>handles increasing, nondecreasing, decreasing and nonincreasing subsequences,</li>\n<li>works with any sequence objects, including <code>list</code>, <code>numpy.array</code>, <code>str</code> and more,</li>\n<li>supports lists of objects and custom comparison methods through the <code>key</code> parameter that works like the one in the builtin <code>sorted</code> function,</li>\n<li>can return the elements of the subsequence or their indices.</li>\n</ul>\n\n<p>The code:</p>\n\n<pre><code>from bisect import bisect_left, bisect_right\nfrom functools import cmp_to_key\n\ndef longest_subsequence(seq, mode='strictly', order='increasing',\n                        key=None, index=False):\n\n  bisect = bisect_left if mode.startswith('strict') else bisect_right\n\n  # compute keys for comparison just once\n  rank = seq if key is None else map(key, seq)\n  if order == 'decreasing':\n    rank = map(cmp_to_key(lambda x,y: 1 if x&lt;y else 0 if x==y else -1), rank)\n  rank = list(rank)\n\n  if not rank: return []\n\n  lastoflength = [0] # end position of subsequence with given length\n  predecessor = [None] # penultimate element of l.i.s. ending at given position\n\n  for i in range(1, len(seq)):\n    # seq[i] can extend a subsequence that ends with a lesser (or equal) element\n    j = bisect([rank[k] for k in lastoflength], rank[i])\n    # update existing subsequence of length j or extend the longest\n    try: lastoflength[j] = i\n    except: lastoflength.append(i)\n    # remember element before seq[i] in the subsequence\n    predecessor.append(lastoflength[j-1] if j &gt; 0 else None)\n\n  # trace indices [p^n(i), ..., p(p(i)), p(i), i], where n=len(lastoflength)-1\n  def trace(i):\n    if i is not None:\n      yield from trace(predecessor[i])\n      yield i\n  indices = trace(lastoflength[-1])\n\n  return list(indices) if index else [seq[i] for i in indices]\n</code></pre>\n\n<p>I wrote a docstring for the function that I didn't paste above in order to show off the code:</p>\n\n<pre><code>\"\"\"\nReturn the longest increasing subsequence of `seq`.\n\nParameters\n----------\nseq : sequence object\n  Can be any sequence, like `str`, `list`, `numpy.array`.\nmode : {'strict', 'strictly', 'weak', 'weakly'}, optional\n  If set to 'strict', the subsequence will contain unique elements.\n  Using 'weak' an element can be repeated many times.\n  Modes ending in -ly serve as a convenience to use with `order` parameter,\n  because `longest_sequence(seq, 'weakly', 'increasing')` reads better.\n  The default is 'strict'.\norder : {'increasing', 'decreasing'}, optional\n  By default return the longest increasing subsequence, but it is possible\n  to return the longest decreasing sequence as well.\nkey : function, optional\n  Specifies a function of one argument that is used to extract a comparison\n  key from each list element (e.g., `str.lower`, `lambda x: x[0]`).\n  The default value is `None` (compare the elements directly).\nindex : bool, optional\n  If set to `True`, return the indices of the subsequence, otherwise return\n  the elements. Default is `False`.\n\nReturns\n-------\nelements : list, optional\n  A `list` of elements of the longest subsequence.\n  Returned by default and when `index` is set to `False`.\nindices : list, optional\n  A `list` of indices pointing to elements in the longest subsequence.\n  Returned when `index` is set to `True`.\n\"\"\"\n</code></pre>\n\n<p>Some examples:</p>\n\n<pre><code>&gt;&gt;&gt; seq = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]\n\n&gt;&gt;&gt; longest_subsequence(seq)\n[0, 2, 6, 9, 11, 15]\n\n&gt;&gt;&gt; longest_subsequence(seq, order='decreasing')\n[12, 10, 9, 5, 3]\n\n&gt;&gt;&gt; txt = (\"Given an input sequence, what is the best way to find the longest\"\n               \" (not necessarily continuous) non-decreasing subsequence.\")\n\n&gt;&gt;&gt; ''.join(longest_subsequence(txt))\n' ,abdegilnorsu'\n\n&gt;&gt;&gt; ''.join(longest_subsequence(txt, 'weak'))\n'              ceilnnnnrsssu'\n\n&gt;&gt;&gt; ''.join(longest_subsequence(txt, 'weakly', 'decreasing'))\n'vuutttttttssronnnnngeee.'\n\n&gt;&gt;&gt; dates = [\n...   ('2015-02-03', 'name1'),\n...   ('2015-02-04', 'nameg'),\n...   ('2015-02-04', 'name5'),\n...   ('2015-02-05', 'nameh'),\n...   ('1929-03-12', 'name4'),\n...   ('2023-07-01', 'name7'),\n...   ('2015-02-07', 'name0'),\n...   ('2015-02-08', 'nameh'),\n...   ('2015-02-15', 'namex'),\n...   ('2015-02-09', 'namew'),\n...   ('1980-12-23', 'name2'),\n...   ('2015-02-12', 'namen'),\n...   ('2015-02-13', 'named'),\n... ]\n\n&gt;&gt;&gt; longest_subsequence(dates, 'weak')\n\n[('2015-02-03', 'name1'),\n ('2015-02-04', 'name5'),\n ('2015-02-05', 'nameh'),\n ('2015-02-07', 'name0'),\n ('2015-02-08', 'nameh'),\n ('2015-02-09', 'namew'),\n ('2015-02-12', 'namen'),\n ('2015-02-13', 'named')]\n\n&gt;&gt;&gt; from operator import itemgetter\n\n&gt;&gt;&gt; longest_subsequence(dates, 'weak', key=itemgetter(0))\n\n[('2015-02-03', 'name1'),\n ('2015-02-04', 'nameg'),\n ('2015-02-04', 'name5'),\n ('2015-02-05', 'nameh'),\n ('2015-02-07', 'name0'),\n ('2015-02-08', 'nameh'),\n ('2015-02-09', 'namew'),\n ('2015-02-12', 'namen'),\n ('2015-02-13', 'named')]\n\n&gt;&gt;&gt; indices = set(longest_subsequence(dates, key=itemgetter(0), index=True))\n\n&gt;&gt;&gt; [e for i,e in enumerate(dates) if i not in indices]\n\n[('2015-02-04', 'nameg'),\n ('1929-03-12', 'name4'),\n ('2023-07-01', 'name7'),\n ('2015-02-15', 'namex'),\n ('1980-12-23', 'name2')]\n</code></pre>\n\n<p>This answer was in part inspired by the <a href=\"https://codereview.stackexchange.com/q/10230/110989\">question over at Code Review</a> and in part by <a href=\"https://stackoverflow.com/q/38283710/1916449\">question asking about \"out of sequence\" values</a>.</p>\n"
                },
                {
                    "owner": {
                        "account_id": 366927,
                        "reputation": 25109,
                        "user_id": 712765,
                        "user_type": "registered",
                        "accept_rate": 42,
                        "display_name": "Old Pro"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 1,
                    "last_activity_date": 1545522024,
                    "creation_date": 1545522024,
                    "answer_id": 53900107,
                    "question_id": 3992697,
                    "link": "https://stackoverflow.com/questions/3992697/longest-increasing-subsequence/53900107#53900107",
                    "body": "<p>There are several answers in code, but I found them a bit hard to understand, so here is an explanation of the general idea, leaving out all the optimizations. I will get to the optimizations later.</p>\n\n<p>We will use the sequence 2, 8, 4, 12, 3, 10 and, to make it easier to follow, we will require the input sequence to not be empty and to not include the same number more than once. </p>\n\n<p>We go through the sequence in order.</p>\n\n<p>As we do, we maintain a set of sequences, the best sequences we have found so far for each length. After we find the first sequence of length 1, which is the first element of the input sequence, we are guaranteed to have a set of sequences for each possible length from 1 to the longest we have found so far. This is obvious, because if we have a sequence of length 3, then the first 2 elements of that sequence are a sequence of length 2.</p>\n\n<p>So we start with the first element being a sequence of length 1 and our set looks like</p>\n\n<pre><code> 1: 2\n</code></pre>\n\n<p>We take the next element of the sequence (8) and look for the longest sequence we can add it to. This is sequence 1, so we get</p>\n\n<pre><code>1: 2\n2: 2 8\n</code></pre>\n\n<p>We take the next element of the sequence (4) and look for the longest sequence we can add it to. The longest sequence we can add it to is the one of length 1 (which is just <code>2</code>). <strong>Here is what I found to be the tricky (or at least non-obvious) part.</strong> Because we could not add it to the end of the sequence of length 2 (<code>2 8</code>) that means <em>it must be a better choice to end the length 2 candidate</em>. If the element were greater than 8, it would have tacked on to the length 2 sequence and given us a new length 3 sequence. So we know that it is less than 8 and therefore replace the 8 with the 4.</p>\n\n<p>Algorithmically, what we say is that whatever is the longest sequence we can tack the element onto, that sequence plus this element is the best candidate for a sequence of the resulting length. <em>Note that every element we process must belong somewhere (because we ruled out duplicate numbers in the input). If it is smaller than the element in length 1, it is the new length 1, otherwise it goes on the end of some existing sequence.</em> Here, the length 1 sequence plus the element 4 becomes the new length 2 sequence and we have:</p>\n\n<pre><code>1: 2\n2: 2 4 (replaces 2 8)\n</code></pre>\n\n<p>The next element, 12, gives us a sequence of length 3 and we have</p>\n\n<pre><code>1: 2\n2: 2 4\n3: 2 4 12\n</code></pre>\n\n<p>The next element, 3, gives us a better sequence of length 2:</p>\n\n<pre><code>1: 2\n2: 2 3 (replaces 2 4)\n3: 2 4 12\n</code></pre>\n\n<p>Note the we cannot alter the sequence of length 3 (substituting the 3 for the 4) because they did not occur in that order in the input sequence. The next element, 10, takes care of this. Because the best we can do with 10 is add it on to <code>2 3</code> it becomes the new list of length 3:</p>\n\n<pre><code>1: 2\n2: 2 3\n3: 2 3 10 (replaces 2 4 12)\n</code></pre>\n\n<p>Note that in terms of the algorithm, we really don't care what comes before the last element on any of our candidate sequences, but of course we need to keep track so that at the end we can output the full sequence. </p>\n\n<p>We keep processing input elements like this: just tack each one onto the longest sequence we can and make that the new candidate sequence for the resulting length, because it is guaranteed not to be worse than the existing sequence of that length. At the end, we output the longest sequence we have found.</p>\n\n<h3>Optimizations</h3>\n\n<p><strong>One optimization</strong> is that we do not really need to store the entire sequence of each length. To do so would take space of O(n^2). For the most part, we can get away with just storing the last element of each sequence, since that is all we ever compare against. (I will get to why this is not entirely sufficient in a bit. See if you can figure out why before I get to it.)</p>\n\n<p>So let's say we will store our set of sequences as an array <code>M</code> where <code>M[x]</code> holds the last element of the sequence of length <code>x</code>. If you think about it, you will realize that the elements of <code>M</code> are themselves in increasing order: they are sorted. If <code>M[x+1]</code> were less than <code>M[x]</code>, it would have replaced <code>M[x]</code> instead. </p>\n\n<p>Since <code>M</code> is sorted, <strong>the next optimization</strong> goes to something I totally glossed over above: how do we find the sequence to add on to? Well, since <code>M</code> is sorted, we can just do a binary search to find the largest <code>M[x]</code> less than the element to be added. That is the sequence we add on to. </p>\n\n<p>This is great if all we want to do is find the length of the longest sequence. However, <code>M</code> is not sufficient to reconstruct the sequence itself. Remember, at one point our set looked like this:</p>\n\n<pre><code>1: 0\n2: 0 2\n3: 0 4 12\n</code></pre>\n\n<p>We cannot just output <code>M</code> itself as the sequence. We need more information in order to be able to reconstruct the sequence. For this, <strong>we make 2 more changes</strong>. <strong>First</strong>, we store the input sequence in an array <code>seq</code> and instead of storing the value of the element in <code>M[x]</code>, we store the index of the element in <code>seq</code>, so the value is <code>seq[M[x]]</code>. </p>\n\n<p>We do this so that we can keep a record of the entire sequence by chaining subsequences. As you saw at the beginning, every sequence is created by adding a single element to the end of an already existing sequence. So, <strong>second</strong>, we keep another array <code>P</code> that stores the index (in <code>seq</code>) of the last element of the sequence we are adding on to. In order to make it chainable, since what we are storing in <code>P</code> is an index of <code>seq</code> we have to index <code>P</code> itself by an index of <code>seq</code>. </p>\n\n<p>The way this works is that when processing element <code>i</code> of <code>seq</code>, we find which sequence we are adding onto. Remember, we are going to tack <code>seq[i]</code> onto a sequence of length <code>x</code> to create a new sequence of length <code>x+1</code> for some <code>x</code>, and we are storing <code>i</code>, not <code>seq[i]</code> in <code>M[x+1]</code>. Later, when we find that <code>x+1</code> is the biggest length possible, we are going to want to reconstruct the sequence, but the only starting point we have is <code>M[x+1]</code>. </p>\n\n<p>What we do is set <code>M[x+1] = i</code> and <code>P[i] = M[x]</code> (which is identical to <code>P[M[x+1]] = M[x]</code>), which is to say that for every element <code>i</code> we add, we store <code>i</code> as the last element in the longest chain we can and we store the index of the last element of the chain we are extending in <code>P[i]</code>. So we have:</p>\n\n<pre><code>last element: seq[M[x]]\n before that: seq[P[M[x]]]\n before that: seq[P[P[M[x]]]]\n etc...\n</code></pre>\n\n<p>And now we are done. If you want to compare this to actual code, you can look at the <a href=\"https://stackoverflow.com/a/9832414/712765\">other</a> <a href=\"https://en.wikipedia.org/wiki/Longest_increasing_subsequence#Efficient_algorithms\" rel=\"nofollow noreferrer\">examples</a>. The main differences are they use <code>j</code> instead of <code>x</code>, may store the list of length <code>j</code> at <code>M[j-1]</code> instead of <code>M[j]</code> to avoid wasting the space at <code>M[0]</code>, and may call the input sequence <code>X</code> instead of <code>seq</code>.</p>\n"
                },
                {
                    "owner": {
                        "account_id": 8086591,
                        "reputation": 1897,
                        "user_id": 6093953,
                        "user_type": "registered",
                        "display_name": "Andrushenko Alexander"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 0,
                    "last_activity_date": 1550177932,
                    "last_edit_date": 1550177932,
                    "creation_date": 1550097488,
                    "answer_id": 54680542,
                    "question_id": 3992697,
                    "link": "https://stackoverflow.com/questions/3992697/longest-increasing-subsequence/54680542#54680542",
                    "body": "<p>Here is my C++ solution of the problem. The solution is simpler than all of the provided here so far, and it is fast: <code>N*log(N)</code> algorithmic time complexity. I submitted the solution at leetcode, it runs 4 ms, faster than 100% of C++ solutions submitted.</p>\n\n<p><a href=\"https://i.stack.imgur.com/feAO8.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/feAO8.png\" alt=\"enter image description here\"></a></p>\n\n<p>The idea is (in my opinion) clear: traverse the given array of numbers from left to right. Maintain additionally array of numbers (<code>seq</code> in my code), that holds increasing subsequence. When the taken number is bigger than all numbers that the subsequence holds, put it at the end of <code>seq</code> and increase the subsequence length counter by 1. When the number is smaller than the biggest number in the subsequence so far, put it anyway in <code>seq</code>, in the place where it belongs to keep the subsequence sorted by replacing some existing number. The subsequence is initialized with the length of the original numbers array and with initial value -inf, what means smallest int in the given OS.</p>\n\n<p>Example:</p>\n\n<p>numbers = { 10, 9, 2, 5, 3, 7, 101, 18 }</p>\n\n<p>seq = {-inf, -inf, -inf, -inf, -inf, -inf, -inf}</p>\n\n<p>here is how the sequence changes when we traverse the numbers from left to right:</p>\n\n<pre><code> seq = {10, -inf, -inf, -inf, -inf, -inf, -inf}\n seq = {9, -inf, -inf, -inf, -inf, -inf, -inf}\n seq = {2, -inf, -inf, -inf, -inf, -inf, -inf}\n seq = {2, 5, -inf, -inf, -inf, -inf, -inf}\n seq = {2, 3, -inf, -inf, -inf, -inf, -inf}\n seq = {2, 3, 7, -inf, -inf, -inf, -inf}\n seq = {2, 3, 7, 101, -inf, -inf, -inf}\n seq = {2, 3, 7, 18, -inf, -inf, -inf}\n</code></pre>\n\n<p>The longest increasing subsequence for the array has length 4.</p>\n\n<p>Here is the code:</p>\n\n<pre><code>int longestIncreasingSubsequence(const vector&lt;int&gt; &amp;numbers){\n    if (numbers.size() &lt; 2)\n        return numbers.size();\n    vector&lt;int&gt;seq(numbers.size(), numeric_limits&lt;int&gt;::min());\n    seq[0] = numbers[0];\n    int len = 1;\n    vector&lt;int&gt;::iterator end = next(seq.begin());\n    for (size_t i = 1; i &lt; numbers.size(); i++) {\n        auto pos = std::lower_bound(seq.begin(), end, numbers[i]);\n        if (pos == end) {\n            *end = numbers[i];\n            end = next(end);\n            len++;\n        }\n        else\n            *pos = numbers[i];\n    }\n    return len;\n}\n</code></pre>\n\n<p>Well, so far so good, but how do we know that the algorithm computes the length of the longest (or one of the longest, here may be several subsequences of the same size)  subsequence? Here is my proof: </p>\n\n<p>Let's assume that the algorithm does not computes length of the longest subsequence. Then in the original sequence must exist a number such that the algorithm misses and that would make the subsequence longer. Let's say, for a subsequence x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>n</sub> there exists a number y such that x<sub>k</sub> &lt; y &lt; x<sub>k+1</sub>, 1 &lt;= k &lt;= n. To contribute to the subsequence y must be located in the original sequence between x<sub>k</sub> and x<sub>k+1</sub>. But then we have contradiction: when the algorithm traverses original sequence from left to right, every time it meets a number bigger than any number in the current subsequence, it extends the subsequence by 1. By the time algorithm would meet such number y the subsequence would have length k and contain numbers x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>k</sub>. Because x<sub>k</sub> &lt; y, the algorithm would extend the subsequence by 1 and include y in the subsequence. The same logic applies when y is the smallest number of the subsequence and located to the left of x<sub>1</sub> or when y is the biggest number of the subsequence and located to the right of x<sub>n</sub>.\nConclusion: such number y does not exists and the algorithm computes the longest increasing subsequence. \nI hope that makes sense.</p>\n\n<p>In the final statement, I would like to mention that the algorithm can be easily generalized to compute longest decreasing subsequence as well, for any data types which elements can be ordered.\nThe idea is the same, here is the code:</p>\n\n<pre><code>template&lt;typename T, typename cmp = std::less&lt;T&gt;&gt;\nsize_t longestSubsequence(const vector&lt;T&gt; &amp;elements)\n{\n    if (elements.size() &lt; 2)\n        return elements.size();\n    vector&lt;T&gt;seq(elements.size(), T());\n    seq[0] = elements[0];\n    size_t len = 1;\n    auto end = next(seq.begin());\n    for (size_t i = 1; i &lt; elements.size(); i++) {\n        auto pos = std::lower_bound(seq.begin(), end, elements[i], cmp());\n        if (pos == end) {\n            *end = elements[i];\n            end = next(end);\n            len++;\n        }\n        else\n            *pos = elements[i];\n    }\n    return len;\n}\n</code></pre>\n\n<p>Examples of usage:</p>\n\n<pre><code>int main()\n{\n    vector&lt;int&gt; nums = { 0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15 };\n    size_t l = longestSubsequence&lt;int&gt;(nums); // l == 6 , longest increasing subsequence\n\n    nums = { 0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15 };\n    l = longestSubsequence&lt;int, std::greater&lt;int&gt;&gt;(nums); // l == 5, longest decreasing subsequence\n\n    vector&lt;string&gt; vstr = {\"b\", \"a\", \"d\", \"bc\", \"a\"};\n    l = longestSubsequence&lt;string&gt;(vstr); // l == 2, increasing\n\n\n    vstr = { \"b\", \"a\", \"d\", \"bc\", \"a\" };\n    l = longestSubsequence&lt;string, std::greater&lt;string&gt;&gt;(vstr); // l == 3, decreasing\n\n} \n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 13429277,
                        "reputation": 15,
                        "user_id": 9689551,
                        "user_type": "registered",
                        "display_name": "Goutham raju"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 0,
                    "last_activity_date": 1565845323,
                    "creation_date": 1565845323,
                    "answer_id": 57505046,
                    "question_id": 3992697,
                    "link": "https://stackoverflow.com/questions/3992697/longest-increasing-subsequence/57505046#57505046",
                    "body": "<pre><code>def longest_sub_seq(arr):\n    main_arr = []\n    sub_arr = []\n    n = len(arr)\n    for ind in range(n):\n        if ind &lt; n - 1 and arr[ind] &lt;= arr[ind+1]:\n           sub_arr.append(arr[ind])\n        else:\n           sub_arr.append(arr[ind])\n           main_arr.append(sub_arr)\n           sub_arr = []\n    return max(main_arr, key=len)\n\na = [3, 10, 3, 11, 4, 5, 6, 7, 8, 12, 1, 2, 3]\nprint(longest_sub_seq(a)) # op: [4, 5, 6, 7, 8, 12]\n</code></pre>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 342731,
                                "reputation": 351046,
                                "user_id": 674039,
                                "user_type": "registered",
                                "accept_rate": 94,
                                "display_name": "wim"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1633567515,
                            "post_id": 65266809,
                            "comment_id": 122796715,
                            "link": "https://stackoverflow.com/questions/3992697/longest-increasing-subsequence/65266809#comment122796715_65266809",
                            "body": "The question wants to find the sequence itself, not its length."
                        }
                    ],
                    "owner": {
                        "account_id": 8465416,
                        "reputation": 25579,
                        "user_id": 7365866,
                        "user_type": "registered",
                        "display_name": "Ben Butterworth"
                    },
                    "comment_count": 1,
                    "is_accepted": false,
                    "score": 0,
                    "last_activity_date": 1607795913,
                    "last_edit_date": 1607795913,
                    "creation_date": 1607787844,
                    "answer_id": 65266809,
                    "question_id": 3992697,
                    "link": "https://stackoverflow.com/questions/3992697/longest-increasing-subsequence/65266809#65266809",
                    "body": "<p><em>The verbosity and complexity of other solutions made me uneasy.</em></p>\n<h2>My python answer:</h2>\n<pre class=\"lang-py prettyprint-override\"><code>def findLIS(s):\n  lengths = [1] * len(s)\n  for i in range(1, len(s)):\n    for j in range(i):\n      if s[i] &gt; s[j] and lengths[i] &lt;= lengths[j]:\n        lengths[i] += 1\n  return max(lengths)\n</code></pre>\n<h2>FAQ</h2>\n<ol>\n<li>We initialize <code>lengths</code> list <code>[1, 1, 1, ..., 1]</code> because the worst case is the length of 1: <code>[5,4,3,2]</code> will have result lengths, <code>[1,1,1,1]</code>, and we can take max of that, i.e. 1.</li>\n<li><strong>Algorithm:</strong> for every number, we try to see if this new number can make the subsequence longer. The most <em>important</em> part is <code>if s[i] &gt; s[j] and lengths[i] &lt;= lengths[j]</code>: we ensure this new number is bigger and its best subsequence is <strong>not longer</strong>. If so, this is a good number to add to the old subsequnce.</li>\n<li>My answer actually gets the <strong>increasing subsequence</strong> length (the title of the question) which is actually different to <strong>non-decreasing</strong> length (the question description). If you want to get the longest <strong>non-decreasing</strong> subsequence length, then just change <code>s[i] &gt; s[j]</code> to <code>s[i] &gt;= s[j]</code>.</li>\n</ol>\n"
                }
            ],
            "owner": {
                "account_id": 171685,
                "reputation": 7258,
                "user_id": 399268,
                "user_type": "registered",
                "accept_rate": 90,
                "display_name": "Jungle Hunter"
            },
            "comment_count": 1,
            "is_answered": true,
            "accepted_answer_id": 9832414,
            "answer_count": 13,
            "score": 35,
            "last_activity_date": 1633567181,
            "creation_date": 1287702257,
            "last_edit_date": 1633567181,
            "question_id": 3992697,
            "link": "https://stackoverflow.com/questions/3992697/longest-increasing-subsequence",
            "title": "Longest increasing subsequence",
            "body": "<p>Given an input sequence, what is the best way to find the longest (not necessarily continuous) increasing subsequence</p>\n<pre><code>[0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]  # input\n\n[1, 9, 13, 15]  # an example of an increasing subsequence (not the longest)\n\n[0, 2, 6, 9, 13, 15]  # longest increasing subsequence (not a unique answer)\n[0, 2, 6, 9, 11, 15]  # another possible solution\n</code></pre>\n<p>I'm looking for the best algorithm. If there is code, Python would be nice, but anything is alright.</p>\n"
        }
    ],
    "has_more": false,
    "quota_max": 10000,
    "quota_remaining": 9829
}