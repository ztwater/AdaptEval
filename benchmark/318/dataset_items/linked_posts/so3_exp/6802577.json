{
    "items": [
        {
            "tags": [
                "python",
                "vector",
                "rotation"
            ],
            "comments": [
                {
                    "owner": {
                        "account_id": 380806,
                        "reputation": 5770,
                        "user_id": 735070,
                        "user_type": "registered",
                        "accept_rate": 68,
                        "display_name": "Mads Skjern"
                    },
                    "edited": false,
                    "score": 17,
                    "creation_date": 1311450699,
                    "post_id": 6802577,
                    "comment_id": 8076790,
                    "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector#comment8076790_6802577",
                    "body": "I find it very surprising that there is no functionality for this in SciPy (or similar easily accessible package); vector rotation isn&#39;t that exotic."
                },
                {
                    "owner": {
                        "account_id": 5300934,
                        "reputation": 5546,
                        "user_id": 4230591,
                        "user_type": "registered",
                        "accept_rate": 61,
                        "display_name": "user"
                    },
                    "edited": false,
                    "score": 7,
                    "creation_date": 1562775169,
                    "post_id": 6802577,
                    "comment_id": 100485720,
                    "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector#comment100485720_6802577",
                    "body": "Now there is: <a href=\"https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.transform.Rotation.from_rotvec.html#scipy.spatial.transform.Rotation.from_rotvec\" rel=\"nofollow noreferrer\">scipy.spatial.transform.Rotation.from_rotvec</a>"
                }
            ],
            "answers": [
                {
                    "owner": {
                        "account_id": 234440,
                        "reputation": 174323,
                        "user_id": 500584,
                        "user_type": "registered",
                        "display_name": "agf"
                    },
                    "comment_count": 0,
                    "is_accepted": true,
                    "score": 13,
                    "last_activity_date": 1311448422,
                    "creation_date": 1311448422,
                    "answer_id": 6802682,
                    "question_id": 6802577,
                    "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/6802682#6802682",
                    "body": "<p>Take a look at <a href=\"http://vpython.org/contents/docs/visual/VisualIntro.html\" rel=\"noreferrer\">http://vpython.org/contents/docs/visual/VisualIntro.html</a>. </p>\n\n<p>It provides a <code>vector</code> class which has a method <code>A.rotate(theta,B)</code>. It also provides a helper function <code>rotate(A,theta,B)</code> if you don't want to call the method on <code>A</code>.</p>\n\n<p><a href=\"http://vpython.org/contents/docs/visual/vector.html\" rel=\"noreferrer\">http://vpython.org/contents/docs/visual/vector.html</a></p>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 64585,
                                "reputation": 864612,
                                "user_id": 190597,
                                "user_type": "registered",
                                "accept_rate": 88,
                                "display_name": "unutbu"
                            },
                            "edited": false,
                            "score": 8,
                            "creation_date": 1349787116,
                            "post_id": 6802723,
                            "comment_id": 17308678,
                            "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/6802723#comment17308678_6802723",
                            "body": "@bougui: Using <code>np.linalg.norm</code> instead of <code>np.sqrt(np.dot(...))</code> seemed like a nice improvement to me, but <code>timeit</code> tests showed <code>np.sqrt(np.dot(...))</code> was 2.5x faster than <code>np.linalg.norm</code>, at least on my machine, so I&#39;m sticking with <code>np.sqrt(np.dot(...))</code>."
                        },
                        {
                            "owner": {
                                "account_id": 55665,
                                "reputation": 359902,
                                "user_id": 166749,
                                "user_type": "registered",
                                "accept_rate": 94,
                                "display_name": "Fred Foo"
                            },
                            "edited": false,
                            "score": 3,
                            "creation_date": 1388325272,
                            "post_id": 6802723,
                            "comment_id": 31230833,
                            "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/6802723#comment31230833_6802723",
                            "body": "<code>sqrt</code> from the Python <code>math</code> module is even faster on scalars. <code>scipy.linalg.norm</code> may be faster than <code>np.linalg.norm</code>; I&#39;ve submitted a patch to NumPy that changes <code>linalg.norm</code> to use <code>dot</code>, but it hasn&#39;t been merged yet."
                        },
                        {
                            "owner": {
                                "account_id": 64585,
                                "reputation": 864612,
                                "user_id": 190597,
                                "user_type": "registered",
                                "accept_rate": 88,
                                "display_name": "unutbu"
                            },
                            "reply_to_user": {
                                "account_id": 55665,
                                "reputation": 359902,
                                "user_id": 166749,
                                "user_type": "registered",
                                "accept_rate": 94,
                                "display_name": "Fred Foo"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1388326632,
                            "post_id": 6802723,
                            "comment_id": 31231187,
                            "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/6802723#comment31231187_6802723",
                            "body": "@larsman: Thanks for the info. I didn&#39;t know <code>math.sqrt</code> is (at the moment) so much faster than <code>np.sqrt</code> on scalars (about 18x on my machine)."
                        },
                        {
                            "owner": {
                                "account_id": 64585,
                                "reputation": 864612,
                                "user_id": 190597,
                                "user_type": "registered",
                                "accept_rate": 88,
                                "display_name": "unutbu"
                            },
                            "reply_to_user": {
                                "account_id": 55665,
                                "reputation": 359902,
                                "user_id": 166749,
                                "user_type": "registered",
                                "accept_rate": 94,
                                "display_name": "Fred Foo"
                            },
                            "edited": false,
                            "score": 3,
                            "creation_date": 1388327339,
                            "post_id": 6802723,
                            "comment_id": 31231396,
                            "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/6802723#comment31231396_6802723",
                            "body": "I suppose <code>math.sqrt</code> will always be faster than <code>np.sqrt</code> when operating on scalars since <code>np.sqrt</code>&#39;s overall performance would be slowed if it had to check its input for scalars."
                        },
                        {
                            "owner": {
                                "user_type": "does_not_exist",
                                "display_name": "user6039682"
                            },
                            "edited": false,
                            "score": 1,
                            "creation_date": 1463581985,
                            "post_id": 6802723,
                            "comment_id": 62127250,
                            "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/6802723#comment62127250_6802723",
                            "body": "This is very neat, would you be so kind to add the equivalent for 2D? I know that for rotating w.r.t OX axis we can just compute new coords as: <code>(x*np.cos(theta)-y*np.sin(theta), x*np.sin(theta)+y*np.cos(theta))</code>, but how should this be modified when the axis of rotation is not OX any longer? thanks for any tips."
                        },
                        {
                            "owner": {
                                "account_id": 10308422,
                                "reputation": 264,
                                "user_id": 7604975,
                                "user_type": "registered",
                                "display_name": "TomK"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1537091711,
                            "post_id": 6802723,
                            "comment_id": 91650780,
                            "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/6802723#comment91650780_6802723",
                            "body": "nice solution,   it looks like the point of  rotation is [0,0,0],  what  do I need  to do,  if  I want  to change  to point of rotation?"
                        },
                        {
                            "owner": {
                                "account_id": 64585,
                                "reputation": 864612,
                                "user_id": 190597,
                                "user_type": "registered",
                                "accept_rate": 88,
                                "display_name": "unutbu"
                            },
                            "reply_to_user": {
                                "account_id": 10308422,
                                "reputation": 264,
                                "user_id": 7604975,
                                "user_type": "registered",
                                "display_name": "TomK"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1537100185,
                            "post_id": 6802723,
                            "comment_id": 91652690,
                            "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/6802723#comment91652690_6802723",
                            "body": "@TomK: To rotate around an arbitrary point <code>P</code>, shift all points so that <code>P</code> is moved to the origin, rotate about the origin, then shift all points so that the origin is moved back to <code>P</code>. For example, to rotate point <code>M</code> about <code>P</code>, you would calculate <code>R(M-P) + P</code>, where <code>R</code> is the rotation matrix."
                        },
                        {
                            "owner": {
                                "account_id": 8733842,
                                "reputation": 1074,
                                "user_id": 6533075,
                                "user_type": "registered",
                                "accept_rate": 92,
                                "display_name": "Sch&#252;tze"
                            },
                            "edited": false,
                            "score": 1,
                            "creation_date": 1562081079,
                            "post_id": 6802723,
                            "comment_id": 100261493,
                            "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/6802723#comment100261493_6802723",
                            "body": "Shouldn&#39;t axis be x, y or z? What&#39;s that vector?"
                        },
                        {
                            "owner": {
                                "account_id": 244067,
                                "reputation": 449,
                                "user_id": 2556682,
                                "user_type": "registered",
                                "display_name": "Harold Cooper"
                            },
                            "reply_to_user": {
                                "account_id": 8733842,
                                "reputation": 1074,
                                "user_id": 6533075,
                                "user_type": "registered",
                                "accept_rate": 92,
                                "display_name": "Sch&#252;tze"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1650332603,
                            "post_id": 6802723,
                            "comment_id": 127084531,
                            "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/6802723#comment127084531_6802723",
                            "body": "@Sch&#252;tze 3d rotations can be around any vector, not just the three cartesian axes. So if you want to rotate about the x-axis, you&#39;d just use axis=[1,0,0]\u2014and similar for y and z."
                        }
                    ],
                    "owner": {
                        "account_id": 64585,
                        "reputation": 864612,
                        "user_id": 190597,
                        "user_type": "registered",
                        "accept_rate": 88,
                        "display_name": "unutbu"
                    },
                    "comment_count": 9,
                    "is_accepted": false,
                    "score": 135,
                    "last_activity_date": 1533210472,
                    "last_edit_date": 1533210472,
                    "creation_date": 1311448852,
                    "answer_id": 6802723,
                    "question_id": 6802577,
                    "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/6802723#6802723",
                    "body": "<p>Using the <a href=\"http://en.wikipedia.org/wiki/Euler%E2%80%93Rodrigues_parameters\" rel=\"noreferrer\">Euler-Rodrigues formula</a>:</p>\n\n<pre><code>import numpy as np\nimport math\n\ndef rotation_matrix(axis, theta):\n    \"\"\"\n    Return the rotation matrix associated with counterclockwise rotation about\n    the given axis by theta radians.\n    \"\"\"\n    axis = np.asarray(axis)\n    axis = axis / math.sqrt(np.dot(axis, axis))\n    a = math.cos(theta / 2.0)\n    b, c, d = -axis * math.sin(theta / 2.0)\n    aa, bb, cc, dd = a * a, b * b, c * c, d * d\n    bc, ad, ac, ab, bd, cd = b * c, a * d, a * c, a * b, b * d, c * d\n    return np.array([[aa + bb - cc - dd, 2 * (bc + ad), 2 * (bd - ac)],\n                     [2 * (bc - ad), aa + cc - bb - dd, 2 * (cd + ab)],\n                     [2 * (bd + ac), 2 * (cd - ab), aa + dd - bb - cc]])\n\nv = [3, 5, 0]\naxis = [4, 4, 1]\ntheta = 1.2 \n\nprint(np.dot(rotation_matrix(axis, theta), v)) \n# [ 2.74911638  4.77180932  1.91629719]\n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 484038,
                        "reputation": 6472,
                        "user_id": 899470,
                        "user_type": "registered",
                        "accept_rate": 67,
                        "display_name": "juniper-"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 22,
                    "last_activity_date": 1346753411,
                    "creation_date": 1346753411,
                    "answer_id": 12261243,
                    "question_id": 6802577,
                    "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/12261243#12261243",
                    "body": "<p>I just wanted to mention that if speed is required, wrapping unutbu's code in scipy's weave.inline and passing an already existing matrix as a parameter yields a 20-fold decrease in the running time.</p>\n\n<p>The code (in rotation_matrix_test.py):</p>\n\n<pre><code>import numpy as np\nimport timeit\n\nfrom math import cos, sin, sqrt\nimport numpy.random as nr\n\nfrom scipy import weave\n\ndef rotation_matrix_weave(axis, theta, mat = None):\n    if mat == None:\n        mat = np.eye(3,3)\n\n    support = \"#include &lt;math.h&gt;\"\n    code = \"\"\"\n        double x = sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);\n        double a = cos(theta / 2.0);\n        double b = -(axis[0] / x) * sin(theta / 2.0);\n        double c = -(axis[1] / x) * sin(theta / 2.0);\n        double d = -(axis[2] / x) * sin(theta / 2.0);\n\n        mat[0] = a*a + b*b - c*c - d*d;\n        mat[1] = 2 * (b*c - a*d);\n        mat[2] = 2 * (b*d + a*c);\n\n        mat[3*1 + 0] = 2*(b*c+a*d);\n        mat[3*1 + 1] = a*a+c*c-b*b-d*d;\n        mat[3*1 + 2] = 2*(c*d-a*b);\n\n        mat[3*2 + 0] = 2*(b*d-a*c);\n        mat[3*2 + 1] = 2*(c*d+a*b);\n        mat[3*2 + 2] = a*a+d*d-b*b-c*c;\n    \"\"\"\n\n    weave.inline(code, ['axis', 'theta', 'mat'], support_code = support, libraries = ['m'])\n\n    return mat\n\ndef rotation_matrix_numpy(axis, theta):\n    mat = np.eye(3,3)\n    axis = axis/sqrt(np.dot(axis, axis))\n    a = cos(theta/2.)\n    b, c, d = -axis*sin(theta/2.)\n\n    return np.array([[a*a+b*b-c*c-d*d, 2*(b*c-a*d), 2*(b*d+a*c)],\n                  [2*(b*c+a*d), a*a+c*c-b*b-d*d, 2*(c*d-a*b)],\n                  [2*(b*d-a*c), 2*(c*d+a*b), a*a+d*d-b*b-c*c]])\n</code></pre>\n\n<p>The timing:</p>\n\n<pre><code>&gt;&gt;&gt; import timeit\n&gt;&gt;&gt; \n&gt;&gt;&gt; setup = \"\"\"\n... import numpy as np\n... import numpy.random as nr\n... \n... from rotation_matrix_test import rotation_matrix_weave\n... from rotation_matrix_test import rotation_matrix_numpy\n... \n... mat1 = np.eye(3,3)\n... theta = nr.random()\n... axis = nr.random(3)\n... \"\"\"\n&gt;&gt;&gt; \n&gt;&gt;&gt; timeit.repeat(\"rotation_matrix_weave(axis, theta, mat1)\", setup=setup, number=100000)\n[0.36641597747802734, 0.34883809089660645, 0.3459300994873047]\n&gt;&gt;&gt; timeit.repeat(\"rotation_matrix_numpy(axis, theta)\", setup=setup, number=100000)\n[7.180983066558838, 7.172032117843628, 7.180462837219238]\n</code></pre>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 2579280,
                                "reputation": 435,
                                "user_id": 2236315,
                                "user_type": "registered",
                                "accept_rate": 20,
                                "display_name": "ximiki"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1532987585,
                            "post_id": 25709323,
                            "comment_id": 90171521,
                            "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/25709323#comment90171521_25709323",
                            "body": "What is the reference for the quote &quot;let a be... then M = exp(\u03b8 A) is the rotation matrix.&quot; ?"
                        },
                        {
                            "owner": {
                                "account_id": 2579280,
                                "reputation": 435,
                                "user_id": 2236315,
                                "user_type": "registered",
                                "accept_rate": 20,
                                "display_name": "ximiki"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1533510836,
                            "post_id": 25709323,
                            "comment_id": 90359302,
                            "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/25709323#comment90359302_25709323",
                            "body": "Thanks. This Wikipedia page (<a href=\"https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula#Matrix_notation\" rel=\"nofollow noreferrer\">en.wikipedia.org/wiki/&hellip;</a>) is also useful. Last question: could you explain how <code>cross(eye(3), axis&#47;norm(axis)*theta)</code> get you the &quot;cross-product matrix&quot;?"
                        }
                    ],
                    "owner": {
                        "account_id": 4995557,
                        "reputation": 18488,
                        "user_id": 4016285,
                        "user_type": "registered",
                        "accept_rate": 100,
                        "display_name": "B. M."
                    },
                    "comment_count": 2,
                    "is_accepted": false,
                    "score": 57,
                    "last_activity_date": 1537979123,
                    "last_edit_date": 1537979123,
                    "creation_date": 1410086262,
                    "answer_id": 25709323,
                    "question_id": 6802577,
                    "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/25709323#25709323",
                    "body": "<p>A one-liner, with numpy/scipy functions.</p>\n\n<p>We use the following:</p>\n\n<blockquote>\n  <p>let <em>a</em> be the unit vector along <em>axis</em>, i.e. <em>a = axis/norm(axis)</em><br>\n  and <em>A = I \u00d7 a</em> be the skew-symmetric matrix associated to <em>a</em>, i.e. the cross product of the identity matrix with <em>a</em> </p>\n  \n  <p>then <em>M = exp(\u03b8 A)</em> is the rotation matrix.</p>\n</blockquote>\n\n<pre><code>from numpy import cross, eye, dot\nfrom scipy.linalg import expm, norm\n\ndef M(axis, theta):\n    return expm(cross(eye(3), axis/norm(axis)*theta))\n\nv, axis, theta = [3,5,0], [4,4,1], 1.2\nM0 = M(axis, theta)\n\nprint(dot(M0,v))\n# [ 2.74911638  4.77180932  1.91629719]\n</code></pre>\n\n<p><code>expm</code> <a href=\"https://github.com/scipy/scipy/blob/v1.1.0/scipy/linalg/matfuncs.py#L211\" rel=\"noreferrer\">(code here)</a> computes the taylor series of the exponential:<br>\n<code>\\sum_{k=0}^{20} \\frac{1}{k!} (\u03b8 A)^k</code>\n, so it's time expensive, but readable and secure.\nIt can be a good way if you have few rotations to do but a lot of vectors.</p>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 2811537,
                                "reputation": 3074,
                                "user_id": 2809008,
                                "user_type": "registered",
                                "display_name": "ljetibo"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1485195019,
                            "post_id": 32647041,
                            "comment_id": 70813720,
                            "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/32647041#comment70813720_32647041",
                            "body": "I know this is very weird but I can&#39;t find a different way of contacting you. Would it be possible to use the math3d library to create 2D projections of 3D functions over an arbitrary axis more easily? For example, imagine projecting a normal distribution on the xy plane from the z axis. Now Imagine moving by the polar angle theta away from the z axis (as in spherical coord. notation) and projecting the normal dist on a plane that is also now rotated by theta in reference to xy? It&#39;s like orthogonal projection + integration. I can open a new question for this if you want."
                        },
                        {
                            "owner": {
                                "account_id": 3329019,
                                "reputation": 103,
                                "user_id": 2798358,
                                "user_type": "registered",
                                "display_name": "Morten Lind"
                            },
                            "reply_to_user": {
                                "account_id": 2811537,
                                "reputation": 3074,
                                "user_id": 2809008,
                                "user_type": "registered",
                                "display_name": "ljetibo"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1485288649,
                            "post_id": 32647041,
                            "comment_id": 70861462,
                            "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/32647041#comment70861462_32647041",
                            "body": "Hi, ljetbo, I think this sounds difficult, or just not very easy with math3d. The function would imply, I guess, an analytical function, whereas math3d works better with point sets. Further, you seem to be talking about a scalar field over the plane (R(2)), whereas math3d deals with the Special Euclidean group (SE+(3)). It may be possible to do what you wish, but I have no immediate idea about how to mix in an analytical function with math3d."
                        }
                    ],
                    "owner": {
                        "account_id": 3329019,
                        "reputation": 103,
                        "user_id": 2798358,
                        "user_type": "registered",
                        "display_name": "Morten Lind"
                    },
                    "comment_count": 2,
                    "is_accepted": false,
                    "score": 9,
                    "last_activity_date": 1442572091,
                    "last_edit_date": 1442572091,
                    "creation_date": 1442563999,
                    "answer_id": 32647041,
                    "question_id": 6802577,
                    "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/32647041#32647041",
                    "body": "<p>I made a fairly complete library of 3D mathematics for Python{2,3}. It still does not use Cython, but relies heavily on the efficiency of numpy. You can find it here with pip:</p>\n\n<pre><code>python[3] -m pip install math3d\n</code></pre>\n\n<p>Or have a look at my gitweb <a href=\"http://git.automatics.dyndns.dk/?p=pymath3d.git\" rel=\"noreferrer\">http://git.automatics.dyndns.dk/?p=pymath3d.git</a>  and now also on github: <a href=\"https://github.com/mortlind/pymath3d\" rel=\"noreferrer\">https://github.com/mortlind/pymath3d</a> .</p>\n\n<p>Once installed, in python you may create the orientation object which can rotate vectors, or be part of transform objects. E.g. the following code snippet composes an orientation that represents a rotation of 1 rad around the axis [1,2,3], applies it to the vector [4,5,6], and prints the result:</p>\n\n<pre><code>import math3d as m3d\nr = m3d.Orientation.new_axis_angle([1,2,3], 1)\nv = m3d.Vector(4,5,6)\nprint(r * v)\n</code></pre>\n\n<p>The output would be</p>\n\n<pre><code>&lt;Vector: (2.53727, 6.15234, 5.71935)&gt;\n</code></pre>\n\n<p>This is more efficient, by a factor of approximately four, as far as I can time it, than the oneliner using scipy posted by B. M. above. However, it requires installation of my math3d package.</p>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 4450355,
                                "reputation": 135,
                                "user_id": 3622450,
                                "user_type": "registered",
                                "display_name": "user3622450"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1550325924,
                            "post_id": 44729925,
                            "comment_id": 96231858,
                            "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/44729925#comment96231858_44729925",
                            "body": "Surprisingly, <code>np.conjugate(q)</code> seems to take longer than <code>np.exp(qlog)</code> despite it seems equivalent to just <code>quat.quaternion(q.real, *(-q.imag))</code>"
                        },
                        {
                            "owner": {
                                "account_id": 18053922,
                                "reputation": 209,
                                "user_id": 13122890,
                                "user_type": "registered",
                                "display_name": "Lucy"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1606228901,
                            "post_id": 44729925,
                            "comment_id": 114895949,
                            "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/44729925#comment114895949_44729925",
                            "body": "I understand this is an old thread, but I have a question about the implementation of this method here if anyone is able to take a look: <a href=\"https://stackoverflow.com/questions/64988678/applying-quaternion-rotation-to-a-vector-time-series\" title=\"applying quaternion rotation to a vector time series\">stackoverflow.com/questions/64988678/&hellip;</a>"
                        }
                    ],
                    "owner": {
                        "account_id": 11182991,
                        "reputation": 449,
                        "user_id": 8206402,
                        "user_type": "registered",
                        "display_name": "henneray"
                    },
                    "comment_count": 2,
                    "is_accepted": false,
                    "score": 17,
                    "last_activity_date": 1534661364,
                    "last_edit_date": 1534661364,
                    "creation_date": 1498251962,
                    "answer_id": 44729925,
                    "question_id": 6802577,
                    "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/44729925#44729925",
                    "body": "<p>Here is an elegant method using quaternions that are blazingly fast; I can calculate 10 million rotations per second with appropriately vectorised numpy arrays. It relies on the quaternion extension to numpy found <a href=\"https://pypi.python.org/pypi/numpy-quaternion\" rel=\"noreferrer\">here</a>.</p>\n\n<p>Quaternion Theory:\nA quaternion is a number with one real and 3 imaginary dimensions usually written as <code>q = w + xi + yj + zk</code> where 'i', 'j', 'k' are imaginary dimensions. Just as a unit complex number 'c' can represent all 2d rotations by <code>c=exp(i * theta)</code>, a unit quaternion 'q' can represent all 3d rotations by <code>q=exp(p)</code>, where 'p' is a pure imaginary quaternion set by your axis and angle.</p>\n\n<p>We start by converting your axis and angle to a quaternion whose imaginary dimensions are given by your axis of rotation, and whose magnitude is given by half the angle of rotation in radians. The 4 element vectors <code>(w, x, y, z)</code> are constructed as follows:</p>\n\n<pre><code>import numpy as np\nimport quaternion as quat\n\nv = [3,5,0]\naxis = [4,4,1]\ntheta = 1.2 #radian\n\nvector = np.array([0.] + v)\nrot_axis = np.array([0.] + axis)\naxis_angle = (theta*0.5) * rot_axis/np.linalg.norm(rot_axis)\n</code></pre>\n\n<p>First, a numpy array of 4 elements is constructed with the real component w=0  for both the vector to be rotated <code>vector</code> and the rotation axis <code>rot_axis</code>. The axis angle representation is then constructed by normalizing then multiplying by half the desired angle <code>theta</code>. See <a href=\"https://math.stackexchange.com/questions/1385028/concise-description-of-why-rotation-quaternions-use-half-the-angle\">here</a> for why half the angle is required.</p>\n\n<p>Now create the quaternions <code>v</code> and <code>qlog</code> using the library, and get the unit rotation quaternion <code>q</code> by taking the exponential.</p>\n\n<pre><code>vec = quat.quaternion(*v)\nqlog = quat.quaternion(*axis_angle)\nq = np.exp(qlog)\n</code></pre>\n\n<p>Finally, the rotation of the vector is calculated by the following operation.</p>\n\n<pre><code>v_prime = q * vec * np.conjugate(q)\n\nprint(v_prime) # quaternion(0.0, 2.7491163, 4.7718093, 1.9162971)\n</code></pre>\n\n<p>Now just discard the real element and you have your rotated vector! </p>\n\n<pre><code>v_prime_vec = v_prime.imag #\u00a0[2.74911638 4.77180932 1.91629719] as a numpy array\n</code></pre>\n\n<p>Note that this method is particularly efficient if you have to rotate a vector through many sequential rotations, as the quaternion product can just be calculated as q = q1 * q2 * q3 * q4 * ... * qn and then the vector is only rotated by 'q' at the very end using v' = q * v * conj(q).</p>\n\n<p>This method gives you a seamless transformation between axis angle &lt;---> 3d rotation operator simply by <code>exp</code> and <code>log</code> functions (yes <code>log(q)</code> just returns the axis-angle representation!). For further clarification of how quaternion multiplication etc. work, see <a href=\"https://stackoverflow.com/questions/4870393/rotating-coordinate-system-via-a-quaternion\">here</a></p>\n"
                },
                {
                    "owner": {
                        "account_id": 7677771,
                        "reputation": 741,
                        "user_id": 5818055,
                        "user_type": "registered",
                        "display_name": "Dr.PP"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 3,
                    "last_activity_date": 1562940758,
                    "last_edit_date": 1562940758,
                    "creation_date": 1504680531,
                    "answer_id": 46068567,
                    "question_id": 6802577,
                    "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/46068567#46068567",
                    "body": "<p>Using pyquaternion is extremely simple; to install it (while still in python), run in your console:</p>\n\n<pre><code>import pip;\npip.main(['install','pyquaternion'])\n</code></pre>\n\n<p>Once installed:</p>\n\n<pre><code>  from pyquaternion import Quaternion\n  v = [3,5,0]\n  axis = [4,4,1]\n  theta = 1.2 #radian\n  rotated_v = Quaternion(axis=axis,angle=theta).rotate(v)\n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 2667463,
                        "reputation": 2820,
                        "user_id": 2305545,
                        "user_type": "registered",
                        "accept_rate": 69,
                        "display_name": "NOhs"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 2,
                    "last_activity_date": 1554847035,
                    "last_edit_date": 1554847035,
                    "creation_date": 1517685924,
                    "answer_id": 48601145,
                    "question_id": 6802577,
                    "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/48601145#48601145",
                    "body": "<p>Disclaimer: I am the author of this package</p>\n\n<p>While special classes for rotations can be convenient, in some cases one needs rotation matrices (e.g. for working with other libraries like the affine_transform functions in scipy). To avoid everyone implementing their own little matrix generating functions, there exists a tiny pure python package which does nothing more than providing convenient rotation matrix generating functions. The package is on github (<a href=\"https://github.com/NOhs/mgen\" rel=\"nofollow noreferrer\">mgen</a>) and can be installed via pip:</p>\n\n<pre><code>pip install mgen\n</code></pre>\n\n<p>Example usage copied from the readme:</p>\n\n<pre><code>import numpy as np\nnp.set_printoptions(suppress=True)\n\nfrom mgen import rotation_around_axis\nfrom mgen import rotation_from_angles\nfrom mgen import rotation_around_x\n\nmatrix = rotation_from_angles([np.pi/2, 0, 0], 'XYX')\nmatrix.dot([0, 1, 0])\n# array([0., 0., 1.])\n\nmatrix = rotation_around_axis([1, 0, 0], np.pi/2)\nmatrix.dot([0, 1, 0])\n# array([0., 0., 1.])\n\nmatrix = rotation_around_x(np.pi/2)\nmatrix.dot([0, 1, 0])\n# array([0., 0., 1.])\n</code></pre>\n\n<p>Note that the matrices are just regular numpy arrays, so no new data-structures are introduced when using this package.</p>\n"
                },
                {
                    "owner": {
                        "account_id": 1914531,
                        "reputation": 26686,
                        "user_id": 1727392,
                        "user_type": "registered",
                        "accept_rate": 91,
                        "display_name": "duhaime"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 1,
                    "last_activity_date": 1552137040,
                    "creation_date": 1552137040,
                    "answer_id": 55077682,
                    "question_id": 6802577,
                    "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/55077682#55077682",
                    "body": "<p>I needed to rotate a 3D model around one of the three axes {x, y, z} in which that model was embedded and this was the top result for a search of how to do this in numpy. I used the following simple function:</p>\n\n<pre><code>def rotate(X, theta, axis='x'):\n  '''Rotate multidimensional array `X` `theta` degrees around axis `axis`'''\n  c, s = np.cos(theta), np.sin(theta)\n  if axis == 'x': return np.dot(X, np.array([\n    [1.,  0,  0],\n    [0 ,  c, -s],\n    [0 ,  s,  c]\n  ]))\n  elif axis == 'y': return np.dot(X, np.array([\n    [c,  0,  -s],\n    [0,  1,   0],\n    [s,  0,   c]\n  ]))\n  elif axis == 'z': return np.dot(X, np.array([\n    [c, -s,  0 ],\n    [s,  c,  0 ],\n    [0,  0,  1.],\n  ]))\n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 14899950,
                        "reputation": 163,
                        "user_id": 10759078,
                        "user_type": "registered",
                        "display_name": "Guillaume Mougeot"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 3,
                    "last_activity_date": 1561884925,
                    "creation_date": 1561884925,
                    "answer_id": 56823599,
                    "question_id": 6802577,
                    "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/56823599#56823599",
                    "body": "<p>It can also be solved using quaternion theory:</p>\n\n<pre><code>def angle_axis_quat(theta, axis):\n    \"\"\"\n    Given an angle and an axis, it returns a quaternion.\n    \"\"\"\n    axis = np.array(axis) / np.linalg.norm(axis)\n    return np.append([np.cos(theta/2)],np.sin(theta/2) * axis)\n\ndef mult_quat(q1, q2):\n    \"\"\"\n    Quaternion multiplication.\n    \"\"\"\n    q3 = np.copy(q1)\n    q3[0] = q1[0]*q2[0] - q1[1]*q2[1] - q1[2]*q2[2] - q1[3]*q2[3]\n    q3[1] = q1[0]*q2[1] + q1[1]*q2[0] + q1[2]*q2[3] - q1[3]*q2[2]\n    q3[2] = q1[0]*q2[2] - q1[1]*q2[3] + q1[2]*q2[0] + q1[3]*q2[1]\n    q3[3] = q1[0]*q2[3] + q1[1]*q2[2] - q1[2]*q2[1] + q1[3]*q2[0]\n    return q3\n\ndef rotate_quat(quat, vect):\n    \"\"\"\n    Rotate a vector with the rotation defined by a quaternion.\n    \"\"\"\n    # Transfrom vect into an quaternion \n    vect = np.append([0],vect)\n    # Normalize it\n    norm_vect = np.linalg.norm(vect)\n    vect = vect/norm_vect\n    # Computes the conjugate of quat\n    quat_ = np.append(quat[0],-quat[1:])\n    # The result is given by: quat * vect * quat_\n    res = mult_quat(quat, mult_quat(vect,quat_)) * norm_vect\n    return res[1:]\n\nv = [3, 5, 0]\naxis = [4, 4, 1]\ntheta = 1.2 \n\nprint(rotate_quat(angle_axis_quat(theta, axis), v))\n# [2.74911638 4.77180932 1.91629719]\n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 5300934,
                        "reputation": 5546,
                        "user_id": 4230591,
                        "user_type": "registered",
                        "accept_rate": 61,
                        "display_name": "user"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 13,
                    "last_activity_date": 1562776593,
                    "last_edit_date": 1562776593,
                    "creation_date": 1562774213,
                    "answer_id": 56974519,
                    "question_id": 6802577,
                    "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector/56974519#56974519",
                    "body": "<p>Use scipy's <a href=\"https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.transform.Rotation.from_rotvec.html#scipy.spatial.transform.Rotation.from_rotvec\" rel=\"noreferrer\"><code>Rotation.from_rotvec()</code></a>. The argument is the rotation vector (a unit vector) multiplied by the rotation angle in rads.</p>\n\n<pre><code>from scipy.spatial.transform import Rotation\nfrom numpy.linalg import norm\n\n\nv = [3, 5, 0]\naxis = [4, 4, 1]\ntheta = 1.2\n\naxis = axis / norm(axis)  # normalize the rotation vector first\nrot = Rotation.from_rotvec(theta * axis)\n\nnew_v = rot.apply(v)  \nprint(new_v)    # results in [2.74911638 4.77180932 1.91629719]\n</code></pre>\n\n<p>There are several more ways to use <a href=\"https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.transform.Rotation.html#scipy.spatial.transform.Rotation\" rel=\"noreferrer\"><code>Rotation</code></a> based on what data you have about the rotation:</p>\n\n<ul>\n<li><p><a href=\"https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.transform.Rotation.from_quat.html#scipy.spatial.transform.Rotation.from_quat\" rel=\"noreferrer\"><code>from_quat</code></a> Initialized from quaternions.</p></li>\n<li><p><a href=\"https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.transform.Rotation.from_dcm.html#scipy.spatial.transform.Rotation.from_dcm\" rel=\"noreferrer\"><code>from_dcm</code></a> Initialized from direction cosine matrices.</p></li>\n<li><p><a href=\"https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.transform.Rotation.from_euler.html#scipy.spatial.transform.Rotation.from_euler\" rel=\"noreferrer\"><code>from_euler</code></a> Initialized from Euler angles.</p></li>\n</ul>\n\n<hr>\n\n<p><sub><strong>Off-topic note:</strong> One line code is <em>not</em> necessarily better code as implied by some users. </sub></p>\n"
                }
            ],
            "owner": {
                "account_id": 380806,
                "reputation": 5770,
                "user_id": 735070,
                "user_type": "registered",
                "accept_rate": 68,
                "display_name": "Mads Skjern"
            },
            "comment_count": 2,
            "is_answered": true,
            "accepted_answer_id": 6802682,
            "answer_count": 11,
            "score": 88,
            "last_activity_date": 1698849808,
            "creation_date": 1311447453,
            "last_edit_date": 1698849808,
            "question_id": 6802577,
            "link": "https://stackoverflow.com/questions/6802577/rotation-of-3d-vector",
            "title": "Rotation of 3D vector?",
            "body": "<p>I have two vectors as Python lists and an angle. E.g.:</p>\n<pre><code>v = [3, 5, 0]\naxis = [4, 4, 1]\ntheta = 1.2  # In radians.\n</code></pre>\n<p>What is the best/easiest way to get the resulting vector when rotating the <code>v</code> vector around the <code>axis</code>?</p>\n<p>The rotation should appear to be counter clockwise for an observer to whom the <code>axis</code> vector is pointing. This is called the <a href=\"http://en.wikipedia.org/wiki/Right_hand_rule\" rel=\"nofollow noreferrer\">right hand rule</a></p>\n"
        }
    ],
    "has_more": false,
    "quota_max": 10000,
    "quota_remaining": 9528
}