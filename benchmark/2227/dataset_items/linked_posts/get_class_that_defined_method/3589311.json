{
    "items": [
        {
            "tags": [
                "python",
                "python-3.x"
            ],
            "comments": [
                {
                    "owner": {
                        "account_id": 48895,
                        "reputation": 84197,
                        "user_id": 145403,
                        "user_type": "registered",
                        "display_name": "Ned Deily"
                    },
                    "edited": false,
                    "score": 5,
                    "creation_date": 1282971951,
                    "post_id": 3589311,
                    "comment_id": 3766468,
                    "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3#comment3766468_3589311",
                    "body": "The removal of unbound methods is documented here: <a href=\"http://docs.python.org/py3k/whatsnew/3.0.html#operators-and-special-methods\" rel=\"nofollow noreferrer\">docs.python.org/py3k/whatsnew/&hellip;</a>"
                },
                {
                    "owner": {
                        "account_id": 64585,
                        "reputation": 864610,
                        "user_id": 190597,
                        "user_type": "registered",
                        "accept_rate": 88,
                        "display_name": "unutbu"
                    },
                    "edited": false,
                    "score": 3,
                    "creation_date": 1282992514,
                    "post_id": 3589311,
                    "comment_id": 3767459,
                    "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3#comment3767459_3589311",
                    "body": "Guido van Rossum&#39;s rationale for removing unbound methods can be found here: <a href=\"http://mail.python.org/pipermail/python-dev/2005-January/050625.html\" rel=\"nofollow noreferrer\">mail.python.org/pipermail/python-dev/2005-January/050625.htm&zwnj;&#8203;l</a>, and the blog mentioned in that post is here: <a href=\"http://artima.com/weblogs/viewpost.jsp?thread=86641\" rel=\"nofollow noreferrer\">artima.com/weblogs/viewpost.jsp?thread=86641</a>"
                },
                {
                    "owner": {
                        "account_id": 91310,
                        "reputation": 5221,
                        "user_id": 250798,
                        "user_type": "registered",
                        "display_name": "Tim Yates"
                    },
                    "edited": false,
                    "score": 0,
                    "creation_date": 1283011009,
                    "post_id": 3589311,
                    "comment_id": 3768644,
                    "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3#comment3768644_3589311",
                    "body": "Thanks to all of you. That was exactly what I was looking for."
                },
                {
                    "owner": {
                        "account_id": 808621,
                        "reputation": 360780,
                        "user_id": 908494,
                        "user_type": "registered",
                        "accept_rate": 25,
                        "display_name": "abarnert"
                    },
                    "edited": false,
                    "score": 0,
                    "creation_date": 1414434934,
                    "post_id": 3589311,
                    "comment_id": 41803533,
                    "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3#comment41803533_3589311",
                    "body": "The solution described in the question you linked to (use a decorator to just tag the functions, and then use a class decorator to modify the tagged functions after the fact) has some nice advantages. It&#39;s explicit, it doesn&#39;t rely on anything tricky or not-well-known, it&#39;s guaranteed to work in any version of Python (well, you need decorators\u2026 but even without them, <code>spam = deco(spam)</code> works), it&#39;s flexible to a wide range of similar but not identical problems, \u2026"
                },
                {
                    "owner": {
                        "account_id": 3580038,
                        "reputation": 1688,
                        "user_id": 2988463,
                        "user_type": "registered",
                        "accept_rate": 59,
                        "display_name": "Pavel Patrin"
                    },
                    "edited": false,
                    "score": 1,
                    "creation_date": 1468949679,
                    "post_id": 3589311,
                    "comment_id": 64333946,
                    "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3#comment64333946_3589311",
                    "body": "Your example is incorrect. When you will use such decorator on a function in class it fails. Because function becomes a bound/unbound method on getting attribute."
                },
                {
                    "owner": {
                        "account_id": 91310,
                        "reputation": 5221,
                        "user_id": 250798,
                        "user_type": "registered",
                        "display_name": "Tim Yates"
                    },
                    "reply_to_user": {
                        "account_id": 3580038,
                        "reputation": 1688,
                        "user_id": 2988463,
                        "user_type": "registered",
                        "accept_rate": 59,
                        "display_name": "Pavel Patrin"
                    },
                    "edited": false,
                    "score": 1,
                    "creation_date": 1468958497,
                    "post_id": 3589311,
                    "comment_id": 64338952,
                    "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3#comment64338952_3589311",
                    "body": "@PavelPatrin You&#39;re right, looks like it only works as <code>decorator(Foo.bar)</code>, not as <code>@decorator</code>. I was probably doing something slightly different, but it&#39;s been six years and it never worked where I wanted it anyway, so who knows."
                },
                {
                    "owner": {
                        "account_id": 69533,
                        "reputation": 33443,
                        "user_id": 202229,
                        "user_type": "registered",
                        "accept_rate": 74,
                        "display_name": "smci"
                    },
                    "reply_to_user": {
                        "account_id": 48895,
                        "reputation": 84197,
                        "user_id": 145403,
                        "user_type": "registered",
                        "display_name": "Ned Deily"
                    },
                    "edited": false,
                    "score": 0,
                    "creation_date": 1535158035,
                    "post_id": 3589311,
                    "comment_id": 90977147,
                    "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3#comment90977147_3589311",
                    "body": "@NedDeily: slight correction: <b>unbound method <i>objects</i></b> were removed from Python 3, but <b>unbound methods</b> still exist, e.g. <code>str.split</code>"
                }
            ],
            "answers": [
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 91310,
                                "reputation": 5221,
                                "user_id": 250798,
                                "user_type": "registered",
                                "display_name": "Tim Yates"
                            },
                            "edited": false,
                            "score": 2,
                            "creation_date": 1283011477,
                            "post_id": 3589335,
                            "comment_id": 3768676,
                            "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/3589335#comment3768676_3589335",
                            "body": "That makes sense. I didn&#39;t even realize there was extra functionality for methods like the first-argument type checking--I just thought they would be normal functions with a few extra attributes. With that, I can completely understand the removal."
                        },
                        {
                            "owner": {
                                "account_id": 34048,
                                "reputation": 869830,
                                "user_id": 95810,
                                "user_type": "registered",
                                "accept_rate": 80,
                                "display_name": "Alex Martelli"
                            },
                            "reply_to_user": {
                                "account_id": 91310,
                                "reputation": 5221,
                                "user_id": 250798,
                                "user_type": "registered",
                                "display_name": "Tim Yates"
                            },
                            "edited": false,
                            "score": 2,
                            "creation_date": 1283040081,
                            "post_id": 3589335,
                            "comment_id": 3770662,
                            "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/3589335#comment3770662_3589335",
                            "body": "@Tim, yes, the check that the first argument was of an instance of the <code>.im_class</code> (including subclasses thereof of course) is why <code>im_class</code> was kept in the first place (and the same layer of indirectness wrapped around functions to make unbound methods, as needs to be wrapped anyway to make bound ones).  The underlying function always was (and still is for <i>bound</i> methods) the <code>.im_func</code>, BTW, never the method object itself."
                        },
                        {
                            "owner": {
                                "account_id": 117511,
                                "reputation": 11071,
                                "user_id": 307705,
                                "user_type": "registered",
                                "accept_rate": 73,
                                "display_name": "Mu Mind"
                            },
                            "edited": false,
                            "score": 2,
                            "creation_date": 1349407303,
                            "post_id": 3589335,
                            "comment_id": 17207979,
                            "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/3589335#comment17207979_3589335",
                            "body": "&quot;With Python 3, simplicity is back!&quot; sounds like it would make a good bumper sticker (or laptop sticker)."
                        },
                        {
                            "owner": {
                                "account_id": 441014,
                                "reputation": 7807,
                                "user_id": 830905,
                                "user_type": "registered",
                                "accept_rate": 84,
                                "display_name": "Gershom Maes"
                            },
                            "edited": false,
                            "score": 2,
                            "creation_date": 1443721479,
                            "post_id": 3589335,
                            "comment_id": 53616750,
                            "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/3589335#comment53616750_3589335",
                            "body": "Would anyone mind explaining how this answers tim&#39;s question? Thanks!"
                        },
                        {
                            "owner": {
                                "account_id": 34048,
                                "reputation": 869830,
                                "user_id": 95810,
                                "user_type": "registered",
                                "accept_rate": 80,
                                "display_name": "Alex Martelli"
                            },
                            "reply_to_user": {
                                "account_id": 441014,
                                "reputation": 7807,
                                "user_id": 830905,
                                "user_type": "registered",
                                "accept_rate": 84,
                                "display_name": "Gershom Maes"
                            },
                            "edited": false,
                            "score": 1,
                            "creation_date": 1443762111,
                            "post_id": 3589335,
                            "comment_id": 53630183,
                            "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/3589335#comment53630183_3589335",
                            "body": "@GershomMaes, if a question was, &quot;how do I get the defining class of a unicorn&quot;, are you really unable to see how &quot;unicorns don&#39;t exist&quot; answers it? The question being &quot;how do I get the defining class of an unbound method in Python 3&quot;, clearly &quot;unbound methods in Python 3 do not exist&quot; answers it in exactly the same way: obviously, you can&#39;t &quot;get the defining class&quot; (or any other characteristic) of something that just does not exist!-)"
                        },
                        {
                            "owner": {
                                "account_id": 441014,
                                "reputation": 7807,
                                "user_id": 830905,
                                "user_type": "registered",
                                "accept_rate": 84,
                                "display_name": "Gershom Maes"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1444068164,
                            "post_id": 3589335,
                            "comment_id": 53734779,
                            "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/3589335#comment53734779_3589335",
                            "body": "Ahh I see, I didn&#39;t realize the question was particularly asking about unbound methods! Thanks"
                        }
                    ],
                    "owner": {
                        "account_id": 34048,
                        "reputation": 869830,
                        "user_id": 95810,
                        "user_type": "registered",
                        "accept_rate": 80,
                        "display_name": "Alex Martelli"
                    },
                    "comment_count": 6,
                    "is_accepted": true,
                    "score": 47,
                    "last_activity_date": 1282965619,
                    "creation_date": 1282965619,
                    "answer_id": 3589335,
                    "question_id": 3589311,
                    "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/3589335#3589335",
                    "body": "<p>The point you appear to be missing is, in Python 3 the \"unbound method\" type has entirely disappeared -- a method, until and unless it's bound, is just a function, without the weird \"type-checking\" unbound methods used to perform.  This makes the language simpler!</p>\n\n<p>To wit...:</p>\n\n<pre><code>&gt;&gt;&gt; class X:\n...   def Y(self): pass\n... \n&gt;&gt;&gt; type(X.Y)\n&lt;class 'function'&gt;\n</code></pre>\n\n<p>and voila -- one less subtle concept and distinction to worry about.  Such simplifications are the core advantage of Python 3 wrt Python 2, which (over the years) had been accumulating so many subtleties that it was in danger (if features kept being added to it) of really losing its status as a <strong>simple</strong> language.  With Python 3, simplicity is <em>back</em>!-)</p>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 61226,
                                "reputation": 258,
                                "user_id": 3191103,
                                "user_type": "registered",
                                "display_name": "jobermark"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1550322340,
                            "post_id": 25959545,
                            "comment_id": 96230900,
                            "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/25959545#comment96230900_25959545",
                            "body": "This identifies @staticmethod&#39;s as methods with this base class. They really aren&#39;t.   Once you have the class you should check that not isinstance( cls.__dict__[meth.__name__], staticmethod ).  It is ambiguous whether you should also check for classmethod.  (The point of using <b>dict</b> is to dodge substitutions done by <b>get</b>) . I don&#39;t think you need to scan up the <b>mro</b> in this case, because the definition will really lie in whatever class <b>qualname</b> indicates, but I am not entirely certain.  (This insight comes from the new &#39;inspect.getattr_static&#39; method implementation)"
                        },
                        {
                            "owner": {
                                "account_id": 61226,
                                "reputation": 258,
                                "user_id": 3191103,
                                "user_type": "registered",
                                "display_name": "jobermark"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1550322805,
                            "post_id": 25959545,
                            "comment_id": 96231024,
                            "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/25959545#comment96231024_25959545",
                            "body": "Also, re: the edit.  set().union is <i>bound</i>.  It has a <b>self</b>.  So you can use the type of that as the declaring class.  And set.union has an <b>objclass</b>."
                        },
                        {
                            "owner": {
                                "account_id": 4837824,
                                "reputation": 9434,
                                "user_id": 3903832,
                                "user_type": "registered",
                                "display_name": "Yoel"
                            },
                            "reply_to_user": {
                                "account_id": 61226,
                                "reputation": 258,
                                "user_id": 3191103,
                                "user_type": "registered",
                                "display_name": "jobermark"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1550749143,
                            "post_id": 25959545,
                            "comment_id": 96388674,
                            "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/25959545#comment96388674_25959545",
                            "body": "@jobermark, thanks for your comments, but I don&#39;t quite follow. Can you provide an example for which the returned class is incorrect for a <code>@staticmethod</code> or a <code>@classmethod</code>? Also, regarding <code>set().union</code> and <code>int().__add__</code>, I&#39;d rather refrain from trying to obtain its &quot;<code>self</code> object&quot; unless I&#39;m certain that I&#39;m dealing with a bound method."
                        },
                        {
                            "owner": {
                                "account_id": 61226,
                                "reputation": 258,
                                "user_id": 3191103,
                                "user_type": "registered",
                                "display_name": "jobermark"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1550777922,
                            "post_id": 25959545,
                            "comment_id": 96406306,
                            "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/25959545#comment96406306_25959545",
                            "body": "The function takes an unbound method...  set().__add__ is a bound method.  And set.__add__ now has an <b>objclass</b> in Python 3.7.  So this special case from the comment has disappeared."
                        },
                        {
                            "owner": {
                                "account_id": 61226,
                                "reputation": 258,
                                "user_id": 3191103,
                                "user_type": "registered",
                                "display_name": "jobermark"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1550779630,
                            "post_id": 25959545,
                            "comment_id": 96407159,
                            "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/25959545#comment96407159_25959545",
                            "body": "Maybe I misunderstood.  I guess I am after something other than the defining class.  As named this is correct, but it is less useful than it might be.  The primary use is going to be to check that I can take an object of the returned class, .__get__ the method onto it to bind, and use the result as expected.  For staticmethods and classmethods this is not quite right.  You should not bind it to anything if it is a staticmethod, and if it is a classmethod you should bind it to the class."
                        },
                        {
                            "owner": {
                                "account_id": 21554,
                                "reputation": 17750,
                                "user_id": 52499,
                                "user_type": "registered",
                                "accept_rate": 83,
                                "display_name": "x-yuri"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1593970061,
                            "post_id": 25959545,
                            "comment_id": 110956465,
                            "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/25959545#comment110956465_25959545",
                            "body": "Your method doesn&#39;t work for <code>_io.BytesIO.__enter__</code>, as opposed to <a href=\"https://stackoverflow.com/a/13628116/52499\">this solution</a>. More on it <a href=\"https://gist.github.com/x-yuri/050c7a0c2133228d27666db092e30678\" rel=\"nofollow noreferrer\">here</a>."
                        },
                        {
                            "owner": {
                                "account_id": 4837824,
                                "reputation": 9434,
                                "user_id": 3903832,
                                "user_type": "registered",
                                "display_name": "Yoel"
                            },
                            "reply_to_user": {
                                "account_id": 21554,
                                "reputation": 17750,
                                "user_id": 52499,
                                "user_type": "registered",
                                "accept_rate": 83,
                                "display_name": "x-yuri"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1594030070,
                            "post_id": 25959545,
                            "comment_id": 110973085,
                            "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/25959545#comment110973085_25959545",
                            "body": "@x-yuri, thanks for your input. I&#39;ve adapted my answer to handle built-ins as well."
                        },
                        {
                            "owner": {
                                "account_id": 2216052,
                                "reputation": 51,
                                "user_id": 1956611,
                                "user_type": "registered",
                                "display_name": "user1956611"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1596646183,
                            "post_id": 25959545,
                            "comment_id": 111880468,
                            "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/25959545#comment111880468_25959545",
                            "body": "I had a need to inspect functions that might be wrapped as a partial function. Adding a check and recursive call at the top allows handling of any depth of partial function wrapping.      I don&#39;t understand why I can&#39;t create code blocks. Good luck deciphering this mess.      ~~~     def get_class_that_defined_method(meth: Callable):       if isinstance(meth, functools.partial):           return get_class_that_defined_method(meth.func)    ~~~"
                        },
                        {
                            "owner": {
                                "account_id": 4837824,
                                "reputation": 9434,
                                "user_id": 3903832,
                                "user_type": "registered",
                                "display_name": "Yoel"
                            },
                            "reply_to_user": {
                                "account_id": 2216052,
                                "reputation": 51,
                                "user_id": 1956611,
                                "user_type": "registered",
                                "display_name": "user1956611"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1596788442,
                            "post_id": 25959545,
                            "comment_id": 111929116,
                            "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/25959545#comment111929116_25959545",
                            "body": "@user1956611, thanks for your suggestion. I&#39;ve incorporated it into my answer. On a side note, code formatting in comments is done using ` (the backtick symbol), as detailed <a href=\"https://stackoverflow.com/editing-help#comment-formatting\">here</a>."
                        },
                        {
                            "owner": {
                                "account_id": 3018196,
                                "reputation": 1352,
                                "user_id": 2559785,
                                "user_type": "registered",
                                "accept_rate": 67,
                                "display_name": "studioj"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1609952266,
                            "post_id": 25959545,
                            "comment_id": 115982965,
                            "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/25959545#comment115982965_25959545",
                            "body": "awesome post! do you have an example of the __func__  not being present in a builtin? i cant find any"
                        },
                        {
                            "owner": {
                                "account_id": 3018196,
                                "reputation": 1352,
                                "user_id": 2559785,
                                "user_type": "registered",
                                "accept_rate": 67,
                                "display_name": "studioj"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1609954718,
                            "post_id": 25959545,
                            "comment_id": 115984278,
                            "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/25959545#comment115984278_25959545",
                            "body": "ah it seems like <code>class Z(object):  z = lambda: lambda: 1; get_class_that_defined_method(Z().z)</code> is such a thing , i think"
                        },
                        {
                            "owner": {
                                "account_id": 4837824,
                                "reputation": 9434,
                                "user_id": 3903832,
                                "user_type": "registered",
                                "display_name": "Yoel"
                            },
                            "reply_to_user": {
                                "account_id": 3018196,
                                "reputation": 1352,
                                "user_id": 2559785,
                                "user_type": "registered",
                                "accept_rate": 67,
                                "display_name": "studioj"
                            },
                            "edited": false,
                            "score": 1,
                            "creation_date": 1609973933,
                            "post_id": 25959545,
                            "comment_id": 115991137,
                            "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/25959545#comment115991137_25959545",
                            "body": "@studioj, I was actually referring to <code>io.BytesIO().__enter__</code> and <code>set().union</code> which are of type <code>builtin_function_or_method</code> and don&#39;t have the attribute <code>__func__</code>. Thank you for asking this question, prompting me to clarify this point in my answer."
                        },
                        {
                            "owner": {
                                "account_id": 15720374,
                                "reputation": 464,
                                "user_id": 11343425,
                                "user_type": "registered",
                                "display_name": "SurpriseDog"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1616262274,
                            "post_id": 25959545,
                            "comment_id": 117949209,
                            "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/25959545#comment117949209_25959545",
                            "body": "Wow. Glad I googled this before trying to figure it out myself, lol. :-)"
                        },
                        {
                            "owner": {
                                "account_id": 3280430,
                                "reputation": 403,
                                "user_id": 2761174,
                                "user_type": "registered",
                                "display_name": "Peter"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1642077028,
                            "post_id": 25959545,
                            "comment_id": 124978795,
                            "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/25959545#comment124978795_25959545",
                            "body": "I had an issue when using this snippet with <code>pytest --import-mode=importlib</code>: <a href=\"https://stackoverflow.com/q/70696622/2761174\">stackoverflow.com/q/70696622/2761174</a>"
                        },
                        {
                            "owner": {
                                "account_id": 4837824,
                                "reputation": 9434,
                                "user_id": 3903832,
                                "user_type": "registered",
                                "display_name": "Yoel"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1644561320,
                            "post_id": 25959545,
                            "comment_id": 125644092,
                            "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/25959545#comment125644092_25959545",
                            "body": "I didn&#39;t experience any issues with  <i>Python 3.8.10</i>, <i>pytest-7.0.0</i>, <i>pluggy-1.0.0</i>. We can continue the discussion in the comments section of <a href=\"https://stackoverflow.com/q/70696622/3903832\">your question</a>."
                        },
                        {
                            "owner": {
                                "account_id": 94703,
                                "reputation": 4927,
                                "user_id": 258418,
                                "user_type": "registered",
                                "accept_rate": 77,
                                "display_name": "ted"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1669806579,
                            "post_id": 25959545,
                            "comment_id": 131725358,
                            "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/25959545#comment131725358_25959545",
                            "body": "Is there any reason for using <code>getattr(obj, attr, None) is not None</code> over <code>hasattr</code>?"
                        },
                        {
                            "owner": {
                                "account_id": 4837824,
                                "reputation": 9434,
                                "user_id": 3903832,
                                "user_type": "registered",
                                "display_name": "Yoel"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1669915735,
                            "post_id": 25959545,
                            "comment_id": 131756876,
                            "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/25959545#comment131756876_25959545",
                            "body": "The outcome is different if <code>obj.attr</code> is <code>None</code>. To elaborate: if <code>obj.attr</code> is <code>None</code>, then <code>getattr(obj, attr, None) is not None</code> evaluates to <code>False</code> while <code>hasattr(obj, attr)</code> evaluates to <code>True</code>."
                        }
                    ],
                    "owner": {
                        "account_id": 4837824,
                        "reputation": 9434,
                        "user_id": 3903832,
                        "user_type": "registered",
                        "display_name": "Yoel"
                    },
                    "comment_count": 17,
                    "is_accepted": false,
                    "score": 125,
                    "last_activity_date": 1609973830,
                    "last_edit_date": 1609973830,
                    "creation_date": 1411305014,
                    "answer_id": 25959545,
                    "question_id": 3589311,
                    "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/25959545#25959545",
                    "body": "<p>I thought it would be worthwhile writing something that does it best at guessing the defining class. For completeness' sake this answer also addresses bound methods.</p>\n<p>At worst, guessing should fail altogether, with the function returning <code>None</code>. However, under any circumstances, it shouldn't raise an exception or return an incorrect class.</p>\n<h1>TL;DR</h1>\n<p>The final version of our function successfully overcomes most simple cases, and a few pitfalls as well.</p>\n<p>In a nutshell, its implementation differentiates between bound methods and <a href=\"https://docs.python.org/3.0/whatsnew/3.0.html#operators-and-special-methods\" rel=\"noreferrer\">\u201cunbound methods\u201c (functions)</a> since in <code>Python 3</code> there is no reliable way to extract the enclosing class from an \u201cunbound method&quot;.</p>\n<ul>\n<li>For a bound method, it simply traverses the <a href=\"http://makina-corpus.com/blog/metier/2014/python-tutorial-understanding-python-mro-class-search-path\" rel=\"noreferrer\"><code>MRO</code></a>, in a similar manner to that done in the <a href=\"https://stackoverflow.com/a/961057/3903832\">accepted answer to an equivalent question for <code>Python 2</code></a>.</li>\n<li>For an \u201cunbound method\u201c, it relies on parsing its <a href=\"https://docs.python.org/3.3/glossary.html#term-qualified-name\" rel=\"noreferrer\">qualified name</a>, which is <a href=\"https://docs.python.org/3.3/whatsnew/3.3.html#pep-3155-qualified-name-for-classes-and-functions\" rel=\"noreferrer\">available only from <code>Python 3.3</code></a> and is quite reckless (if this feature is unnecessary it's probably best to remove this block of code and just return <code>None</code> instead).</li>\n</ul>\n<p>Several useful comments prompted additional changes, as detailed in the edits section below, producing the following improvements:</p>\n<ul>\n<li>Limited handling for methods defined via descriptors, that aren't classified as ordinary methods or functions (for example, <code>set.union</code>, <code>int.__add__</code> and <code>int().__add__</code>) and for built-in methods (for example <code>set().union</code> and <code>io.BytesIO().__enter__</code>).</li>\n<li>Handling of <code>functools.partial</code> objects.</li>\n</ul>\n<p>The resulting function is:</p>\n\n<pre class=\"lang-py prettyprint-override\"><code>def get_class_that_defined_method(meth):\n    if isinstance(meth, functools.partial):\n        return get_class_that_defined_method(meth.func)\n    if inspect.ismethod(meth) or (inspect.isbuiltin(meth) and getattr(meth, '__self__', None) is not None and getattr(meth.__self__, '__class__', None)):\n        for cls in inspect.getmro(meth.__self__.__class__):\n            if meth.__name__ in cls.__dict__:\n                return cls\n        meth = getattr(meth, '__func__', meth)  # fallback to __qualname__ parsing\n    if inspect.isfunction(meth):\n        cls = getattr(inspect.getmodule(meth),\n                      meth.__qualname__.split('.&lt;locals&gt;', 1)[0].rsplit('.', 1)[0],\n                      None)\n        if isinstance(cls, type):\n            return cls\n    return getattr(meth, '__objclass__', None)  # handle special descriptor objects\n</code></pre>\n<h1>A small request</h1>\n<p>If you decide to use this implementation, and encounter any caveats, please comment and describe what happened.</p>\n<hr />\n<h1>The Full Version</h1>\n<h2>\u201cUnbound methods\u201d are regular functions</h2>\n<p>First of all, it's worth noting the following <a href=\"https://docs.python.org/3.0/whatsnew/3.0.html#operators-and-special-methods\" rel=\"noreferrer\">change</a> made in <code>Python 3</code> (see Guido's motivation <a href=\"http://www.artima.com/weblogs/viewpost.jsp?thread=86641#loose-ends\" rel=\"noreferrer\">here</a>):</p>\n<blockquote>\n<p>The concept of \u201cunbound methods\u201d has been removed from the language. When referencing a method as a class attribute, you now get a plain function object.</p>\n</blockquote>\n<p>This makes it practically impossible to reliably extract the class in which a certain \u201cunbound method\u201c was defined unless it's bound to an object of that class (or of one of its subclasses).</p>\n<h2>Handling bound methods</h2>\n<p>So, let us first handle the \u201ceasier case\u201c in which we have a bound method. Note that the bound method must be written in <code>Python</code>, as described in <a href=\"https://docs.python.org/3/library/inspect.html#inspect.ismethod\" rel=\"noreferrer\"><code>inspect.ismethod</code>'s documentation</a>.</p>\n<pre class=\"lang-py prettyprint-override\"><code>def get_class_that_defined_method(meth):\n    # meth must be a bound method\n    if inspect.ismethod(meth):\n        for cls in inspect.getmro(meth.__self__.__class__):\n            if meth.__name__ in cls.__dict__:\n                return cls\n    return None  # not required since None would have been implicitly returned anyway\n</code></pre>\n<p>However, this solution is not perfect and has its perils, as methods can be assigned in runtime, rendering their name possibly different than that of the attribute that they are assigned to (see example below). This problem exists also in <code>Python 2</code>. A possible workaround would be to iterate over all of the class's attributes, looking for one whose identity is that of the specified method.</p>\n<h2>Handling \u201cunbound methods\u201c</h2>\n<p>Now that we got that out of the way, we can suggest a hack that tries to handle \u201cunbound methods\u201d. The hack, its rationale, and some discouragement words can be found in <a href=\"https://stackoverflow.com/a/25922101/3903832\">this answer</a>. It relies on manually parsing <a href=\"https://docs.python.org/3.3/glossary.html#term-qualified-name\" rel=\"noreferrer\">the <code>__qualname__</code> attribute</a>, <a href=\"https://docs.python.org/3.3/whatsnew/3.3.html#pep-3155-qualified-name-for-classes-and-functions\" rel=\"noreferrer\">available only from <code>Python 3.3</code></a>, is highly unrecommended, but <em>should</em> work for <strong>simple</strong> cases:</p>\n<pre class=\"lang-py prettyprint-override\"><code>def get_class_that_defined_method(meth):\n    if inspect.isfunction(meth):\n        return getattr(inspect.getmodule(meth),\n                       meth.__qualname__.split('.&lt;locals&gt;', 1)[0].rsplit('.', 1)[0],\n                       None)\n    return None  # not required since None would have been implicitly returned anyway\n</code></pre>\n<h2>Combining both approaches</h2>\n<p>Since <code>inspect.isfunction</code> and <code>inspect.ismethod</code> are mutually exclusive, combining both approaches into a single solution gives us the following (with added logging facilities for the upcoming examples):</p>\n<pre class=\"lang-py prettyprint-override\"><code>def get_class_that_defined_method(meth):\n    if inspect.ismethod(meth):\n        print('this is a method')\n        for cls in inspect.getmro(meth.__self__.__class__):\n            if meth.__name__ in cls.__dict__:\n                return cls\n    if inspect.isfunction(meth):\n        print('this is a function')\n        return getattr(inspect.getmodule(meth),\n                       meth.__qualname__.split('.&lt;locals&gt;', 1)[0].rsplit('.', 1)[0],\n                       None)\n    print('this is neither a function nor a method')\n    return None  # not required since None would have been implicitly returned anyway\n</code></pre>\n<h2>Execution example</h2>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; class A:\n...     def a(self): pass\n... \n&gt;&gt;&gt; class B:\n...     def b(self): pass\n... \n&gt;&gt;&gt; class C(A, B):\n...     def a(self): pass\n... \n&gt;&gt;&gt; A.a\n&lt;function A.a at 0x7f13b58dfc80&gt;\n&gt;&gt;&gt; get_class_that_defined_method(A.a)\nthis is a function\n&lt;class '__main__.A'&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; A().a\n&lt;bound method A.a of &lt;__main__.A object at 0x7f13b58ca9e8&gt;&gt;\n&gt;&gt;&gt; get_class_that_defined_method(A().a)\nthis is a method\n&lt;class '__main__.A'&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; C.a\n&lt;function C.a at 0x7f13b58dfea0&gt;\n&gt;&gt;&gt; get_class_that_defined_method(C.a)\nthis is a function\n&lt;class '__main__.C'&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; C().a\n&lt;bound method C.a of &lt;__main__.C object at 0x7f13b58ca9e8&gt;&gt;\n&gt;&gt;&gt; get_class_that_defined_method(C().a)\nthis is a method\n&lt;class '__main__.C'&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; C.b\n&lt;function B.b at 0x7f13b58dfe18&gt;\n&gt;&gt;&gt; get_class_that_defined_method(C.b)\nthis is a function\n&lt;class '__main__.B'&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; C().b\n&lt;bound method C.b of &lt;__main__.C object at 0x7f13b58ca9e8&gt;&gt;\n&gt;&gt;&gt; get_class_that_defined_method(C().b)\nthis is a method\n&lt;class '__main__.B'&gt;\n</code></pre>\n<p>So far, so good, but...</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; def x(self): pass\n... \n&gt;&gt;&gt; class Z:\n...     y = x\n...     z = (lambda: lambda: 1)()  # this returns the inner function\n...     @classmethod\n...     def class_meth(cls): pass\n...     @staticmethod\n...     def static_meth(): pass\n...\n&gt;&gt;&gt; x\n&lt;function x at 0x7f13b58dfa60&gt;\n&gt;&gt;&gt; get_class_that_defined_method(x)\nthis is a function\n&lt;function x at 0x7f13b58dfa60&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; Z.y\n&lt;function x at 0x7f13b58dfa60&gt;\n&gt;&gt;&gt; get_class_that_defined_method(Z.y)\nthis is a function\n&lt;function x at 0x7f13b58dfa60&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; Z().y\n&lt;bound method Z.x of &lt;__main__.Z object at 0x7f13b58ca9e8&gt;&gt;\n&gt;&gt;&gt; get_class_that_defined_method(Z().y)\nthis is a method\nthis is neither a function nor a method\n&gt;&gt;&gt;\n&gt;&gt;&gt; Z.z\n&lt;function Z.&lt;lambda&gt;.&lt;locals&gt;.&lt;lambda&gt; at 0x7f13b58d40d0&gt;\n&gt;&gt;&gt; get_class_that_defined_method(Z.z)\nthis is a function\n&lt;class '__main__.Z'&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; Z().z\n&lt;bound method Z.&lt;lambda&gt; of &lt;__main__.Z object at 0x7f13b58ca9e8&gt;&gt;\n&gt;&gt;&gt; get_class_that_defined_method(Z().z)\nthis is a method\nthis is neither a function nor a method\n&gt;&gt;&gt;\n&gt;&gt;&gt; Z.class_meth\n&lt;bound method type.class_meth of &lt;class '__main__.Z'&gt;&gt;\n&gt;&gt;&gt; get_class_that_defined_method(Z.class_meth)\nthis is a method\nthis is neither a function nor a method\n&gt;&gt;&gt;\n&gt;&gt;&gt; Z().class_meth\n&lt;bound method type.class_meth of &lt;class '__main__.Z'&gt;&gt;\n&gt;&gt;&gt; get_class_that_defined_method(Z().class_meth)\nthis is a method\nthis is neither a function nor a method\n&gt;&gt;&gt;\n&gt;&gt;&gt; Z.static_meth\n&lt;function Z.static_meth at 0x7f13b58d4158&gt;\n&gt;&gt;&gt; get_class_that_defined_method(Z.static_meth)\nthis is a function\n&lt;class '__main__.Z'&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; Z().static_meth\n&lt;function Z.static_meth at 0x7f13b58d4158&gt;\n&gt;&gt;&gt; get_class_that_defined_method(Z().static_meth)\nthis is a function\n&lt;class '__main__.Z'&gt;\n</code></pre>\n<h2>Final touches</h2>\n<ul>\n<li><p>The outcome generated by <code>x</code> and <code>Z.y</code> can be partially fixed (to return <code>None</code>) by verifying that the returned value is a class, before actually returning it.</p>\n</li>\n<li><p>The outcome generated by <code>Z().z</code> can be fixed by falling back to parsing the function's <code>__qualname__</code> attribute (the function can be extracted via <code>meth.__func__</code>).</p>\n</li>\n<li><p>The outcome generated by <code>Z.class_meth</code> and <code>Z().class_meth</code> is incorrect because accessing a class method always returns a bound method, whose <code>__self__</code> attribute is the class itself, rather than its object. Thus, further accessing the <code>__class__</code> attribute on top of that <code>__self__</code> attribute doesn't work as expected:</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; Z().class_meth\n&lt;bound method type.class_meth of &lt;class '__main__.Z'&gt;&gt;\n&gt;&gt;&gt; Z().class_meth.__self__\n&lt;class '__main__.Z'&gt;\n&gt;&gt;&gt; Z().class_meth.__self__.__class__\n&lt;class 'type'&gt;\n</code></pre>\n<p>This can be fixed by checking whether the method's <code>__self__</code> attribute returns an instance of <code>type</code>. However, this might be confusing when our function is invoked against methods of a metaclass, so we'll leave it as is for now.</p>\n</li>\n</ul>\n<p>Here is the final version:</p>\n<pre class=\"lang-py prettyprint-override\"><code>def get_class_that_defined_method(meth):\n    if inspect.ismethod(meth):\n        for cls in inspect.getmro(meth.__self__.__class__):\n            if meth.__name__ in cls.__dict__:\n                return cls\n        meth = meth.__func__  # fallback to __qualname__ parsing\n    if inspect.isfunction(meth):\n        cls = getattr(inspect.getmodule(meth),\n                      meth.__qualname__.split('.&lt;locals&gt;', 1)[0].rsplit('.', 1)[0],\n                      None)\n        if isinstance(cls, type):\n            return cls\n    return None  # not required since None would have been implicitly returned anyway\n</code></pre>\n<p>Surprisingly, this also fixes the outcome of <code>Z.class_meth</code> and <code>Z().class_meth</code> which now correctly return <code>Z</code>. This is because the <code>__func__</code> attribute of a class method returns a regular function whose <code>__qualname__</code> attribute may be parsed:</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; Z().class_meth.__func__\n&lt;function Z.class_meth at 0x7f13b58d4048&gt;\n&gt;&gt;&gt; Z().class_meth.__func__.__qualname__\n'Z.class_meth'\n</code></pre>\n<hr />\n<p><strong>EDIT:</strong></p>\n<p>As per the issue raised by <a href=\"https://stackoverflow.com/users/487464/bryce-guinta\">Bryce</a>, it's possible to handle <code>method_descriptor</code> objects, like <code>set.union</code>, and <code>wrapper_descriptor</code> objects, like <code>int.__add__</code>, merely by returning their <a href=\"https://docs.python.org/3/reference/datamodel.html#implementing-descriptors\" rel=\"noreferrer\"><code>__objclass__</code></a> attribute (introduced by <a href=\"https://www.python.org/dev/peps/pep-0252/\" rel=\"noreferrer\">PEP-252</a>), if such exists:</p>\n<pre class=\"lang-py prettyprint-override\"><code>if inspect.ismethoddescriptor(meth):\n    return getattr(meth, '__objclass__', None)\n</code></pre>\n<p>However, <code>inspect.ismethoddescriptor</code> returns <code>False</code> for the respective instance method objects, i.e. for <code>set().union</code> and for <code>int().__add__</code>:</p>\n<ul>\n<li>Since <code>int().__add__.__objclass__</code> returns <code>int</code>, the above if clause may be relinquished in order to solve the problem for <code>int().__add__</code>. Unfortunately, this doesn't address the matter of <code>set().union</code>, for which no <code>__objclass__</code> attribute is defined. In order to avoid an <code>AttributeError</code> exception in such a case, the <code>__objclass__</code> attribute isn't accessed directly, but rather via the <code>getattr</code> function.</li>\n</ul>\n<hr />\n<p><strong>EDIT:</strong></p>\n<p>As per the <a href=\"https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/25959545?noredirect=1#comment110956465_25959545\">issue</a> raised by <a href=\"https://stackoverflow.com/users/52499/x-yuri\">x-yuri</a>, it seems that our function fails to handle the method <code>io.BytesIO().__enter__</code> since <code>inspect</code> doesn't identify it as a method, but rather as a built-in:</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; inspect.ismethod(io.BytesIO().__enter__)\nFalse\n&gt;&gt;&gt; inspect.isbuiltin(io.BytesIO().__enter__)\nTrue\n</code></pre>\n<p>This is the same issue encountered above in regard to <code>set().union</code>:</p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; inspect.ismethod(set().union)\nFalse\n&gt;&gt;&gt; inspect.isbuiltin(set().union)\nTrue\n</code></pre>\n<p>Other than this peculiarity, we can handle such methods as ordinary methods and extract the defining class by traversing the MRO.</p>\n<p>However, just to be on the safe side, we shall include an extra layer of protection and verify that the <code>__self__</code> attribute of such methods, if defined, isn't <code>None</code> and that the <code>__class__</code> attribute of that <code>__self__</code> object, if defined, isn't <code>None</code> as well:</p>\n<pre class=\"lang-py prettyprint-override\"><code>if inspect.ismethod(meth) or (inspect.isbuiltin(meth) and getattr(meth, '__self__', None) and getattr(meth.__self__, '__class__', None)):\n    # ordinary method handling\n</code></pre>\n<p>Alas, this simple test fails for <code>set().union</code> because <code>bool(set().union.__self__)</code> evaluates to <code>False</code> since <code>set().union.__self__</code> returns the empty set. Thus, an explicit test against <code>None</code> is required, producing the following fix:</p>\n<pre class=\"lang-py prettyprint-override\"><code>if inspect.ismethod(meth) or (inspect.isbuiltin(meth) and getattr(meth, '__self__', None) is not None and getattr(meth.__self__, '__class__', None)):\n    # ordinary method handling\n</code></pre>\n<p>A minor additional patch is advised in order to avoid a possible <code>AttributeError</code> exception when accessing the <code>__func__</code> attribute during fallback to <code>__qualname__</code> parsing. This is required since while the <code>__func__</code> attribute is guaranteed to exist for an ordinary method, it's not necessarily defined for one of the type <code>builtin_function_or_method</code>, such as <code>io.BytesIO().__enter__</code> and <code>set().union</code>.</p>\n<pre class=\"lang-py prettyprint-override\"><code>def get_class_that_defined_method(meth):\n    if inspect.ismethod(meth) or (inspect.isbuiltin(meth) and getattr(meth, '__self__', None) is not None and getattr(meth.__self__, '__class__', None)):\n        for cls in inspect.getmro(meth.__self__.__class__):\n            if meth.__name__ in cls.__dict__:\n                return cls\n        meth = getattr(meth, '__func__', meth)  # fallback to __qualname__ parsing\n    if inspect.isfunction(meth):\n        cls = getattr(inspect.getmodule(meth),\n                      meth.__qualname__.split('.&lt;locals&gt;', 1)[0].rsplit('.', 1)[0],\n                      None)\n        if isinstance(cls, type):\n            return cls\n    return getattr(meth, '__objclass__', None)  # handle special descriptor objects\n</code></pre>\n<hr />\n<p><strong>EDIT:</strong></p>\n<p>As per the <a href=\"https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/25959545?noredirect=1#comment111880468_25959545\">suggestion</a> put forward by <a href=\"https://stackoverflow.com/users/1956611/user1956611\">user1956611</a>, it's possible to handle <a href=\"https://docs.python.org/3/library/functools.html#partial-objects\" rel=\"noreferrer\"><code>partial</code> objects</a> by introducing a recursive call to seek out the original callable with which the <code>partial</code> object was created:</p>\n<pre class=\"lang-py prettyprint-override\"><code>if isinstance(meth, functools.partial):\n    return get_class_that_defined_method(meth.func)\n</code></pre>\n"
                },
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 12448472,
                                "reputation": 2374,
                                "user_id": 9063935,
                                "user_type": "registered",
                                "display_name": "dwb"
                            },
                            "edited": false,
                            "score": 1,
                            "creation_date": 1617385326,
                            "post_id": 54316923,
                            "comment_id": 118296840,
                            "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/54316923#comment118296840_54316923",
                            "body": "Be careful with this approach, as the decorator class (<code>particular_purpose</code>) will return <i>itself</i> and <b>not</b> the function, which means any decorators &quot;above&quot; it will incorrectly receive this object and likely malfunction. I would recommend using a class decorator (as shown <a href=\"https://stackoverflow.com/a/2367605/9063935\">here</a>) if you are tagging and then post-processing functions in the class."
                        }
                    ],
                    "owner": {
                        "account_id": 322098,
                        "reputation": 2194,
                        "user_id": 641317,
                        "user_type": "registered",
                        "display_name": "tyrion"
                    },
                    "comment_count": 1,
                    "is_accepted": false,
                    "score": 9,
                    "last_activity_date": 1548193598,
                    "creation_date": 1548193598,
                    "answer_id": 54316923,
                    "question_id": 3589311,
                    "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/54316923#54316923",
                    "body": "<p>Since python 3.6 you could accomplish what you are describing using a decorator that defines a <code>__set_name__</code> method. <a href=\"https://docs.python.org/3/reference/datamodel.html#object.__set_name__\" rel=\"noreferrer\">The documentation</a> states that <code>object.__set_name__</code> is called when the class is being created.</p>\n\n<p>Here is an example that decorates a method \"in order to register it in a list of methods that serve a particular purpose\":</p>\n\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; class particular_purpose: \n...     def __init__(self, fn): \n...         self.fn = fn \n...      \n...     def __set_name__(self, owner, name): \n...         owner._particular_purpose.add(self.fn) \n...          \n...         # then replace ourself with the original method \n...         setattr(owner, name, self.fn) \n...  \n... class A: \n...     _particular_purpose = set() \n...  \n...     @particular_purpose \n...     def hello(self): \n...         return \"hello\" \n...  \n...     @particular_purpose \n...     def world(self): \n...         return \"world\" \n...  \n&gt;&gt;&gt; A._particular_purpose\n{&lt;function __main__.A.hello(self)&gt;, &lt;function __main__.A.world(self)&gt;}\n&gt;&gt;&gt; a = A() \n&gt;&gt;&gt; for fn in A._particular_purpose: \n...     print(fn(a)) \n...                                                                                                                                     \nworld\nhello\n</code></pre>\n\n<p>Note that this question is very similar to <a href=\"https://stackoverflow.com/questions/2366713/can-a-python-decorator-of-an-instance-method-access-the-class\">Can a Python decorator of an instance method access the class?</a> and therefore my answer as well to <a href=\"https://stackoverflow.com/a/54316392/641317\">the answer I provided there</a>.</p>\n"
                },
                {
                    "owner": {
                        "account_id": 3184194,
                        "reputation": 11020,
                        "user_id": 4013571,
                        "user_type": "registered",
                        "accept_rate": 82,
                        "display_name": "Alexander McFarlane"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 2,
                    "last_activity_date": 1549645319,
                    "last_edit_date": 1549645319,
                    "creation_date": 1549645005,
                    "answer_id": 54597033,
                    "question_id": 3589311,
                    "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/54597033#54597033",
                    "body": "<p>A small extension for <strong>python 3.6</strong> (python 2.7 worked fine) to the great answer of <a href=\"https://stackoverflow.com/a/25959545/4013571\">https://stackoverflow.com/a/25959545/4013571</a></p>\n\n<pre><code>def get_class_that_defined_method(meth):\n    if inspect.ismethod(meth):\n        for cls in inspect.getmro(meth.__self__.__class__):\n            if cls.__dict__.get(meth.__name__) is meth:\n                return cls\n        meth = meth.__func__  # fallback to __qualname__ parsing\n    if inspect.isfunction(meth):\n        class_name = meth.__qualname__.split('.&lt;locals&gt;', 1)[0].rsplit('.', 1)[0]\n        try:\n            cls = getattr(inspect.getmodule(meth), class_name)\n        except AttributeError:\n            cls = meth.__globals__.get(class_name)\n        if isinstance(cls, type):\n            return cls\n    return None  # not required since None would have been implicitly returned anyway\n</code></pre>\n\n<p>I found the following adjustment was required for <code>doctest</code></p>\n\n<pre><code>        except AttributeError:\n            cls = meth.__globals__.get(class_name)\n</code></pre>\n\n<p>As for some reason, when using <code>nose</code> the <code>inspect.getmodule(meth)</code> didn't contain the defining class</p>\n"
                },
                {
                    "owner": {
                        "account_id": 1843044,
                        "reputation": 465,
                        "user_id": 2891209,
                        "user_type": "registered",
                        "accept_rate": 75,
                        "display_name": "JWCompDev"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 0,
                    "last_activity_date": 1645248132,
                    "creation_date": 1645248132,
                    "answer_id": 71182400,
                    "question_id": 3589311,
                    "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3/71182400#71182400",
                    "body": "<p>I made a basic wrapper object that wraps a function and includes info about the parent class and module of the function.</p>\n<p>I have included the 'get_class_that_defined_method' in <a href=\"https://stackoverflow.com/a/25959545/2891209\">Yoel's answer</a> as the way to get the class info.</p>\n<p><a href=\"https://gist.github.com/jwcompdev/65da6a59a6bcb44864de77b8a29baeed\" rel=\"nofollow noreferrer\">Here is a link to the GitHub gist of the file.</a></p>\n"
                }
            ],
            "owner": {
                "account_id": 91310,
                "reputation": 5221,
                "user_id": 250798,
                "user_type": "registered",
                "display_name": "Tim Yates"
            },
            "comment_count": 7,
            "is_answered": true,
            "accepted_answer_id": 3589335,
            "answer_count": 5,
            "score": 58,
            "last_activity_date": 1645248132,
            "creation_date": 1282965167,
            "last_edit_date": 1495541866,
            "question_id": 3589311,
            "link": "https://stackoverflow.com/questions/3589311/get-defining-class-of-unbound-method-object-in-python-3",
            "title": "Get defining class of unbound method object in Python 3",
            "body": "<p>Say I want to make a decorator for methods defined in a class. I want that decorator, when invoked, to be able to set an attribute on the class defining the method (in order to register it in a list of methods that serve a particular purpose).</p>\n\n<p>In Python 2, the <code>im_class</code> method accomplishes this nicely:</p>\n\n<pre><code>def decorator(method):\n  cls = method.im_class\n  cls.foo = 'bar'\n  return method\n</code></pre>\n\n<p>However, in Python 3, no such attribute (or a  replacement for it) seems to exist. I suppose the idea was that you could call <code>type(method.__self__)</code> to get the class, but this does not work for unbound methods, since <code>__self__ == None</code> in that case.</p>\n\n<p><strong>NOTE:</strong> This question is actually a bit irrelevant for my case, since I've chosen instead to set an attribute on the method itself and then have the instance scan through all of its methods looking for that attribute at the appropriate time. I am also (currently) using Python 2.6. However, I am curious if there is any replacement for the version 2 functionality, and if not, what the rationale was for removing it completely.</p>\n\n<p><strong>EDIT</strong>: I just found <a href=\"https://stackoverflow.com/questions/2188409/how-to-find-class-of-bound-method-during-class-construction-in-python-3-1\">this question</a>. This makes it seem like the best solution is just to avoid it like I have. I'm still wondering why it was removed though.</p>\n"
        }
    ],
    "has_more": false,
    "quota_max": 10000,
    "quota_remaining": 5784
}