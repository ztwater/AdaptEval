{
    "items": [
        {
            "tags": [
                "python-2.7",
                "python-mock"
            ],
            "comments": [
                {
                    "owner": {
                        "account_id": 317335,
                        "reputation": 27386,
                        "user_id": 633961,
                        "user_type": "registered",
                        "accept_rate": 66,
                        "display_name": "guettli"
                    },
                    "edited": false,
                    "score": 1,
                    "creation_date": 1502281834,
                    "post_id": 44768483,
                    "comment_id": 78140357,
                    "link": "https://stackoverflow.com/questions/44768483/python-mock-wrap-instance-method#comment78140357_44768483",
                    "body": "Here is a method which works, but it uses try..finally and not the mock library: <a href=\"https://stackoverflow.com/questions/45584656/max-recursion-depth-while-trying-to-mock-instance-method\" title=\"max recursion depth while trying to mock instance method\">stackoverflow.com/questions/45584656/&hellip;</a>"
                },
                {
                    "owner": {
                        "account_id": 26355,
                        "reputation": 309,
                        "user_id": 68505,
                        "user_type": "registered",
                        "accept_rate": 40,
                        "display_name": "Colin"
                    },
                    "reply_to_user": {
                        "account_id": 317335,
                        "reputation": 27386,
                        "user_id": 633961,
                        "user_type": "registered",
                        "accept_rate": 66,
                        "display_name": "guettli"
                    },
                    "edited": false,
                    "score": 1,
                    "creation_date": 1533326601,
                    "post_id": 44768483,
                    "comment_id": 90322052,
                    "link": "https://stackoverflow.com/questions/44768483/python-mock-wrap-instance-method#comment90322052_44768483",
                    "body": "I just spent a few hours trying to solve this same problem. Did you ever find something useful? @guettli&#39;s suggestion still relies on having a handle the the instance so it&#39;s not helpful if my tests isn&#39;t directly creating the instance."
                },
                {
                    "owner": {
                        "account_id": 9180890,
                        "reputation": 2558,
                        "user_id": 6824752,
                        "user_type": "registered",
                        "accept_rate": 75,
                        "display_name": "Filip Kilibarda"
                    },
                    "reply_to_user": {
                        "account_id": 26355,
                        "reputation": 309,
                        "user_id": 68505,
                        "user_type": "registered",
                        "accept_rate": 40,
                        "display_name": "Colin"
                    },
                    "edited": false,
                    "score": 0,
                    "creation_date": 1533330110,
                    "post_id": 44768483,
                    "comment_id": 90323334,
                    "link": "https://stackoverflow.com/questions/44768483/python-mock-wrap-instance-method#comment90323334_44768483",
                    "body": "@Colin Wrote out a relatively simple solution below."
                }
            ],
            "answers": [
                {
                    "comments": [
                        {
                            "owner": {
                                "account_id": 26355,
                                "reputation": 309,
                                "user_id": 68505,
                                "user_type": "registered",
                                "accept_rate": 40,
                                "display_name": "Colin"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1536854077,
                            "post_id": 51680037,
                            "comment_id": 91582263,
                            "link": "https://stackoverflow.com/questions/44768483/python-mock-wrap-instance-method/51680037#comment91582263_51680037",
                            "body": "I&#39;ve moved on from this problem, but this solution is very intriguing! I will give this a shot! Thanks for the idea @Filip Kilibarda!"
                        },
                        {
                            "owner": {
                                "account_id": 1146365,
                                "reputation": 2228,
                                "user_id": 1129015,
                                "user_type": "registered",
                                "display_name": "nitely"
                            },
                            "edited": false,
                            "score": 0,
                            "creation_date": 1545868165,
                            "post_id": 51680037,
                            "comment_id": 94716590,
                            "link": "https://stackoverflow.com/questions/44768483/python-mock-wrap-instance-method/51680037#comment94716590_51680037",
                            "body": "You still need the instance. How is this different from the OP code?"
                        },
                        {
                            "owner": {
                                "account_id": 9180890,
                                "reputation": 2558,
                                "user_id": 6824752,
                                "user_type": "registered",
                                "accept_rate": 75,
                                "display_name": "Filip Kilibarda"
                            },
                            "reply_to_user": {
                                "account_id": 1146365,
                                "reputation": 2228,
                                "user_id": 1129015,
                                "user_type": "registered",
                                "display_name": "nitely"
                            },
                            "edited": false,
                            "score": 2,
                            "creation_date": 1546215639,
                            "post_id": 51680037,
                            "comment_id": 94802409,
                            "link": "https://stackoverflow.com/questions/44768483/python-mock-wrap-instance-method/51680037#comment94802409_51680037",
                            "body": "@nitely Yeah you still need the instance to check the <code>call_count</code>, but you don&#39;t need the instance in order to apply the patch. This is useful in cases where a class is instantiated deep within the code under test and the instance is returned to the test code. When returned to the test code, the test can check the <code>call_count</code> of that particular instance. If you want to track the total sum <code>call_count</code> of all instances in the patch block without access to the instances themselves, then this is not the solution for you."
                        }
                    ],
                    "owner": {
                        "account_id": 9180890,
                        "reputation": 2558,
                        "user_id": 6824752,
                        "user_type": "registered",
                        "accept_rate": 75,
                        "display_name": "Filip Kilibarda"
                    },
                    "comment_count": 3,
                    "is_accepted": true,
                    "score": 11,
                    "last_activity_date": 1533330105,
                    "creation_date": 1533330105,
                    "answer_id": 51680037,
                    "question_id": 44768483,
                    "link": "https://stackoverflow.com/questions/44768483/python-mock-wrap-instance-method/51680037#51680037",
                    "body": "<p>The problem with my proposed and incorrect solution above</p>\n\n<pre><code>with patch(\"__main__.Foo.foo\", wraps=Foo.foo) as m:\n    ...\n</code></pre>\n\n<p>is that the <code>foo</code> method on <code>Foo</code> is mocked such that it wraps the unbound method <code>Foo.foo</code>, which naturally doesn't work, because the unbound method <code>Foo.foo</code> has no idea which instance it's attached to when called later on.</p>\n\n<p>The simplest solution I could think of</p>\n\n<pre><code>from mock import patch, MagicMock\n\nclass Foo:\n\n    def foo(self):\n        return \"foo\"\n\nclass MockFoo(Foo):\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # Every instance of MockFoo will now have its `foo` method \n        # wrapped in a MagicMock\n        self.foo = MagicMock(wraps=self.foo)\n\nwith patch(\"__main__.Foo\", MockFoo) as m:\n    foo = Foo()\n    print(foo.foo())\n    assert foo.foo.call_count == 1\n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 1387453,
                        "reputation": 5227,
                        "user_id": 1319147,
                        "user_type": "registered",
                        "accept_rate": 85,
                        "display_name": "Eugene D. Gubenkov"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 2,
                    "last_activity_date": 1619607370,
                    "last_edit_date": 1619607370,
                    "creation_date": 1619605674,
                    "answer_id": 67298460,
                    "question_id": 44768483,
                    "link": "https://stackoverflow.com/questions/44768483/python-mock-wrap-instance-method/67298460#67298460",
                    "body": "<p>This is so nasty with Python mocks so that I ended up building a custom patch implementation (extend with other features if required).</p>\n<pre><code>import contextlib\n\nclass Patcher:\n    UNCHANGED_RET = object()\n\n    def __init__(self):\n        self.call_count = 0\n        self.return_value = Patcher.UNCHANGED_RET\n\n\n@contextlib.contextmanager\ndef patch(klass, method_name):\n    patcher = Patcher()\n    orig_method = getattr(klass, method_name)\n\n    def new_method(myself, *args, **kwargs):\n        patcher.call_count += 1\n        orig_return_value = orig_method(myself, *args, **kwargs)\n\n        if patcher.return_value != Patcher.UNCHANGED_RET:\n            return patcher.return_value\n\n        return orig_return_value\n\n    setattr(klass, method_name, new_method)\n    yield patcher\n    setattr(klass, method_name, orig_method)\n</code></pre>\n<p>Use as follows:</p>\n<pre><code>class MyClass:\n    def f(self):\n        return 42\n\n\nx = MyClass()\nwith patch(MyClass, 'f') as f_patcher:\n    y = MyClass()  # inside or outside -- does not matter\n    assert x.f() == 42\n    assert f_patcher.call_count == 1\n    f_patcher.return_value = 7\n    assert y.f() == 7\n    assert f_patcher.call_count == 2\n</code></pre>\n"
                },
                {
                    "owner": {
                        "account_id": 2541415,
                        "reputation": 181,
                        "user_id": 9230828,
                        "user_type": "registered",
                        "display_name": "Benjamin Drung"
                    },
                    "comment_count": 0,
                    "is_accepted": false,
                    "score": 0,
                    "last_activity_date": 1653995383,
                    "last_edit_date": 1653995383,
                    "creation_date": 1653993780,
                    "answer_id": 72446339,
                    "question_id": 44768483,
                    "link": "https://stackoverflow.com/questions/44768483/python-mock-wrap-instance-method/72446339#72446339",
                    "body": "<p>While working on Apport, I ran into the exact same question. I experimented with multiple approaches and came up with this solution, which is the most elegant and readable one:</p>\n<pre class=\"lang-py prettyprint-override\"><code># Copyright (C) 2022, Benjamin Drung &lt;bdrung@posteo.de&gt;\n#\n# Permission to use, copy, modify, and/or distribute this software for any\n# purpose with or without fee is hereby granted, provided that the above\n# copyright notice and this permission notice appear in all copies.\n#\n# THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\nimport contextlib\nimport typing\nimport unittest.mock\n\n@contextlib.contextmanager\ndef wrap_object(\n    target: object, attribute: str\n) -&gt; typing.Generator[unittest.mock.MagicMock, None, None]:\n    &quot;&quot;&quot;Wrap the named member on an object with a mock object.\n\n    wrap_object() can be used as a context manager. Inside the\n    body of the with statement, the attribute of the target is\n    wrapped with a :class:`unittest.mock.MagicMock` object. When\n    the with statement exits the patch is undone.\n\n    The instance argument 'self' of the wrapped attribute is\n    intentionally not logged in the MagicMock call. Therefore\n    wrap_object() can be used to check all calls to the object,\n    but not differentiate between different instances.\n    &quot;&quot;&quot;\n    mock = unittest.mock.MagicMock()\n    real_attribute = getattr(target, attribute)\n\n    def mocked_attribute(self, *args, **kwargs):\n        mock.__call__(*args, **kwargs)\n        return real_attribute(self, *args, **kwargs)\n\n    with unittest.mock.patch.object(target, attribute, mocked_attribute):\n        yield mock\n</code></pre>\n<p>Unittest for <code>wrap_object</code>:</p>\n<pre class=\"lang-py prettyprint-override\"><code>class Multiply:\n    &quot;&quot;&quot;Test class for wrap_object test cases.&quot;&quot;&quot;\n\n    def __init__(self, multiplier):\n        self.multiplier = multiplier\n\n    def multiply(self, x: int) -&gt; int:\n        return x * self.multiplier\n\n\nclass TestWrapObject(unittest.TestCase):\n    def test_wrap_object_with_statement(self):\n        with wrap_object(Multiply, &quot;__init__&quot;) as mock:\n            m = Multiply(7)\n            self.assertEqual(m.multiply(6), 42)\n        mock.assert_called_once_with(7)\n</code></pre>\n<p>Then you can use following code in your initial example:</p>\n<pre><code>&gt;&gt;&gt; with wrap_object(Foo, &quot;foo&quot;) as m:\n...     foo = Foo()\n...     print(foo.foo())\n... \nfoo\n&gt;&gt;&gt; m.assert_called_once_with()\n&gt;&gt;&gt; m.call_count\n1\n&gt;&gt;&gt; \n</code></pre>\n"
                }
            ],
            "owner": {
                "account_id": 9180890,
                "reputation": 2558,
                "user_id": 6824752,
                "user_type": "registered",
                "accept_rate": 75,
                "display_name": "Filip Kilibarda"
            },
            "comment_count": 3,
            "is_answered": true,
            "accepted_answer_id": 51680037,
            "answer_count": 3,
            "score": 12,
            "last_activity_date": 1653995383,
            "creation_date": 1498510310,
            "last_edit_date": 1498510612,
            "question_id": 44768483,
            "link": "https://stackoverflow.com/questions/44768483/python-mock-wrap-instance-method",
            "title": "Python mock: wrap instance method",
            "body": "<p><strong>What I would like:</strong>\nEnsure that all instances of <code>Foo</code> that are created inside the <code>with</code> statement have their <code>foo</code> instance method wrapped in a MagicMock via <code>wraps=Foo.foo</code>. The reason I want this is so that I can track <code>call_count</code> on the method <code>foo</code> for all instances of <code>Foo</code> that are created. Now that I say it like that it seems kind of impossible...</p>\n\n<pre><code>&gt;&gt;&gt; from mock import patch\n...\n... class Foo(object):\n...\n...     def foo(self):\n...         return \"foo\"\n...\n... with patch(\"__main__.Foo.foo\", wraps=Foo.foo) as m:\n...     foo = Foo()\n...     print(foo.foo())\n\nTraceback (most recent call last):\n  File \"a.py\", line 12, in &lt;module&gt;\n    print(foo.foo())\n  File \"/disk/software/lib/python27/mock/mock.py\", line 1062, in __call__\n    return _mock_self._mock_call(*args, **kwargs)\n  File \"/disk/software/lib/python27/mock/mock.py\", line 1132, in _mock_call\n    return self._mock_wraps(*args, **kwargs)\nTypeError: unbound method foo() must be called with Foo instance as first argument (got nothing instead)\n</code></pre>\n\n<p><strong>The problem</strong>\nThe mocked <code>foo</code> method isn't bound to the <code>foo</code> instance created via <code>foo = Foo()</code> because it's wrapping the unbound method <code>Foo.foo</code>. Does anyone know how to ensure that the mocked method is bound to an instance?</p>\n\n<p><strong>What I already know:</strong></p>\n\n<pre><code>&gt;&gt;&gt; foo = Foo()\n... with patch.object(foo, \"foo\", wraps=foo.foo) as m:\n...     print(foo.foo())\n\"foo\"\n</code></pre>\n\n<p>But this doesn't satisfy my constraint that the object must be instantiated inside the <code>patch</code> context.</p>\n"
        }
    ],
    "has_more": false,
    "quota_max": 10000,
    "quota_remaining": 6723
}